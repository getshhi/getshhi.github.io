[{"content":"Linux 拷贝目录 Linux中使用cp -r命令将一个或多个源目录复制到指定的目录下。它可以将单个源目录复制成一个指定目录名的具体的目录或一个已经存在的目录下。\n具体命令如下：cp 参数 源目录 目的目录\n常用参数如下：\n-r 是递归把源目录下的目录递归进行移动；\n-f：强行复制文件或目录，不论目标文件或目录是否已存在；\n-i：覆盖既有文件之前先询问用户；\n-p：保留源文件或目录的属性。 具体说明：\ncp命令支持同时复制多个目录，当一次复制多个目录时，目的目录参数必须是一个已经存在的目录，否则将出现错误；\ncp命令支持同时复制多个目录，当一次复制多个目录时，多个目录名用空格分隔；\ncp命令拷贝目录和拷贝文件大致用法相似，最大差别就是拷贝目录的时候必须加上-r参数，而拷贝文件的时候不需要加-r参数。\n应用示例一:\n将当前目录下的一个目录拷贝到指定的目录下，被拷贝目录名为：Dir1，指定目录名为：Dir2，则可以使用如下命令：\ncp -r Dir1 Dir2\n使用ls命令来查看目录是否拷贝成功。\n应用示例二:\n将当前目录下的一个目录拷贝到一个指定的目录下并重命名为Dir1Cpy，被拷贝目录名为：Dir1，指定目录名为：Dir2，则可以使用如下命令：\ncp -r Dir1 Dir2/Dir1Cpy\n使用ls命令来查看目录是否拷贝成功。\n应用示例三:\n将当前目录下的两个目录拷贝到一个指定的目录下，被拷贝目录名为：Dir1和Dir2，指定目录名为：Dir3，则可以使用如下命令：\ncp -r Dir1 Dir2 Dir3\n使用ls命令来查看目录是否拷贝成功。\nLinux 重命名目录 Linux中使用mv命令来重命名一个目录名。\nmv命令还可以用来移动目录，类似于Windows上的剪切功能。\n具体命令如下：mv 参数 源目录 目的目录\n常用参数如下：\n-f：若目标目录与现有的目录重复，则直接合并现有的目录；\n-i：交互式操作，覆盖前先行询问用户，如果源目录与目标目录同名，则询问用户是否合并目标目录。用户输入”y”，表示将合并目标目录；输入”n”，表示取消对源目录的移动。这样可以避免误将目录覆盖。 具体说明：\n如果一次想移动多个目录，则每个目录名用空格隔开。\nmv命令可以使用通配符来移动目录。\nmv命令移动目录和移动文件的使用大致一样，唯一不同的是如果出现源目录和目标目录重名，则采用合并的方式，而对于文件则是直接覆盖。\n应用示例一:\n将当前目录下的目录newDir重命名为newDirCpy，则可以使用如下命令:\nmv newDir newDirCpy\n使用ls命令来查看目录是否重命名成功。\n应用示例二:\n将当前目录下的目录newDirCpy移动到一个指定的目录下，指定目录名为：Dir，则可以使用如下命令：\nmv newDirCpy Dir\n使用ls命令来查看目录是否移动成功。\n应用示例三:\n将当前目录下的目录newDirCpy移动到一个指定的目录下并重命名为newDir，指定目录名为：Dir，则可以使用如下命令：\nmv newDirCpy Dir/newDir\n使用ls命令来查看目录是否移动和重命名成功。\n","date":"2025-01-05T15:44:26+08:00","image":"https://getshhi.github.io/op6.png","permalink":"https://getshhi.github.io/p/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6/%E9%87%8D%E5%91%BD%E5%90%8D/","title":"Linux的目录复制/重命名"},{"content":"Linux 拷贝文件 Linux中使用cp命令将一个或多个源文件复制到指定的目的目录下。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。\n具体命令如下：cp 参数 源文件 目的目录\n常用参数如下：\n-f：强行复制文件或目录，不论目标文件或目录是否已存在；\n-i：覆盖既有文件之前先询问用户；\n-p：保留源文件或目录的属性。 具体说明：\ncp命令支持同时复制多个文件，当一次复制多个文件时，目的目录参数必须是一个已经存在的目录，否则将出现错误；\ncp命令支持同时复制多个文件，当一次复制多个文件时，多个文件用空格分隔。\n应用示例一：\n将当前目录下的一个文件拷贝到一个指定的目录下，文件名为：newFile，目录名为：newDir，则可以使用如下命令：\ncp newFile newDir\n使用ls命令来查看文件是否拷贝成功。\n应用示例二:\n将当前目录下的一个文件拷贝到一个指定的目录下并重命名为newFileCpy，文件名为：newFile，目录名为：newDir，则可以使用如下命令：\ncp newFile newDir/newFileCpy\n使用ls命令来查看文件是否拷贝成功。\n应用示例三:\n将当前目录下的两个文件拷贝到一个指定的目录下，文件名为：newFile1和newFile2，目录名为：newDir1，则可以使用如下命令：\ncp newFile1 newFile2 newDir1\n使用ls命令来查看文件是否拷贝成功。\nLinux 重命名文件 Linux中使用mv命令来重命名一个文件名。\nmv命令还可以用来移动文件，类似于Windows上的剪切功能。\n具体命令如下：mv 参数 目录名\n常用参数如下：\n-f：若目标文件与现有的文件重复，则直接覆盖现有的文件； -i：交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。 具体说明：\n如果一次想移动多个文件，则每个文件名用空格隔开；\nmv命令可以使用通配符来移动目录。\n应用示例一:\n将当前目录下的文件newFile重命名为newFileRename，则可以使用如下命令:\nmv newFile newFileRename\n使用ls命令来查看文件是否重命名成功。\n应用示例二:\n将当前目录下的文件newFileRename移动到一个指定的目录下，目录名为：Dir，则可以使用如下命令：\nmv newFileRename Dir\n使用ls命令来查看文件是否移动成功。\n应用示例三:\n将当前目录下的文件newFileRename移动到一个指定的目录下并重命名为newFile，目录名为：Dir，则可以使用如下命令：\nmv newFileRename Dir/newFile\n使用ls命令来查看文件是否移动和重命名成功。\n","date":"2025-01-04T15:44:08+08:00","image":"https://getshhi.github.io/op5.png","permalink":"https://getshhi.github.io/p/linux%E7%9A%84%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6/%E9%87%8D%E5%91%BD%E5%90%8D/","title":"Linux的复制文件复制/重命名"},{"content":"Linux 创建目录 Linux中使用mkdir命令来创建一个空目录。\n具体命令如下：mkdir 参数 目录名\n常用参数如下：\n-p或\u0026ndash;parents：若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。 具体说明：\n如果一次想创建多个目录，则每个目录名用空格隔开；\nmkdir命令创建一个指定的目录，并将当前登录用户作为目录所有者；\nmkdir命令创建一个空目录后，该目录下只存在两个特殊的目录，分别是.和..。\n应用示例一:\n在Linux系统命令行下创建一个新的目录，目录名为：newDir，则可以使用如下命令：\nmkdir newDir\n使用ls命令来查看目录是否创建成功。\n应用示例二:\n在Linux系统命令行下一次创建2个目录，目录名分别为：newDir1和newDir2，则可以使用如下命令：\nmkdir newDir1 newDir2\n使用ls命令来查看目录是否创建成功。\n应用示例三:\n在Linux系统命令行下创建一个目录如果上层目录目前尚未建立则一并将其创建，目录名分别为：Dir1/Dir2，则可以使用如下命令：\nmkdir -p Dir1/Dir2\n首先查看Dir1目录是否存在，如果不存在直接创建Dir1/Dir2，使用ls命令查看目录是否创建成功。\nLinux 删除目录 Linux中使用rmdir命令来删除一个已经存在的空目录。\n具体命令如下：rmdir 参数 目录名\n常用参数如下：\n-p或\u0026ndash;parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。 具体说明：\n如果一次想删除多个空目录，则每个目录名用空格隔开；\nrmdir命令可以使用通配符来删除目录。\n如果想删除的目录不为空，则先使用rm命令将目录下的所有文件都清空，然后再使用rmdir将目录删除，或者直接使用rm -r命令直接递归的删除整个目录。\n应用示例一:\n在Linux系统命令行下删除一个空目录，目录名为：newDir，则可以使用如下命令：\nrmdir newDir\n使用ls命令来查看目录是否删除成功。\n应用示例二:\n在Linux系统命令行下一次删除2个空目录，目录名分别为：newDir1和newDir2，则可以使用如下命令：\nrmdir newDir1 newDir2\n使用ls命令来查看目录是否删除成功。\n应用示例三:\n在Linux系统命令行下删除一个目录如果上层目录为空则一并将其删除，目录名分别为：Dir1/Dir2，则可以使用如下命令：\nrmdir -p Dir1/Dir2\n使用ls命令来查看目录是否删除成4。\n应用示例四:\n在Linux系统命令行下删除一个不为空的目录，则可以使用如下命令：\nrm -r Dir\n使用ls命令来查看目录是否删除成功。\n","date":"2025-01-03T15:44:00+08:00","image":"https://getshhi.github.io/op4.png","permalink":"https://getshhi.github.io/p/linux%E7%9A%84%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA/%E5%88%A0%E9%99%A4/","title":"Linux的目录创建/删除"},{"content":"Linux 创建文件 Linux中使用touch命令来创建一个空文件。\n具体命令如下：touch 文件名\n具体说明：\n如果一次想创建多个文件，则每个文件名用空格隔开；\ntouch命令创建一个指定的新文件，并将当前登录用户作为文件所有者；\n由于touch命令创建的文件为空，所以文件的大小为0；\ntouch命令还可以用于更改文件的访问时间和修改时间，而不改变文件的内容。\n应用示例一：\n在Linux系统命令行下创建一个新的文件，文件名为：newFile，则可以使用如下命令：\ntouch newFile\n使用ls命令来查看文件是否创建成功。\n应用示例二：\n在Linux系统命令行下一次创建2个文件，文件名分别为：newFile1和newFile2，则可以使用如下命令：\ntouch newFile1 newFile2\n使用ls命令来查看文件是否创建成功。\nLinux 删除文件 Linux中使用rm命令来删除一个已经存在的文件。\n具体命令如下：rm 参数 文件名\n常用参数如下：\n-f：强制删除文件或目录；\n-i：删除已有文件或目录之前先询问用户；\n-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理。 具体说明：\n如果一次想删除多个文件，则每个文件名用空格隔开；\nrm命令可以使用通配符来删除文件。\n应用示例一：\n在Linux系统命令行下删除一个文件，文件名为：newFile，则可以使用如下命令：\nrm newFile\n使用ls命令来查看文件是否删除成功。\n应用示例2：\n在Linux系统命令行下一次删除2个文件，文件名分别为：newFile1和newFile2，则可以使用如下命令：\nrm newFile1 newFile2 使用ls命令来查看文件是否删除成功。\n应用示例三：\n在Linux系统命令行下删除一个文件同时删除前询问用户，文件名分别为：newFile，则可以使用如下命令：\nrm -i newFile\n","date":"2025-01-02T13:54:37+08:00","image":"https://getshhi.github.io/op3.png","permalink":"https://getshhi.github.io/p/linux%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA/%E5%88%A0%E9%99%A4/","title":"Linux的文件创建/删除"},{"content":"mkfs的作用 mkfs 命令用于在特定的分区上建立 linux 文件系统\nmkfs 本身并不执行建立文件系统的工作,而是去调用相关的程序来执行。\nmkfs 命令通常用于在设备硬件分区上创建 linux 文件系统。\nmkfs 命令支持建立多种 Linux 文件系统，如 ext 系列，xfs 等等。实际上 mkfs 是支持多种文件系统构建命令 mkfs. TYPE 的前部分，mkfs 命令通常执行的时候也是调用mkfs. TYPE 来执行，如 mkfs.ext2， mkfs.ext3， mkfs.ext4，mkfs.vfs，mkfs.vfat 等等。\nmkfs的使用 使用格式：\nmkfs [-V] [-t fstype] [fs-options] filesys [blocks]\n参数 ：\ndevice ： 预备检查的硬盘分区，例如：/dev/sda1\n-V : 详细显示模式\n-t : 给定档案系统的型式，Linux 的预设值为 ext2\n-c : 在制做档案系统前，检查该 partition 是否有坏轨\n-l bad_blocks_file : 将有坏轨的 block 资料加到 bad_blocks_file 里面\n例如将新创建的分区格式化为 exit4 格式： 只有将创建的分区格式化之后才能够使用，否则创建的分区是不能使用的，经过格式化之后的分区虽然可以使用了，但是这个分区格式化后需要挂载到一个文件内才可以使用\n","date":"2025-01-01T11:15:07+08:00","image":"https://getshhi.github.io/op2.png","permalink":"https://getshhi.github.io/p/linuxmkfs%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Linuxmkfs的使用"},{"content":"fdisk基本介绍 fdisk 是 Linux 中常用的硬盘管理工具，是一个创建和维护分区表的程序，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的磁盘列表。\nfdisk 是常用的 Linux 系统分区工具，使用 fdisk 可以对硬盘分区进行各种操作。\nfdisk具体使用 语法：fdisk (选项) (参数)\n选项： -b：\u0026lt;分区大小\u0026gt;：指定每个分区的大小； -l：列出指定的外围设备的分区表状况； -s：\u0026lt;分区编号\u0026gt;：将指定的分区大小输出到标准输出上，单位为区块； -u：搭配\u0026quot;-l\u0026quot;参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址； -v：显示版本信息。 例如：对新增加的硬盘进行分区\n通过上面的图片可以看到目前 sdb 并没有进行分区，也没有被使用过，而硬盘 sda 已经被使用，我们将通过使用 fdisk 命令学会对硬盘进行管理，在 Linux 系统中 dev 是设备 (device) 的英文缩写，而 Linux 系统之中将设备认成一个文件，所以可以在目录 dev 中看到 sda 以及 sdb ，在Linux系统中 /dev/sda 指的是第一块硬盘， /dev/sdb 指的是第二快硬盘，以此类推。\n可以直接使用 fdisk /dev/sdb 对硬盘 sdb 进行操作。\n输入 m 列出可以执行的命令：\n输入 n 可以建立新的磁盘分区：\n选择 p 建立主分区，主分区最多可以建四个。\nPartition number 选择分区号，可以不输入直接使用默认的分区号，\nFirst sector 指的是选择分区的起始位置，可以直接回车选择默认的分区号，\nLast sector 指的是选择结尾的扇区，也可以直接输想创建的分区的大小加单位。\n创建完成之后要输入 w 保存，否则系统不会对硬盘进行操作，保存之后会自动退出程序。\n保存之后可以继续使用 fdisk 命令查看分区情况：\n在创建完分区之后是不能直接使用的，必须经过格式化之后才能够使用。\n","date":"2024-12-31T11:15:00+08:00","image":"https://getshhi.github.io/nq3.png","permalink":"https://getshhi.github.io/p/linuxfdisk%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"Linuxfdisk的使用"},{"content":"直接附加的存储DAS Linux 支持种类繁多的 DAS 界面，包括像并行高级技术附件的旧标准 — 电子集成驱动器 IDE/ATA — 并行 SCSI 和光纤通道以及新的存储界面，例如串行连接的 SCSI、串行 ATA 和外部 SATA 。您还将发现高级存储技术，例如 USB3（可扩展的主机控制器界面）和 Firewire 。\n存储区域网络SAN SAN 提供块级存储合并，以便在一些服务器中共享它。存储对服务器显示为是本地的，其中端点存储设备可以为客户端设备实现附加服务（例如备份和复制）。\nSAN 的协议和界面是广泛和多样的。可以在 Linux 中发现典型的 SAN 协议，例如光纤通道以及其通过 IP 的扩展 (iFCP)。还存在更新的协议，例如 SAS、以太网光纤通道以及 iSCSI 。\n作为存储协议出现的以太网已经在 Linux 中完全实现，其说明了这些方法的力量和灵活性。 Linux 完全支持 10 千兆位以太网，并允许构造高性能 SAN 。\n网络附加存储NAS NAS 是通过网络的存储合并，以便不同类型客户端在文件级别进行访问。Linux 中完全支持的两种最流行协议是网络文件系统 NFS 和服务器消息块/通用互联网文件系统 SMB/CIFS 。\n虽然原始的 SMB 实现是专有的，但是它被逆向设计以便在 Linux 中受到支持。后来的 SMB 修订版被公开记录以便允许在 Linux 中进行更简单的开发。\nLinux 继续发展针对 NFS 的各种增强和扩展。NFS 现在是一个状态协议并包括对数据和元数据分离的优化以及数据访问并行。\n","date":"2024-12-30T11:12:49+08:00","image":"https://getshhi.github.io/op1.png","permalink":"https://getshhi.github.io/p/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84/","title":"Linux常见的存储架构"},{"content":"Linux查看用户属性命令 Linux中使用id命令可以查看用户的大多数信息。具体使用方法请参看上一关的实训。\nLinux中还可以通过查看/etc/passwd文件来获取用户的信息。具体方法可以参考背景知识。\nLinux中还可以使用finger命令来查询用户的信息。\n注意：Ubuntu系统中默认没有安装finger命令，用户可以通过以下命令来安装finger，然后就可以使用finger。\nsudo apt-get install finger\n具体使用方法如下：\n命令格式：finger [命令参数] 参数\n常见命令参数\n-l：多行显示； -s：单行显示。这个选项只显示登入名称、真实姓名、终端机名称、闲置时间、登入时间、办公室号码及电话号码。如果所查询的使用者是远端服务器的使用者，这个选项无效。 案例演示: 使用finger命令查看用户信息。\n例如，查看系统中已经存在的用户newUser信息。\nLinux用户信息修改命令 Linux 中usermod命令是最强大的用户账户修改实用工具。\nusermod命令我们在上一关只是简单的用到其-g、-G参数对用户的所属组进行修改，本关我们将进一步使用usermod命令的其它属性进行修改更多的属性。\n命令格式：usermod [命令参数] 参数\n常见命令参数：\n-c\u0026lt;备注\u0026gt;：修改用户帐号的备注文字； -d\u0026lt;登入目录\u0026gt;：修改用户登入时的目录； -e\u0026lt;有效期限\u0026gt;：修改帐号的有效期限； -f\u0026lt;缓冲天数\u0026gt;：修改在密码过期后多少天即关闭该帐号； -g\u0026lt;群组\u0026gt;：修改用户所属的群组； -G\u0026lt;群组\u0026gt;；修改用户所属的附加群组； -l\u0026lt;帐号名称\u0026gt;：修改用户帐号名称； -L：锁定用户密码，使密码无效； -s：修改用户登入后所使用的shell； -u：修改用户ID； -U:解除密码锁定。 usermod必须以root权限才能执行，如果是普通用户想使用该命令时，需要在命令前加sudo命令来提升权限为root权限。 案例演示一:\n使用usermod命令修改用户名。\n例如，在系统中已经存在一个用户名为oldUser的用户，由于某种原因，现在必须将其修改成newUser。\n案例演示二:\n使用usermod命令修改用户登录目录。\n首先使用finger命令查看用户newUser的登录目录为/home/oldUser，然后新创建一个/home/newUser，使用usermod将用户newUser的登录目录修改成/home/newUser，最后使用finger命令查看是否修改成功。\nLinux用户组信息修改命令 Linux 中使用groupmod命令来修改用户组信息。\n命令格式：groupmod [命令参数] 参数\n常见命令参数：\n-g\u0026lt;群组识别码\u0026gt;：设置欲使用的群组识别码； -n\u0026lt;新群组名称\u0026gt;：设置欲使用的群组名称。 groupmod必须以root权限才能执行，如果是普通用户想使用该命令时，需要在命令前加sudo命令来提升权限为root权限。 案例演示:\n使用groupmod命令修改已有用户组名称。\n首先通过tail命令查看一个已有用户组信息，可以看到该用户组名为oldUser，并且组ID为1004，通过groupmod命令将其名由oldUser修改成renameOldUser，最后使用再查看是否修改成功。\n","date":"2024-12-29T17:46:37+08:00","image":"https://getshhi.github.io/nq4.png","permalink":"https://getshhi.github.io/p/linux%E7%94%A8%E6%88%B7/%E7%94%A8%E6%88%B7%E7%BB%84%E7%BC%96%E8%BE%91/","title":"Linux用户/用户组编辑"},{"content":"Linux查看用户所属组 Linux中查看一个用户所属的组两种方法。\n使用id命令查看。\n命令格式：id [命令参数] 参数\n参数为要查询的用户名，默认是当前登录用户。\n常见命令参数：\n-g或\u0026ndash;group：显示用户所属群组的ID； -G或\u0026ndash;groups：显示用户所属附加群组的ID； -n或\u0026ndash;name：显示用户，所属群组或附加群组的名称。 id命令的执行权限是面向所有用户。\n案例演示:\n使用id命令查看用户fzm所属组。\n使用group命令查看。 命令格式：groups 参数\n参数为要查询的用户名，默认是当前登录用户。\n执行权限：groups命令的执行权限是面向所有用户。\n案例演示:\n使用groups命令查看用户fzm所属组。\n一个用户是可以属于多个组的。\nLinux修改用户所属组 使用usermod命令修改用户组 如果要一个用户仅仅属于某一个组，而不是同时属于多个组，则使用如下命令：\n命令格式：usermod -g 组名 用户名\n如果要给一个用户添加一个新的组，同时保留原来有所的组，则使用如下命令：\n命令格式：usermod -a -G 组名 用户名\nusermod必须以root权限才能执行，如果是普通用户想执行usermod时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示一:\n新创建一个用户newUser和新创建一个用户组newGroup，使用usermod命令将newUser用户所属组修改为newGroup。\n首先，创建用户newUser和组newGroup，使用groups命令查看用户newUser所属的组，因为默认情况下新创建用户的时候会默认创建一个与用户名同名的私有组，并将新创建的用户所属组设置为私有组。接下来使用usermod命令来修改用户所属组，最后查看修改是否成功。\n案例演示二:\n新创建一个用户newUser和新创建一个用户组newGroup，使用usermod命令为newUser用户新添加一个组newGroup。\n首先，创建用户newUser和组newGroup，使用groups命令查看用户newUser所属的组。接下来使用usermod命令来为用户添加一个新的组，最后查看添加是否成功。\n使用useradd命令创建用户的时候指定用户组 在创建新用户的同时可以修改默认用户所属组，如果想在创建的时候直接将用户所属组修改成系统中已经存在的一个组，而不是使用默认私有组，则使用如下命令：\n命令格式：useradd -g 组名 用户名\n在创建新用户的同时可以为用户添加其它组，如果想在创建新用户的时候为用户添加一个已经存在的组，而不仅只属于默认创建的私有组，则使用如下命令：\n命令格式：useradd -G 组名 用户名\nuseradd必须以root权限才能执行，如果是普通用户执行时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示一:\n新创建一个用户组newGroup，并且使用useradd命令新创建用户newUser同时将其所属组修改为newGroup。\n首先，创建用户组newGroup，使用useradd命令创建新用户newUser，同时将其所属组修改为newGroup，最后查看修改是否成功。\n案例演示二:\n新创建一个用户组newGroup，并且使用useradd命令新创建用户newUser同时为其添加一个新的用户组newGroup。\n首先，创建用户组newGroup，使用useradd命令创建新用户newUser，同时为其添加一个新的用户组newGroup，最后查看添加是否成功。\n","date":"2024-12-28T17:46:29+08:00","image":"https://getshhi.github.io/nq3.png","permalink":"https://getshhi.github.io/p/linux%E7%94%A8%E6%88%B7%E6%89%80%E5%B1%9E%E7%BB%84%E5%8F%98%E6%9B%B4/","title":"Linux用户所属组变更"},{"content":"Linux创建用户组命令 Linux 中使用groupadd命令来创建一个新用户组。\n命令格式：groupadd [命令参数] 参数\n常见命令参数：\n-g：指定新建工作组的id； -r：创建系统工作组，系统工作组的组ID小于500； groupadd必须以root权限才能执行，如果是普通用户想使用该命令，需要在命令前加sudo命令来提升权限为root权限。\n案例演示一 使用groupadd命令新创建一个用户组testGroup\n在背景介绍中，我们了解到，Linux中用户组信息是保存在/etc/group文件中，我们可以使用命令tail /etc/group命令查看/etc/group文件最后10行中是否存在刚刚新创建的testGroup用户信息。\n案例演示二 使用groupadd命令新创建一个用户组testGroupID，并且指定组的ID\n注意：我们可以看到有时执行sudo命令就不需要输入密码，这是因为每次都输入密码比较麻烦，所以Linux会设置一个sudo的会话时间，就是说我们在第一次执行sudo的时候是要输入密码，那么在接下来的一段时间内在执行sudo的时候就不需要输入密码，这个会话时间默认是5分钟，用户也可以通过编辑/etc/sudoers来修改这个会话时间的大小。\n同样我们可以使用命令tail /etc/group命令查看/etc/group文件最后10行中是否存在刚刚新创建的testGroupID用户信息。\nLinux删除用户组命令 Linux 中使用groupdel命令来删除一个已经存在的用户组。\n命令格式：groupdel 参数\n参数为要删除的用户组名\ngroupdel必须以root权限才能执行，如果是普通用户想使用该命令，需要在命令前加sudo命令来提升权限为root权限。\n案例演示一 使用groupdel命令删除上面创建的testGroup和testGroupID组\n","date":"2024-12-27T17:46:19+08:00","image":"https://getshhi.github.io/nq2.png","permalink":"https://getshhi.github.io/p/linux%E5%88%9B%E5%BB%BA/%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84/","title":"Linux创建/删除用户组"},{"content":"图形化界面登录 Linux中添加用户后，用户在图形界面登录系统的方式和Windows一样，都是选择要登录的用户后直接输入登录密码即可。\n案例演示 1: 添加一个新用户，并且设置登录密码，然后在图形界面登录。\n使用login命令登录 login命令是让用户登录系统，可通过它的功能随时更换登入身份。当/etc目录里含名称为nologin的文件时，系统只允许root帐号登入系统，其他用户一律不准登入。\n当使用login命令登录系统后，可以使用logout命令或者exit命令来退出当前用户登录，返回到登录前的用户状态。\n命令格式：login [命令参数] 参数\n参数为登录的用户名，可以不输入登录的用户名，直接输入login命令后回车，然后根据提示再输入用户名和密码。\n常见命令参数 -p：告诉login指令不销毁环境变量； -h：指定远程服务器的主机名。 login必须以root权限才能执行，如果是普通用户执行时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示 1: 使用login命令来登录系统(文件/etc/nologin不存在)。\n首先查看当前登录的用户名是fzm。\n使用newUser用户来登录系统，然后查看当前登录的用户名。\n使用logout或者exit命令退出newUser用户，然后在查看当前登录用户是否为fzm。\n2: 使用login命令来登录系统(文件/etc/nologin存在)。\n首先查看当前登录的用户名是fzm。\n在/etc目录下新创建一个nologin文件，使用如下命令创建：\nsudo touch /etc/nologin\n使用普通用户newUser来登录系统，查看是否可以登录成功。\n发现使用newUser用户是无法登录系统的，只有使用root用户才能登录系统。\n使用su命令切换用户身份 su命令用于切换当前用户身份到其他用户身份，变更时须输入所要变更的用户帐号的密码。\n当使用su命令切换用户后，使用exit命令退出当前身份，返回原有登录用户身份。\n注：如果当前用户身份是root，则使用su命令切换到其他用户的时候不需要相应用户的密码\n命令格式：su [命令参数] 参数\n参数为登录的用户名，如果没有参数，则默认切换为root用户。\n常见命令参数\n-c\u0026lt;指令\u0026gt;或\u0026ndash;command=\u0026lt;指令\u0026gt;：执行完指定的指令后，即恢复原来的身份； -l或\u0026ndash;login：改变身份时，也同时变更工作目录，以及HOME,SHELL,USER,logname。此外，也会变更PATH变量； -m,-p或\u0026ndash;preserve-environment：变更身份时，不要变更环境变量； -s或\u0026ndash;shell=：指定要执行的shell。 su命令所有使用者都可以执行。 案例演示 1: 使用su命令切换当前用户身份(不改变当前工作目录)。\n首先查看当前登录的用户名是fzm，当前工作目录是/home/fzm。\n切换当前用户为newUser用户，然后查看当前用户身份和当前工作目录。\n使用exit命令退出newUser用户，然后在查看当前登录用户身份和当前工作目录。\n2: 使用su命令切换当前用户身份(改变当前工作目录)。\n首先查看当前登录的用户名是fzm，当前工作目录是/home/fzm。\n切换当前用户为newUser用户，然后查看当前用户身份和当前工作目录。\n使用exit命令退出newUser用户，然后在查看当前登录用户身份和当前工作目录。\n","date":"2024-12-26T17:24:00+08:00","image":"https://getshhi.github.io/nq1.png","permalink":"https://getshhi.github.io/p/linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2/","title":"Linux用户权限切换"},{"content":"用户密码存放地及方式 Linux中用户的登录密码是存放在/etc/shadow文件中，/etc/shadow文件中存放的是加密过后的密码，所以在/etc/shadow文件中看到的密码是加密过后的密文。\n看下我的电脑中/etc/shadow文件存放的内容格式。\n可以看到第一个冒号前是用户名，用户名是以明文的方式存放。\n在第一个冒号和第二个冒号之间存放的是加密过后的密码，密码是以密文的方式存放，其中密文是由用户密码和其它信息加密后组成的，这里不做详细讲解，我们只需要知道如果第一个冒号和第二个冒号之间是*或者!或者空，则表示该用户没有密码，否则，则表示该用户是有密码。\n例如：用户名fzm是存在密码，而mysql是不存在密码的。\n使用passwd命令修改用户密码 命令格式：passwd [命令参数] 参数\n常见命令参数：\n-d 删除密码； -l 停止账号使用； -S 显示密码信息。 passwd必须以root权限才能执行，如果是普通用户想执行passwd时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示 1: 使用useradd命令来新创建一个用户，使用passwd命令来设置登录密码。\n使用useradd命令创建一个新用户(test)，此时test用户是没有密码的，所以使用tail -n 1 /etc/shadow命令查看/etc/shadow文件的最后一行可以看出test用户密码部分为!。\n使用passwd命令为test用户设置密码时，可以看到需要输入两次密码，目的是为了确保两次输入的密码一致。当设置完密码后，可以看到/etc/shadow文件中test用户的密码部分已经为加密过后的密文。\n2: 使用passwd命令来清除用户的密码。\n使用passwd命令清除用户test的登录密码，使用tail -n 1 /etc/shadow命令查看/etc/shadow文件的最后一行可以看出test用户密码部分为空，此时test用户是没有密码的。\n使用chpasswd命令修改用户密码 chpasswd命令通常是用于批量修改用户密码，从标准输入批量读取成对的用户名和密码，其中输入的用户名和密码的格式为用户名:密码。\n例如要批量更新用户密码，将用户名和密码写入到一个文件中，格式如下所示：\n然后执行执行如下命令来更新密码：\nsudo chpasswd \u0026lt; batch.txt\n\u0026lt;符号表示输入重定向，接下来的实训中我们会详细的介绍。\n命令格式：chpasswd [命令参数] 参数\n常见命令参数\n-e：输入的密码是加密后的密文； -h：显示帮助信息并退出。 chpasswd必须以root权限才能执行，如果是普通用户执行时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示 1: 使用chpasswd命令来更新用户登录密码。\nchpasswd是从键盘不断的读入指令，我们可以使用Ctrl+D组合键来结束键盘输入。\n","date":"2024-12-25T17:23:48+08:00","image":"https://getshhi.github.io/nq.png","permalink":"https://getshhi.github.io/p/linux%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/","title":"Linux用户密码管理"},{"content":"Linux创建用户命令 Linux中使用useradd命令来创建一个新用户。\n命令格式格式：useradd [命令参数] 参数\n常见命令参数：\n-d\u0026lt;登入目录\u0026gt;：指定用户登入时的启始目录； -D：查看或变更预设值； -g\u0026lt;群组\u0026gt;：指定用户所属的群组； -m：自动建立用户的登入目录； -M：不要自动建立用户的登入目录； -s：指定用户登入后所使用的shell。 useradd必须以root权限才能执行，如果是普通用户想创建一个新用户时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示 1 .查看useradd系统默认属性值，使用命令useradd -D。\n我使用的系统是Ubuntu16.04，useradd系统默认值如下所示：\n2 . 使用useradd命令新创建一个用户test，并且自动建立用户的登入目录。\n在背景介绍中，我们了解到，Linux中用户信息是保存在/etc/passwd文件中，我们可以使用命令tail /etc/passwd命令查看/etc/passwd文件最后10行中是否存在刚刚新创建的test用户信息。\nLinux删除用户命令 Linux中使用userdel命令来删除一个已经存在的用户。\n命令格式：userdel [命令参数] 参数\n常见命令参数：\n-f：强制删除用户，即使用户当前已登录； -r：删除用户的同时，删除与用户相关的所有文件。 userdel必须以root权限才能执行，如果是普通用户想使用该命令时，需要在命令前加sudo命令来提升权限为root权限。\n案例演示 1 . 使用userdel命令删除一个已经存在的用户test，并且自动删除其家目录文件。\n因为系统默认是不会给新创建的用户自动创建一个文件夹用于用户账户接收邮件，所以在使用userdel -r命令删除的时候会提醒/var/mail/test文件夹不存在。\n","date":"2024-12-24T17:20:51+08:00","image":"https://getshhi.github.io/mk.png","permalink":"https://getshhi.github.io/p/linux%E5%88%9B%E5%BB%BA/%E5%88%A0%E9%99%A4%E6%96%B0%E7%94%A8%E6%88%B7/","title":"Linux创建/删除新用户"},{"content":"String 介绍 String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。\n内部实现 String类型的底层的数据结构实现主要是int和SDS(简单动态字符串)\nSDS不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。 SDS获取字符串的时间复杂度为O(1)。因为SDS靠len属性直接获取字符串长度。 Redis的SDS API是安全的，拼接字符串不会造成缓冲区溢出。y因为在拼接前会检查SDS空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。 字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。\nembstr和raw编码的相同之处和不同之处 embstr和raw编码都会使用SDS来保存值，但不同之处在于embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，而raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。\nRedis这样做会有很多好处：\nembstr编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次； 释放 embstr编码的字符串对象同样只需要调用一次内存释放函数； 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。 但是 embstr 也有缺点的：\n如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以embstr编码的字符串对象实际上是只读的，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。 应用场景 缓存对象 有两种方式\n直接缓存整个对象的 JSON，命令例子： SET user:1 \u0026lsquo;{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;wanli\u0026rdquo;, \u0026ldquo;age\u0026rdquo;:18}\u0026rsquo; 采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20。 常规计数 因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。\n分布式锁 SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：\n如果 key 不存在，则显示插入成功，可以用来表示加锁成功； 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。 一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下： 1 SET lock_key unique_value NX PX 10000 lock_key 就是 key 键； unique_value 是客户端生成的唯一的标识； NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作； PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。 而解锁的操作必须由操作的客户端进行，所以解锁的时候，我们要先判断锁的unique_value是否为加锁客户端，是的话，才将lock_key键删除。\n可以看到，是先判断锁，然后再进行解锁之类的操作，这时就需要Lua脚本来保证解锁的原子性，因为Redis在执行Lua脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。\n1 2 3 4 5 6 // 释放锁时，先比较 unique_value 是否相等，避免锁的误释放 if redis.call(\u0026#34;get\u0026#34;,KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;,KEYS[1]) else return 0 end 共享Session信息 分布式系统单独存储Session流程图 List 介绍 List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。\n列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。\n内部实现 List 类型的底层数据结构是由双向链表或压缩列表实现的：\n如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用压缩列表作为 List 类型的底层数据结构； 如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构； 但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。\n应用场景 消息队列 消息队列在存取消息时，必须要满足三个需求，分别是消息保序，处理重复的消息和保证消息可靠性\n如何满足消息保序需求 List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。\n生产者使用 LPUSH key value[value\u0026hellip;] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。 消费者使用 RPOP key 依次读取队列的消息，先进先出。 如何处理重复的消息 消费者要实现重复消息的判断，需要2个方面的要求:\n每个消息都有一个全局的 ID。 消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。 但是 List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。\n例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 100 的消息插入了消息队列：\n1 2 \u0026gt; LPUSH mq \u0026#34;111000102:stock:100\u0026#34; (integer) 1 如何保证消息可靠性 当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。\n为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。\n这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。\n好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。\n消息保序：使用 LPUSH + RPOP； 阻塞读取：使用 BRPOP； 重复消息处理：生产者自行实现全局唯一 ID； 消息的可靠性：使用 BRPOPLPUSH List 作为消息队列有什么缺陷？ List 只支持一个消费者消费同一条消息，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。 要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 List 类型并不支持消费组的实现。 Hash 介绍 Hash 是一个键值对（key - value）集合，其中 value 的形式如： value=[{field1，value1}，\u0026hellip;{fieldN，valueN}]。Hash 特别适合用于存储对象。 Hash 与 String 对象的区别如下图所示:\n内部实现 Hash类型的底层数据结构是由压缩列表或哈希表实现的\n如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构； 如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。\n应用场景 缓存对象 Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。 Redis Hash 存储其结构如下图： 在介绍 String 类型的应用场景时有所介绍，String + Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？\n一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。\nset 介绍 Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。\n一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。 Set 类型和 List 类型的区别如下： List 可以存储重复元素，Set 只能存储非重复元素； List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。 内部实现 Set 类型的底层数据结构是由哈希表或整数集合实现的：\n如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构； 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。 应用场景 集合的主要几个特性，无序、不可重复、支持并交差等操作。\n因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。\n但是这里有一个潜在的风险。Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。\n在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。\n可以用做点赞，抽奖活动，共同关注等应用场景。\nZset 介绍 Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。\n有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。\n内部实现 Zset 类型的底层数据结构是由压缩列表或跳表实现的：\n如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构； 如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构； 在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了\n应用场景 Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。\n在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。\n排行榜 有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。\n电话 姓名排序 使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。\nBitMap 介绍 Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。\n由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。\n","date":"2024-12-23T22:31:04+08:00","image":"https://getshhi.github.io/lm.png","permalink":"https://getshhi.github.io/p/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","title":"Redis常见数据类型和应用场景"},{"content":"Redis简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\nRedis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。\nRedis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\nRedis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n","date":"2024-12-23T21:41:16+08:00","image":"https://getshhi.github.io/nj.png","permalink":"https://getshhi.github.io/p/redis%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","title":"Redis的简单介绍"},{"content":"插入数据优化 对于insert这个命令来说有三种优化方式 优化方案一 可以批量插入数据\n1 Insert into tb_test values(1,\u0026#39;Tom\u0026#39;),(2,\u0026#39;Cat\u0026#39;),(3,\u0026#39;Jerry\u0026#39;); 优化方案二 手动控制事务\n1 2 3 4 5 start transaction; insert into tb_test values(1,\u0026#39;Tom\u0026#39;),(2,\u0026#39;Cat\u0026#39;),(3,\u0026#39;Jerry\u0026#39;); insert into tb_test values(4,\u0026#39;Tom\u0026#39;),(5,\u0026#39;Cat\u0026#39;),(6,\u0026#39;Jerry\u0026#39;); insert into tb_test values(7,\u0026#39;Tom\u0026#39;),(8,\u0026#39;Cat\u0026#39;),(9,\u0026#39;Jerry\u0026#39;); commit; 优化方案三 主键顺序插入，性能要高于乱序插入 对于大批量插入数据 如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。\n并且我们建议要顺序插入(主键顺序插入性能高于乱序插入)\n主键优化 满足业务需求的情况下，尽量降低主键的长度。 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键 尽量不要使用UUID做主键或者是其他自然主键，如身份证号 业务操作时，避免对主键的修改 order by 优化 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k) group by优化 在分组操作时，可以通过索引来提高效率。 分组操作时，索引的使用也是满足最左前缀法则的。 limit优化 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化。 count优化 MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。 如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。\n按照效率排序的话，count(字段) \u0026lt; count(主键 id) \u0026lt; count(1) ≈ count()，所以尽 量使用 count()。\nupdate优化 要加索引，不加的话会加一个间隙锁，会导致整张表被锁住。\n","date":"2024-12-22T18:26:46+08:00","image":"https://getshhi.github.io/nv4.png","permalink":"https://getshhi.github.io/p/mysql%E4%BC%98%E5%8C%96/","title":"MySql优化"},{"content":"Linux man命令 linux中使用man命令来查询命令的帮助文件,命令格式如下:\n1 man [章节] command 常用命令如下：\n1 2 3 4 5 6 d, Ctrl+D: 向文件尾部翻半屏； u, Ctrl+U: 向文件首部翻半屏； q: 退出； #：跳转至第#行； home: 回到文件首部； end：翻至文件尾部。 命令的帮助文件通常存放在/usr/share/man目录下。\nman包含9个章节，章节用数字表示，分别是：\n1 2 3 4 5 6 7 8 9 用户命令 系统调用 C库调用 设备文件及特殊文件 配置文件格式 游戏 杂项 管理类的命令 Linux 内核API 如果查询命令的时候不追加章节，则默认从第一个章节开始查询，以此类推，直到找到对应要查询的命令为止。\n例如：使用man命令查询open命令的使用方法。\nman open\n如果想查询系统库函数的open函数的使用方法，则使用如下命令：\nman 2 open\n使用man搜索命令 以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索，不区分字符大小写；\n1 2 n: 下一个 N：上一个 Linux info命令 linux中使用info命令来查询命令的帮助文件。info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。\n命令格式如下：\n1 info [命令参数] command 常用命令参数选项：\n1 2 3 4 -d：添加包含info格式帮助文档的目录； -f：指定要读取的info格式的帮助文档； -n：指定首先访问的info帮助文件的节点； -o：输出被选择的节点内容到指定文件。 常见命令如下：\n1 2 3 4 5 6 7 8 9 10 ?键：它就会显示info的常用快捷键； N键：显示（相对于本节点的）下一节点的文档内容； P键：显示（相对于本节点的）前一节点的文档内容； U键：进入当前命令所在的主题； M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了； G键：敲G键后输入主题名称，进入该主题； L键：回到上一个访问的页面； SPACE键：向前滚动一页； BACKUP或DEL键：向后滚动一页； Q：退出info。 例如：我们使用info来查询info的帮助手册。\n1 info info Linux whatis命令 whatis用来显示命令的简短描述。\n命令格式如下：\nwhatis command\n例如：我们使用whatis来查询ls的使用方法。 ","date":"2024-12-21T13:31:17+08:00","image":"https://getshhi.github.io/nv3.png","permalink":"https://getshhi.github.io/p/linux-%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E8%AF%AD%E5%8F%A5/","title":"Linux 查询命令帮助语句"},{"content":"Linux文件操作 Linux系统中最常用的文件操作有创建、删除文件等。\n创建文件\nlinux中创建文件的常用命令是touch，命令格式如下:\n1 touch filename 有时可能需要创建一个空的文件的情况。在这种情况下，可以使用touch命令来轻松创建一个空文件。\n例如：创建一个新的文件testfile可以使用如下命令。\n1 touch testfile 如果想同时创建多个文件也可以使用touch命令完成，具体格式如下：\n1 touch file1 file2 ... 只需将不同的文件名用空格分隔即可完成创建多个文件。\n删除文件\nLinux中常用的删除文件的命令是rm，使用格式如下：\n1 rm [命令选项] filename 常用命令选项：\n1 2 3 -f：强制删除文件或目录； -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； -i：删除已有文件或目录之前先询问用户。 例如，删除我们刚刚创建的文件testfile可以使用如下命令。\n1 rm -f testfile Linux文件夹操作 Linux中关于文件夹的操作主要包括创建和删除等。\n创建文件夹 Linux中创建文件夹命令是mkdir，命令格式如下：\n1 mkdir [命令选项] dirname 常用命令选项： -p或\u0026ndash;parents 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；\n例如：我们新创建一个文件夹testdir可以使用如下命令。\n1 mkdir testdir 因为新创建的文件夹是一个空的文件夹，所以使用ls -l显示的结果是空。\n删除文件夹\nLinux中删除文件夹的命令是rmdir或者rm -r，命令格式如下：\n1 rmdir [命令选项] dirname 常用命令选项：-p或\u0026ndash;parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；\n例如：将刚刚新创建的文件夹testdir删除可以使用如下命令。\n1 rmdir testdir Linux文件和文件夹拷贝\nLinux使用cp命令用来将一个或多个源文件或者目录复制到指定的目录中，命令格式如下：\n1 cp [命令选项] 源文件 目的文件 常用命令选项：\n1 2 3 4 -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理。 例如：新建一个文件newfile和一个文件夹newdir，将newfile复制到newdir目录下。具体命令如下。\n1 2 3 touch newfile mkdir newdir cp newfile newdir Linux文件和文件夹移动/重命名\nLinux使用mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中，命令格式如下：\n1 mv [命令选项] 源文件 目标文件 常用命令选项：\n1 2 3 4 -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理\u0026#39;。 例如：新建一个文件newfile和一个文件夹newdir，将newfile剪切到newdir目录下，并重新命名为newfileCpy。具体命令如下。\n1 2 3 touch newfile mkdir newdir mv newfile newdir/newfileCpy ","date":"2024-12-20T13:31:17+08:00","image":"https://getshhi.github.io/nv2.png","permalink":"https://getshhi.github.io/p/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","title":"Linux常用命令"},{"content":"Linux目录结构介绍 对Linux文件系统目录结构的了解是学习和掌握Linux系统的基础。Linux 文件系统是树形层次结构，具体如下图所示。\nLinux用户介绍 Linux用户通常分为两类:\n管理员用户(root)；\n普通用户(类似Windows上的普通用户)。\nLinux登录系统后，默认当前所在目录为用户主目录，类似Windows登录系统后，默认的所在目录为桌面。\n管理员(root)登录系统后默认目录为/root；\n普通用户登录系统后默认目录为/home/username， username为用户名。 例如：笔者用普通用户fzm登录系统后，那么当前所在目录为。/home/fzm。\nLinux 常用命令介绍 pwd命令\npwd(Print Working Directory )：显示当前所在目录。\n例如：笔者用普通用户fzm登录系统后，那么当前所在目录为/home/fzm。\ncd命令\ncd(Change Directory): 切换当前目录。\n常用特殊目录表示：\ncd 进入用户主目录； cd ~ 进入用户主目录； cd - 返回进入此目录之前所在的目录； cd .. 返回上级目录(若当前目录为\u0026quot;/\u0026quot;，则执行完后还在\u0026quot;/\u0026quot;；\u0026quot;..\u0026ldquo;为上级目录的意思)； cd ../.. 返回上两级目录； cd !$ 把上个命令的参数作为cd参数使用。 例如：切换当前目录为/bin目录。 ls命令\nls(list): 列出指定目录列表信息，如果没有参数默认列出当前目录下的所有文件和文件夹(隐藏文件和文件夹除外)。\n常见ls命令选项:\n-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；\n-a：显示所有文件和文件夹(包括隐藏文件/文件夹)。\n例如：显示根目录下所有文件和文件夹。\n","date":"2024-12-19T13:31:17+08:00","image":"https://getshhi.github.io/nv.png","permalink":"https://getshhi.github.io/p/linux%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"Linux初体验"},{"content":"Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。\nBuffer Pool 以页为单位缓冲数据，可以通过 innodb_buffer_pool_size 参数调整缓冲池的大小，默认是 128 M。\nInnodb 通过三种链表来管理缓页：\nFree List （空闲页链表），管理空闲页； Flush List （脏页链表），管理脏页； LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。； InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：\n将 LRU 链表 分为young 和 old 两个区域，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。 当 **「页被访问」且「 old 区域停留时间超过 innodb_old_blocks_time 阈值（默认为1秒）」**时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。 可以通过调整 innodb_old_blocks_pct 参数，设置 young 区域和 old 区域比例。 在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。\n","date":"2024-12-18T16:07:41+08:00","image":"https://getshhi.github.io/ok.png","permalink":"https://getshhi.github.io/p/mysql%E5%86%85%E5%AD%98/","title":"MySql内存"},{"content":"Spring有几种设计模式？ 责任链模式: Spring 中的过滤器和拦截器使用了责任链模式，多个过滤器和拦截器按照一定顺序执行，每个过滤器和拦截器可以拦截请求或者响应并做出相应的处理。 单例模式: Spring 的 Bean 默认是单例模式，通过 Spring 容器管理 Bean 的生命周期，保证每个 Bean 只被创建一次，并在整个应用程序中重用。 观察者模式: Spring 中的事件机制基于观察者模式，通过 ApplicationEventPublisher 发布事件，由 ApplicationListener 监听事件，实现了对象间的松耦合。 工厂模式: Spring 使用工厂模式通过 BeanFactory 和 ApplicationContext 创建并管理 Bean 对象。 代理模式: Spring AOP 基于动态代理技术，使用代理模式实现切面编程，提供了对 AOP 编程的支持。 模板方法模式: Spring 中的JdbcTemplate使用了模板方法模式，将一些固定的流程封装在父类中，子类只需实现一些抽象方法即可。 MySQL主从复制了解吗？ MySQL的主从复制依赖于binlog，也就是记录MySQL的所有变化以二进制形式保存在磁盘上。复制的过程就是将binlog中的数据从主库传输到从库中。\n写入Binlog: 主库写binlog日志，提交事务，并更新本地存储数据。 同步Binlog: 把binlog复制到所有从库中，每个从库把binlog写到暂存日志中。 回放Binlog: 回放binlog，并更新存储引擎中的数据。 具体详细过程如下：\nMySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。 从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。 从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。 在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。\nMybatis的执行原理 MyBatis的执行原理基于:通过映射文件(XML或注解)将SQL语句与Java对象进行绑定。\n初始化‌：加载配置文件和xxxMapper.xml文件。创建全局配置对象Configuration，在其中保存配置信息、注册Mapper接口和创建sql语句对象MappedStatement。另创建 SqlSessionFactory。 ‌获取 SqlSession‌：通过 SqlSessionFactory 获取 SqlSession 实例。 ‌获取 Mapper 代理对象‌：通过 SqlSession 获取 Mapper 接口的代理对象。 ‌执行代理对象中的方法‌：调用 Mapper 方法时， MapperProxy 代理对象的invoke方法根据传来的方法名和参数类型，找到对应的sql语句对象 MappedStatement，并创建 Executor 执行器执行 SQL 语句。 返回结果‌：将执行结果映射到java对象中返回给调用者。 Spring的启动过程 (1)加载配置文件。 Spring 启动时首先会读取配置文件（如 XML 配置文件、Java Config 类等），包括配置数据库连接、事务管理、AOP 配置等。\n(2)实例化容器。 Spring 根据配置文件中的信息创建容器 ApplicationContext，在容器启动阶段实例化 BeanFactory，并加载容器中的 BeanDefinitions。\n(3)解析BeanDefinitions。 Spring 容器会解析配置文件中的 BeanDefinitions，即声明的 Bean 元数据，包括 Bean 的作用域、依赖关系等信息。\n(4)实例化Bean。 Spring 根据 BeanDefinitions 实例化 Bean 对象，将其放入容器管理。\n(5)注入依赖。 Spring 进行依赖注入，将 Bean 之间的依赖关系进行注入，包括构造函数注入、属性注入等。\n(6)处理Bean生命周期初始化方法。 Spring 调用 Bean 初始化方法（如果有定义的话），对 Bean 进行初始化。\n如果 Bean 实现了 InitializingBean 接口，Spring 会调用其 afterPropertiesSet 方法。\n(7)处理BeanPostProcessors方法。 容器定义了很多 BeanPostProcessor，处理其中的自定义逻辑，例如 postProcessBeforeInitialization 会在 Bean 初始化前调用， postProcessAfterInitialization 则在之后调用。\n(8)代理切面处理。 Spring AOP 代理在这个阶段生成。\n(9)发布事件。 Spring 可能会在启动过程中发布一些事件，比如容器启动事件。\n(10)完成启动。 当所有 Bean 初始化完毕、依赖注入完成、AOP 配置生效等都准备就绪时，Spring 容器启动完成。\nMySQL如何配置主从复制？ (1)配置主服务器 (2)配置从服务器 (3)启动主从复制 主要原理:\n(1)主服务器将对数据库的更新操作记录到二进制日志中(Binary Log)中 (2)从服务器从主服务器取这些二进制日志，并将它们重新播放，即执行这些更新操作，从而使得从服务器的数据与主服务器保持一致。 线上发现Redis机器爆了，如何优化？ (1) 首先需要排查并确定根因(通过线上的监控工具来进行分析)，判断是哪里出错了(比如内存，CPU，带宽)等等。\n(2) 依据根源来解决问题\n如果是内存的话，先临时增加机器的内存量，然后在分析代码去了解业务，判断哪些缓存哪里需要缓存，哪里不需要缓存，通过设置缓存的过期时间和设置缓存在哪个位置开始删除。 如果是CPU的话，可以看看那些读写命令和排序的命令，此时需要回退或下架相关有影响的代码。后续在进行优化，看是否可以通过将大KEY变为小之类的，使用集群分片来解决这个问题。 如果是带宽的问题的话，可以增大带宽来解决这个问题。 还可以将热点数据存储到本地缓存来解决这个问题，减轻Redis的压力。 (3)必须配置监控报警系统。(可以对某个指标设置阈值)，如果过了这个阈值，就可以通知开发者，避免问题的进一步扩大。\nJava的注解是啥？(AI面试) 1.注解其实就是一个标记，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。 2.有了标记之后，就可以在解析的时候获取标记，然后做特别处理。 3.注解的使用可以通过编译时、类加载时或者运行时的反射机制来实现特殊的处理逻辑。 Java的集合框架是啥?(AI面试) Java集合分为Collection和Map，其中Collection接口分为Set，List，Queue，用来存储单一元素，而Map接口用来存储键值对。 Java都有哪些锁?(AI面试) 独占锁(Exclusive Lock): 如synchronized和ReentrantLock，同一时间仅仅允许一个线程持有锁。 读写锁(ReadWriteLock): 允许多个线程并发读，但写时需要独占锁，适合读多写少的场景。 乐观锁和悲观锁:悲观锁会有并发冲突，每次操作都加锁；而乐观锁不会有冲突，通过版本号或CAS实现冲突检测。 Java的三大特性(AI面试) 封装\n简单来说就是将一个对象的属性封装在一起，对外仅仅暴露方法调用。(比如你用空调遥控器时，空调遥控器内部的细节不知道，但你可以通过它提供的按钮来使用) 继承\n子类拥有父类的属性和方法(私有方法和私有属性有但不能继承)。提高代码的复用性，程序的可维护性。 多态\n一个对象可以有多种状态，即父类引用指向子类的多种实例。 Java的线程是指啥?(AI面试) Java中的线程是指Java语言里的线程，它们是操作系统中的线程中的一种封装。 在Java中，线程是程序执行的基本单位，每个线程都有自己的堆栈，程序计数器和本地变量表。 Java中的线程可以通过继承Thread类或Runnable接口来创建。 ","date":"2024-12-17T19:25:15+08:00","image":"https://getshhi.github.io/dp.png","permalink":"https://getshhi.github.io/p/%E9%83%91%E5%B7%9E%E5%B0%8F%E5%8E%82%E9%9D%A2%E7%BB%8F/","title":"郑州小厂面经"},{"content":"直接继承LinkedHashMap来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class LRUCache extends LinkedHashMap\u0026lt;Integer, Integer\u0026gt;{ private int capacity; public LRUCache(int capacity) { super(capacity, 0.75F, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } protected boolean removeEldestEntry(Map.Entry\u0026lt;Integer, Integer\u0026gt; eldest){ return size() \u0026gt; capacity ; } } 采用LinkedHashMap来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class LRUCache { private LinkedHashMap\u0026lt;Integer, Integer\u0026gt; cache; private int capacity; public LRUCache(int capacity) { cache = new LinkedHashMap(); this.capacity = capacity; } public int get(int key) { if(!cache.containsKey(key)){ return -1; } int val = cache.get(key); Recent(key); return val; } public void put(int key, int value) { if(cache.containsKey(key)){ cache.put(key, value); Recent(key); return; } if(capacity == cache.size()){ int old = cache.keySet().iterator().next(); cache.remove(old); } cache.put(key, value); } public void Recent(int key){ int val = cache.get(key); cache.remove(key); cache.put(key, val); } } 采用HashMap和自己实现的双向链表来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class LRUCache { class Node{ private int key, value; private Node pre, next; public Node(int key, int value){ this.key = key; this.value = value; } } class DoubleList{ private Node head, tail; private int size; public DoubleList(){ head = new Node(-1,-1); tail = new Node(-1,-1); head.next = tail; tail.pre = head; } public void addFirst(Node n){ n.next = head.next; n.pre = head; head.next = n; n.next.pre = n; size++; } public void remove(Node n){ n.pre.next = n.next; n.next.pre = n.pre; size--; } public Node removeLast(){ Node last = tail.pre; remove(last); return last; } public int size(){ return size; } } private Map\u0026lt;Integer, Node\u0026gt; map; private DoubleList cache; private int capacity; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;Integer ,Node\u0026gt;(); cache = new DoubleList(); } public int get(int key) { if(!map.containsKey(key)){ return -1; } int val = map.get(key).value; put(key, val); return val; } public void put(int key, int value) { Node n = new Node(key, value); if(map.containsKey(key)){ cache.remove(map.get(key)); cache.addFirst(n); map.put(key, n); }else{ if(cache.size() == capacity){ Node last = cache.removeLast(); map.remove(last.key); } cache.addFirst(n); map.put(key, n); } } } ","date":"2024-12-16T18:18:50+08:00","image":"https://getshhi.github.io/nh.png","permalink":"https://getshhi.github.io/p/lru%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9B%E6%89%A3%E5%AE%9E%E7%8E%B0/","title":"LRU算法的力扣实现"},{"content":"三个日志 undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和MVCC。 redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复； binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制； 为啥需要 undo log？ 实现事务回滚，保障事务的原子性。在事务处理过程中，如果出现了错误或者用执行了ROLLBACK语句，MySql可以利用undo log中的历史数据恢复到事务开始之前的状态。 实现MVCC(多版本并发控制)关键因素之一。MVCC是通过ReadView + undo log实现的。undo log 为每条记录保存多份历史数据，MySQL在执行快照读(普通select语句)的时候，会根据事务的Read View里的信息，顺着undo log 的版本链找到满足其可见性的记录。 为啥需要Buffer Pool？ 总体原因:\n相较于内存的缓存来说，磁盘的速度太慢，这时如果有相应的缓存池，就可以大幅度地提高性能。\n当读取数据时，如果数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取。\n当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。\nBuffer Pool缓存啥？ Buffer Pool的内存空间是一片连续的内存空间，以页的形式进行数据交换，组成部分是一个个页，这种页叫做缓存页。 由数据页，索引页，插入缓存页，undo页，自适应哈希索引，锁信息。 undo页是记录相应的undo log。 当查询一条记录时，InnoDB不是只需要缓存一条记录，当我们查询一条记录时，InnoDB是会把整个页的数据加载到Buffer Pool中，将页加载到Buffer Pool中，再通过页里的页目录去定义到某条具体的记录。 为啥需要redo log？ 基于内存的Buffer Pool，如果内存出现错误，那么其中还没来得及落盘的脏页数据就会丢失。为了防止这种情况再次发生引出了rdao log。 可能会出现啥服务端宕机的情况，所以可以通过redo log来进行预防故障。 被修改 Undo 页面，需要记录对应 redo log 吗？ 需要的。在内存修改该Undo页面后，也是需要记录对应的redo log, 因为undo log也要实现持久性的保护。 redo log 和 undo log区别在哪？ redo log 记录了此次事务修改后的数据状态，记录的是更新后的值，功能是事务崩溃恢复，保证事务的持久性。 undo log 记录了此次事务修改前的数据状态，记录的是更新之前的值，保证事务的原子性。 redo log 要写到磁盘，数据也要写磁盘，为啥要多次一举？ 第一点redo log的写入方式使用了追加操作，所以磁盘操作是顺序写，而对于直接写入数据的写入方式是随机写。所以redo log 的写入更加高效，这是第一点。 第二点的话就是实现事务的持久性，让MySql有crash-safe的能力，能够保证MySql在任何时间段突然崩溃，重启之前已提交的记录都不会丢失。 产生的redo log是直接写入磁盘的吗？ 不是\n它也有自己的缓存redo log buffer，每当产生一条redo log时，会先写入到redo log buffer，后续在持久化到磁盘中。(redo log buffer默认大小为16MB，可以通过innodb_log_Buffer_size参数动态的调整大小)。 redo log啥时候刷盘？ MySQL正常关闭时。 当redo log buffer中记录的写入量大于redo log buffer 内存空间的一半时，会触发落盘。 InnoDB的后台线程每隔1秒，将redo log buffer持久化到磁盘中 每次事务提交时都将缓存在redo log buffer里的redo log直接持久化到磁盘(这个策略可由innodb_flush_log_at_trx_commit 参数控制) innodb_flush_log_at_trx_commit参数控制的是啥？ 控制的是当事务提交的时候，redo log写入的策略。\n当设置该参数为0的时候，表示每次事务提交的时候，还是将redo log 留在redo log buffer中，该模式下在事务提交时不主动触发写入主动触发写入磁盘的操作。 当设置该参数为1的时候，表示每次事务提交的时候，都将缓存在redo log buffer里的redo log直接持久化到磁盘中，这样可以保证MySql异常重启之后数据都不会丢失。 当设置该参数为2时候，表示每次事务提交的时候，都只是缓存在redo log buffer 里的redo log 写到redo log 文件，其实是写入到操作系统的Page Cache。 如下图 那innodb_flush_log_at_trx_commit为0和2的时候，啥时候才将redo log 写入磁盘？ 当然是交给InnoDB的后台线程了\n对于innodb_flush_log_at_trx_commit参数为0的情况，会把缓存在redo log buffer 中的redo log，通过调用write()写到操作系统的Page Cache，然后调用fsync()持久化到磁盘。所以参数为0的策略，MySql进程的崩溃的会导致上一秒的所有的事务数据的丢失。 对于innodb_flush_log_at_trx_commit参数为2的情况，会直接调用fsync()持久化到磁盘。所以参数为2的策略，较取值为0情况下更安全，因为MySQL进程的崩溃并不会丢失数据，只有在操作系统崩溃或者没电的情况下，上一秒钟所有事务数据才可能丢失。 对于这三种参数我们该如何使用？ 对于数据安全性的话，参数1的安全性最高，其次是参数2，最后是参数0 对入写入性能的话，参数0的写入性能最好，其次是参数2，最后是参数1 不同的场景我们使用不同的处理方案\n在一些数据安全性要求比较高的场景中，显然参数需要设置为1。 在一些可以容忍数据库崩溃时丢失1s的数据的数据，而且同时对性能有要求的话，我们可以将参数设置为0，这样的话可以明显地提高性能。 如果想要折中的方案的话，可以将参数设置为2，这样既有安全性又有性能。 redo log 文件写满了咋办？ MySql有两个日志文件组(redo log Group)，这个日志文件组是以循环写的方式工作的，如果 write pos 追上了checkpoint，就意味着redo log 文件满了，这时MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作。\n这样的话就可一次将脏页刷新到磁盘中变成干净页，然后标记redo log哪些记录可以被覆盖的过程。\n为啥需要binlog？ 这个跟MySql的时间线有关，最开始MySql里面没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MYISAM没有crash-cafe的能力，binlog日志只能用于归档。 而InnnoDB是另一个公司以插件形式引入MySQL的，既然只靠binlog是没有crash-sefe能力的，所以InnoDB使用redo log 来实现crash-safe能力。 redo log 和 binlog有啥区别？ 1.写入方式不同 binlog是追加写，写满一个文件，就创建一个新的文件继续写，保存的是全量的日志。 redo log是循环写，日志空间大小是固定，如果写满的话，就从头开始，保存未被刷入磁盘的脏页日志。 2.用途不同 binlog用于备份恢复，主从复制。 redo log 用于掉电等故障恢复。 3.用的对象不同 binlog是Server层实现的日志，所有的存储引擎都可以使用。 redo log仅仅适用于Innodb存储引擎实现的日志。 4.文件格式不同 Binlog（二进制日志）主要有以下三种格式： STATEMENT格式\n定义：也称为基于SQL语句的复制（SBR，Statement - Based Replication）。在这种格式下，binlog会记录每一条修改数据的SQL语句。例如，当执行INSERT INTO users (name, age) VALUES ('John', 25)这条SQL语句时，binlog会将这条完整的INSERT语句记录下来。 优点： - 日志内容相对紧凑，因为它记录的是SQL语句，占用的空间比记录每一行数据变化的格式要小。例如，一条UPDATE语句可能会修改多条记录，但在STATEMENT格式下，只需要记录这一条UPDATE语句。 - 比较直观，易于理解。可以直接看到执行的SQL操作，方便数据库管理员（DBA）进行故障排查和审计。 缺点： - 存在一定的安全风险。如果SQL语句中包含了一些具有不确定性的函数，如UUID()、NOW()等，可能会导致主从数据库的数据不一致。因为这些函数在主库和从库执行时，结果可能会不同。 - 对于一些复杂的存储过程和函数，在从库上重新执行时可能会出现问题。因为主库上存储过程内部的操作细节可能依赖于主库的环境，在从库上执行相同的存储过程可能无法得到预期的结果。 ROW格式\n定义：基于行的复制（RBR，Row - Based Replication）。它会记录每一行数据的修改情况。比如，对一个表进行UPDATE操作，它会记录更新前后每一行的具体内容。如果更新了3行数据，binlog中会详细记录这3行数据从旧值到新值的变化。 优点： - 能够更准确地进行数据复制。因为它记录的是行级别的数据变化，所以不会受到SQL语句中不确定性因素的影响，保证了主从数据库的数据一致性。 - 对于一些包含复杂逻辑的更新操作，能够更精确地在从库上重现数据的修改过程。 缺点： 会产生大量的日志。因为它记录了每一行数据的变化，所以相比STATEMENT格式，日志文件可能会大很多。特别是对于一些批量操作，如批量插入或更新大量数据时，日志文件的增长速度会比较快。 日志内容相对来说不那么直观，不容易直接看出执行的SQL操作，需要通过工具或者一定的解析才能了解数据变化对应的SQL操作。 MIXED格式\n定义：混合了STATEMENT和ROW两种格式。MySQL会根据具体的SQL操作自动选择合适的日志记录方式。例如，对于一些简单的、确定性的SQL语句，如UPDATE tab SET col1 = 'value' WHERE col2 = 'condition'（其中不包含不确定函数），会以STATEMENT格式记录；而对于一些复杂的操作，如包含UUID()函数的INSERT语句或者UPDATE语句影响了大量行数据，就会以ROW格式记录。 优点： 结合了STATEMENT和ROW格式的优点。在一定程度上减少了日志文件的大小，同时也保证了数据复制的准确性。 可以根据实际的业务场景自动调整日志记录方式，具有较好的灵活性。 缺点： 由于采用了混合的记录方式，日志的解析和管理可能会相对复杂一些。需要考虑两种记录格式的特点，对于故障排查和数据恢复操作，要求DBA对两种格式都比较熟悉。 redo log是物理日志，记录的是在某个数据页 做了啥修改，比如对xxx表空间中的yyy数据页zzz偏移量的地方做了啥更新(这个就是弄了啥变化，具体的实现这个日志没说) 主从复制是如何实现的？ MySQL的主从复制依赖于binlog，binlog记录MySQl上的所有变化并以二进制形式保存在磁盘上，复制的过程就是将binlog中的数据从主库传输到从库中。\nMySQL集群的主从复制过程分为3个阶段\n写入binlog: 主库写binlog日志，提交事务，并更新本地数据。 同步binlog: 把binlog复制到所有从库中，每个从库把binlog写到暂存日志中。 回放binlog: 回放binlog，并更新存储引擎中的数据。 具体详细过程如下:\nMySQL主库在收到客户端提交事务的请求后，会先写入binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端\u0026quot;操作成功\u0026quot;的响应。 从库会创建一个专门的I/O线程，连接主库的log dump线程，来接收主库的binlog日志，再把binlog信息写入relay log的中继日志中，再返回给主库\u0026quot;复制成功\u0026quot;的响应。 从库会创建一个用于回放binlog的线程，去读relay log中继日志，然后回放binlog更新存储引擎中的数据，最终实现主从的数据一致性。 这样的话你就可以写的时候只写主库，读的时候只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。\n从库是不是越多越好？ 不是\n因为从库数量增加，从库连接上来的I/O线程也比较多，主库也要创建同样多的log dump线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。(通常情况下一个主库一般跟2-3个从库 1套数据库，1主2从备主)，这就是一主多从的MySQL集群结构。 MySQL主从复制还有哪些模型？ 主要有三种 同步复制: MySQL主库提交事务的线程要等待所有从库的复制响应，才返回客户端结果。这种方式在实际项目中，基本没法用，原因是: 一是性能很差，因为要复制到所有节点才返回响应，二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。 异步复制(默认模型): MySQL主库提交事务的线程并不会等待binlog同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。 半同步复制: MySQL5.7版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。 binlog啥时候刷盘？ MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：\nsync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘； sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync； sync_binlog =N(N\u0026gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。 在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。 而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。 如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。 为啥需要两阶段提交？ 事务提交后，redo log和binlog都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成了两份日志之间的数据不一致。\n如果在将redo log刷入到磁盘中，MySQL突然宕机了，而binlog还没有来得及写入。这样的话就会造成主库的数据是新的，但是从的数据是旧的。 如果在将binlog刷入到磁盘中，MySQL突然宕机了，而redo log还没有来得及写入。这样的话就会造成主库是旧的数据，而从库的数据是新的，从而导致数据不一致。 两阶段提交的过程是咋样的？ 事务的提交过程有两个阶段\nprepare阶段: 将XID(内部XA事务的ID)写入到redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘中。 commit阶段: 把XID写入到binlog，然后将binlog持久化到磁盘，接着调用引擎的提交事务接口，将redo log状态设置为commit,此时该状态并不需要持久化到磁盘中，只需要write到文件系统的page cache中就够了，因为只要binlog写磁盘成功，就算redo log的状态还是prepare也没有关系，一样会被认为事务已经执行成功。 两阶段提交有啥问题吗？ 磁盘I/O次数高: 对于\u0026quot;双1\u0026quot;配置，每个事务提交都会进行两次fsync(刷盘)，一次是redo log刷盘，另一次是binlog刷盘。 锁竞争激烈: 两阶段提交虽然能够保证单个事务两个日志的内容一致，但在多个事务的情况下，却不能保证两者的提交顺序一致。 为啥锁竞争激烈？ 在早期的MySQL版本中，对于一个事务来说，获取锁才能进入prepare阶段，一直到commit阶段结束才能释放锁，相当于串行化。\n组提交 MySQL引入了binlog组提交机制，当有多个事务提交的时候，会将多个binlog刷盘操作合并成一个，从而减少磁盘I/O的次数。\n引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：\nflush 阶段: 多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）； sync 阶段: 对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）； commit 阶段: 各个事务按顺序做 InnoDB commit 操作； MySQL磁盘I/O很高，有啥优化的方法没？ 设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。 将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。 将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。 具体更新一条记录 UPDATE t_user SET name = \u0026lsquo;jiahao\u0026rsquo; WHERE id = 1; 的流程如下: 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：\n如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新； 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：\n如果一样的话就不进行后续更新流程； 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作； 开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。\nInnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。\n至此，一条记录更新完了。\n在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。\n事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：\nprepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘； commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）； 至此，一条更新语句执行完成\n","date":"2024-12-16T16:07:41+08:00","image":"https://getshhi.github.io/gg.png","permalink":"https://getshhi.github.io/p/mysql%E6%97%A5%E5%BF%97/","title":"MySql日志"},{"content":"MySql的锁有哪些? MySql的锁可以分为三部分\n全局锁(一旦使用数据库就处于只读的状态) 主要用来进行 全库逻辑备份 加上全局锁的缺点是因为是只读状态，可能会导致业务只能读数据，从而导致业务停滞。 表级锁 表锁 一旦实现，本线程就只能读本线程所在的表，不能访问其他的线程，其他线程的只能读该线程所在的表。 1 2 3 4 5 6 //表级别的共享锁，也就是读锁； //允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。 lock tables t_student read; //表级别的独占锁，也就是写锁； //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 lock tables t_stuent write; 元数据锁(MDL) 分为MDL读锁和MDL写锁(都是数据库自动加的MDL)对一张表进行CRUD操作时，加的是MDL读锁，对一张表做结构变更操作的时候，加的是MDL写锁。 MDL在事务执行期间，MDL是一直持有的。 MDL写锁获取优先级高于MDL读锁。 意向锁 意向锁简单来说就是提前说明记录是否存在共享锁和独占锁。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享锁和独占表锁发生冲突。 意向锁的目的就是为了判断表里是否有记录被加锁。 AUTO-INC锁 AUTO-INC锁的作用就是自动增加主键的值。 锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放。 在插入数据时，会加一个表级别的AUTO-INC锁。 从MySql5.1.22版本开始，InnoDB存储引擎提供了一种轻量级的锁来实现自增。 对于解决InnoDB的数据库一致性问题，可以采用innodb_autoinc_lock_mode = 2，并且binlog_format = row，既能提高并发性，又不会出现数据一致性问题 行级锁(基于InnoDB) Record Lock(记录锁) S型记录锁(S型与S型兼容，S型与X型不兼容，X型与X型也不兼容) X型记录锁(S型与S型兼容，S型与X型不兼容，X型与X型也不兼容) Gap Lock(间隙锁) 间隙锁只存在可重复读隔离级别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入缓影记录而提出的。 Next-Key Lock(间隙锁加记录锁-临键锁) Next-key lock是包含间隙锁+记录锁的，如果一个事务获取了X型的next-key lock,那么另外一个事务在获取相同范围的X型的间隙锁时，是会被阻塞的。 插入意向锁 插入意向锁不是意向锁，它是一种特殊的间隙锁，属于行级别锁。 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁，如果有的话，插入操作就会发生阻塞，直到有间隙锁的那个事务提交为止，在此期间会生成一个插入意向锁。 MySql是咋加锁的？ 啥SQL语句会加行级锁？ 首先对于支持加行级锁的只有InnoDB，而对于InnoDB存储引擎加锁的语句为\n1 2 3 4 5 6 7 8 9 10 11 //对读取的记录加共享锁(S型锁) select ... lock in share mode; //对读取的记录加独占锁(X型锁) select ... for update; //对操作的记录加独占锁(X型锁) update table .... where id = 1; //对操作的记录加独占锁(X型锁) delete from table where id = 1; update和delete操作都会加行级锁，且锁的类型都是独占锁(X型锁)\nMySql是咋加行级锁？ MySQL行级锁的加锁规则\n唯一索引等值查询 当查询的记录是存在的，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock会退化成记录锁。 当查询的记录是不存在的，在索引树上找到第一条大于该记录的记录后，将该记录的索引中的next-key lock 会退化成间隙锁。 唯一索引范围查询 针对大于等于的范围查询，因为存在等值的查询，那么等值查询的记录存在的话，那么该记录的索引中的next-key锁会退化成记录锁 针对小于或者小于等于的范围查询，要看条件值的记录是否存在于表中: 当条件值得记录不在表中，那么不管是小于还是小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁，其他扫描的记录，都是在这些记录的索引上加next-key锁。 当条件值的记录在表中，如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。 因为存在两个索引，一个是主键索引，一个是非唯一索引(二级索引)，所以在加锁的时候，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。\n非唯一索引等值查询 当查询的记录存在时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描的二级索引记录加的是next-key锁，而对于第一个不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁，同时，在符合查询条件的记录的主键索引上加记录锁。 当查询的记录不存在时，扫描到第一条不符合条件的二级索引记录，该二级索引的next-key锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。 非唯一索引范围查询 该查询进行时，索引的next-key lock 不会有退化为间隙锁和记录锁的情况。 没有加索引的查询 如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加next-key锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。 在线上在执行 update、delete、select \u0026hellip; for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了 update没加索引会锁全表？ 为啥会发生这种事故？\n可能是在update语句的where条件没有使用索引，就会全表扫描，于是就会对所有记录加上next-key锁，相当于加的是表锁。(相当于把整个表锁住了) 上面的情况为啥是可能，因为决定全表扫描的是MySql中的优化器决定的。 如何避免这种事故？\n主观做法\n一定要为需要经常更新的字段加上索引，且执行update语句必须加上where条件。 客观做法 我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。 MySQL 里的 sql_safe_updates的原理和作用 防止意外的大规模数据修改 原理：在sql_safe_updates设置为非0值（通常为1）时，MySQL对于UPDATE和DELETE操作有更严格的限制。这是为了避免因错误的WHERE条件或者缺少合适的限制条件而导致大量数据被意外修改或删除。 示例：假设你有一个包含100万条客户记录的customers表。如果sql_safe_updates为0，执行UPDATE customers SET status = 'inactive'这样没有WHERE条件的语句，会将表中所有客户的状态都更新为inactive。但如果sql_safe_updates为1，这个操作就会被阻止，因为它既没有使用键（例如customer_id）来限制更新范围，也没有LIMIT子句。 提高数据安全性和稳定性 对于开发环境：在开发过程中，开发人员可能会频繁地编写和测试UPDATE和DELETE语句。开启sql_safe_updates可以作为一种安全机制，减少因代码错误而对数据造成不可逆损坏的风险。例如，新手开发人员可能在测试UPDATE语句时，忘记添加WHERE条件，有了这个设置可以避免这种错误操作。 对于生产环境：虽然在生产环境中通常会有更严格的代码审查和测试流程，但意外情况仍可能发生。开启sql_safe_updates可以作为额外的一层保护，防止恶意或误操作对重要数据的破坏。比如，防止有人在数据库管理工具中不小心执行了无限制的DELETE语句。 强制使用合适的更新和删除策略 促进正确的SQL编写习惯：要求UPDATE语句在WHERE子句中使用键或者有LIMIT子句，以及DELETE语句同时具备这两个条件，有助于开发人员养成更谨慎、更精确的SQL编写习惯。例如，开发人员会更加注意在UPDATE语句中使用索引列作为WHERE条件，这样不仅能避免大规模的数据修改，还能提高查询性能。 与索引使用的关联：通过强制使用键（索引），间接鼓励开发人员合理利用索引来优化UPDATE和DELETE操作。这与数据库的性能优化是紧密相关的，因为正确使用索引可以减少锁的范围，提高数据库的并发处理能力。 MySQL记录锁+间隙锁可以防止删除操作而导致的吗? 可以的，对于MySql的可重复读隔离级别下，针对当前读的语句不会出现幻读的现象，因为MVCC机制，对于在快照读的情况下，next-key锁可以避免幻读的现象，因为锁不让进行插入，删除，更新等操作(该锁是X型独占锁) MySQL死锁了，咋办？ 啥是死锁？ 根据操作系统的官方定义来讲的话，就是多个进程互相拥有对方的所需的资源，但是都不放弃自己的资源，从而形成循环等待链，形成僵局。 从数据库的角度来看的话就是一个业务或多个业务在进行幂等性校验时，进行快照读，然后互相占有锁，这样就造成了死锁。 如何避免死锁？ 死锁的四个必要条件:互斥，占有且等待，不可强占用，循环等待。对于这四个条件只要破坏其中任意一个条件就行。 设置事务等待锁的超时时间，这个是破坏了占有且等待的条件。 开启主动死锁检测，破坏了循环等待的条件。 ","date":"2024-12-15T16:07:41+08:00","image":"https://getshhi.github.io/f2.png","permalink":"https://getshhi.github.io/p/mysql%E9%94%81/","title":"MySql锁"},{"content":"事务有哪些特性? 原子性，类似于操作系统中的原语，要不全部完成，要不全部不完成，不会结束在中间某个环节。 原子性是通过undo log(回滚日志)实现的。 一致性，是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如你买了个东西花了200元，卖家赚了200元，但这个200元还在数据库中。一致性是通过持久性，原子性，隔离性共同实现的。 隔离性，是指数据库允许多个并发事务同时对其数据进行读写和修改的能力，也就是说消费者买东西是不影响另一个消费者的。隔离性是通过MVCC(多版本并发控制)或锁机制来保证的。 持久性，是指事务结束后，对数据的修改就是永久的，即使系统故障也不会丢失。 并行事务会引发啥问题? 脏读，脏读就是一个事务读的数据是另一个未提交事务修改得到的数据。 不可重复读，不可重复读就是在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就代表着发生了不可重复读。 幻读，幻读就是在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着产生了幻读现象。(是不是幻读很懵逼的感觉，哈哈😁) 事务的隔离级别有哪些 读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到。这个的话，会出现幻读，不可重复读，脏读。 读提交，指一个事务提交时，它做的变才能被其他事务看到。这个的话，会出现不可重复读，脏读。 可重复读，指一个事务执行中中看到的数据，一直跟这个事务启动看到的数据是一致的，也就是MySQL InnoDB引擎的默认隔离级别。 串行锁; 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能执行。(是不是跟操作系统的p-v操作很像呢)。这个不会出现问题，但会性能较低。 Read Vied 在MVCC里如何工作的? 首先我们需要了解Read Vied 的四个字段的作用 creator_trx_id就是创建该Reda View的事务的事务id。 m_ids是指当前活跃并且未提交的事务id列表。 min_trx_id，是指m_ids中最小事务的事务id。 max_trx_id，是指该事务中这个事务中的id+1。 一般会出现几种情况 如果一个事务的id小于min_trx_id的话，那说明这个事务对于当前的事务是个旧的记录，所存在的是当前事务可见的。 如果一个事务的id不小于min_trx_id的话，并且不大于max_trx_id，并且在m_ids中，说明该版本的记录对当前的事务不可见，如果不在max_trx_id中，说明该版本的记录对当前的事务可见。 如果一个事务的id大于max_trx_id的话，说明该版本的记录对当前的事务不可见。 可重复度读读底层原理是啥？ 可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都在用这个Read View。\n「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。\n读提交的底层原理是啥? 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。\nMySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案: 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。 针对当前读（select \u0026hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。 会发生幻读的例子 对于快照读，MVCC并不能完全避免幻读现象，因为当一个事务更新了另一条事务插入的记录，那么事务前后查询的记录条目就不一样的，所以就发生幻读。 对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他数据插入了一条数据，那么事务后续使用当前进行查询的时候，就会发现前后查询的记录条目就不一样的。 ","date":"2024-12-13T12:13:39+08:00","image":"https://getshhi.github.io/f5.png","permalink":"https://getshhi.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySql事务"},{"content":"合并远程分支 合并远程分支的一般步骤是：\n1.第一步，分别获取远程分支内容到本地； 2.第二步，在本地将两个分支合并； 3.第三步，将合并后的本地分支推送到远程分支，完成合并。\n具体的，以将远程develop分支合并到远程master分支为例，操作过程如下： 1.获取远程develop分支到本地分支（如develop分支）。如果本地已经有分支对应远程develop分支，则可以直接在该分支上执行pull操作或者fetch/merge操作，以获取远程最新内容。否则，可以新建分支跟踪远程develop分支，并获取最新内容到本地；\n2.切换到master分支，并获取远程master分支的最新内容到本地；\n3.将本地develop分支合并到本地master分支；\n4.将本地master分支推送到远程master分支。\n以合并远程develop分支到远程master分支为例，其具体操作步骤如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #切换到develop分支 git checkout develop #获取远程develop分支的内容到本地 git pull origin develop:develop #切换到master分支 git checkout master #拉取远程master分支内容到本地 git pull origin master #合并本地develop分支到master分支 git merge develop #将合并后的分支推送到远程master分支 git push origin master:master rebase操作 merge和rebase的不同 merge的工作流程如下图：\n如上图所示，我们从远程仓库origin的C2版本，创建一个新的分支develop进行开发，并进行了C5、C6两次提交。之后团队中其他成员又向origin推送了两次提交C3、C4。为了合并远程分支上的新内容到本地，我们进行merge操作，将内容合并到develop之后，生成了一次新的提交C7。此时，develop分支还是一个独立的分支。\n而rebase的工作流程如下图：\nrebase又可称为‘变基’，结合上图的话，这个词就很容易理解了。即：\n1.C5、C6本来是在C2这次提交的基础上进行修改的；\n2.现在我们将这个‘基础’改为C4，即将C5、C6的提交作用到C4上去；\n3.在这个过程中，可能会有冲突产生，解决冲突之后就完成了rebase。\n由图可以看到，rebase完成后，源分支上的提交都不见了。\nrebase基础操作 rebase的基本操作是将某个分支的修改到指定分支，其命令格式为：\n1 1.git rebase 基分支 源分支 其中‘基分支’是我们的新的‘基’，而‘源分支’就是需要进行变基操作的分支。这样就能实现将源分支变基到基分支。具体使用示例如下：\n1 1.git rebase master develop 以上语句就能实现将develop变基到master分支。 如果是将当前分支变基到指定分支，则可以直接使用：\n1 git rebase 基分支 这一命令默认将当前分支变基到‘基分支’。如果当前处于develop分支，则其使用示例如下：\n1 git rebase master 这样也能实现将当前的develop分支rebase到master分支。\n由于变基是将修改作用到一个不同的版本上，因此很可能在rebase的过程中出现冲突。和merge一次性合并所有冲突不同的是，rebase的冲突是一个一个解决的。以上图中的rebase操作为例，需要分别解决和C3、C4的冲突。在解决rebase冲突的过程中，当解决完一个冲突的时候，使用如下命令后，才会出现下一个冲突：\n1 2 1.git add -u 2.git rebase --continue 冲突全部解决完后，rebase操作就完成了。 如果在解决冲突的过程中，想放弃rebase操作，则可以使用如下命令撤销rebase操作：\n1 git rebase --abort 这样就能退出rebase，并回退到rebase前的状态。\n储藏之保存 储藏的概念 “储藏”可以获取你工作目录的中间状态（包括修改过的被追踪的文件和已经暂存的变更），并将其保存到一个未完结变更的堆栈中，而且随时可以重新应用。当你不想提交，也不想丢弃当前工作区中的内容，而想切换到其他分支的时候，可以使用储藏命令先暂存工作区中的内容。然后，再回到当前分支的时候，将储藏起来的内容，恢复到工作区之后，即可恢复之前的工作。\n储藏的基本操作 储藏分为保存和应用两个部分。保存就是将当前工作区的内容保存到一个栈中，而应用就是重新应用被保存的工作。\n保存 保存用到的命令是git stash，只需在当前分支执行此命令，即可将当前工作区的内容保存起来。如你在本地版本库创建了helloGit文件，此时查看工作区状态可以得到如下所示提示：\n1 2 3 4 5 On branch master Unt\\fracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) helloGit nothing added to commit but unt\\fracked files present (use \u0026#34;git add\u0026#34; to t\\frack) 当你执行git stash命令，将工作区保存起来之后，再次查看可以得到如下提示：\n1 2 On branch master nothing to commit, working tree clean 此时已经将工作区内容保存了起来，所以才会提示工作区是干净（clean）的。\n重新应用 当你需要再次应用被保存的内容的时候，只需执行git stash apply即可。 因为可能执行了多次保存，所以你需要查看已经保存起来的内容有哪些。查看已经保存的工作的命令如下：\n1 $ git stash list 会得到类似于如下输出：\n1 2 3 stash@{0}: WIP on master: bguebge add helloGit1 stash@{1}: WIP on master: 7gder34 add helloGit2 stash@{2}: WIP on master: 3frfg4g add helloGit3 如上所示，可以得知一共有三个保存。\n如果要应用指定的储藏，则可以使用命令：\n1 git stash apply 储藏标识 这里的储藏标识就是git stash list中显示的类似于stash@{0}的字符串。如：\n1 git stash apply stash@{2} 这样就重新应用了第二次储藏。如果不加储藏标识，就默认应用最近的储藏：\n1 git stash apply 上述命令就重新应用了最近的一次储藏。\n储藏之恢复 储藏的概念 “储藏”可以获取你工作目录的中间状态（包括修改过的被追踪的文件和已经暂存的变更），并将其保存到一个未完结变更的堆栈中，而且随时可以重新应用。当你不想提交，也不想丢弃当前工作区中的内容，而想切换到其他分支的时候，可以使用储藏命令，先暂存工作区中的内容。然后，再回到当前分支的时候，将储藏起来的内容，恢复到工作区之后，即可恢复之前的工作。\n储藏的基本操作 储藏分为保存和应用两个部分。保存就是将当前工作区的内容保存到一个栈中，而应用就是重新应用被保存的工作。\n保存 保存用到的命令是git stash，只需在当前分支执行此命令，即可将当前工作区的内容保存起来。如你在本地版本库创建了helloGit文件，此时查看工作区状态，可以得到如下所示提示：\n1 2 3 4 5 On branch master Unt\\fracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) helloGit nothing added to commit but unt\\fracked files present (use \u0026#34;git add\u0026#34; to t\\frack) 当你执行git stash命令，将工作区保存起来之后，再次查看可以得到如下提示：\n1 2 On branch master nothing to commit, working tree clean 此时已经将工作区内容保存了起来，所以才会提示工作区是干净（clean）的。\n重新应用 当你需要再次应用被保存的内容的时候，只需执行git stash apply即可。 因为可能执行了多次保存，因此你需要查看已经保存起来的内容有哪些，查看已经保存的工作的命令如下：\n1 $ git stash list 会到的类似于如下的输出：\n1 2 3 stash@{0}: WIP on master: bguebge add helloGit1 stash@{1}: WIP on master: 7gder34 add helloGit2 stash@{2}: WIP on master: 3frfg4g add helloGit3 如上所示，可以得知一共有三个保存。\n如果要应用指定的储藏吗，则可以使用命令：\n1 git stash apply 储藏标识 这里的储藏标识就是git stash list中显示的类似于stash@{0}的字符串。如：\n1 git stash apply stash@{2} 这样就重新应用了第二次储藏。如果不加储藏标识，就默认应用最近的储藏：\n1 git stash apply 上述命令就重新应用了最近的一次储藏。\n","date":"2024-12-11T17:13:24+08:00","image":"https://getshhi.github.io/hg4.png","permalink":"https://getshhi.github.io/p/git%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%90%88%E5%B9%B6%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AFrebase%E5%82%A8%E8%97%8F/","title":"Git进阶之合并远程分支、rebase、储藏"},{"content":"解决冲突 冲突的产生 内容冲突 Git内容冲突产生的原因是，针对版本库中某个文件的某项内容，不同的操作对其做了不同的修改，以致于在合并不同的操作时发生矛盾。比如下面的例子：\n1.我们在本地master分支，添加了文件hello，其内容如下：\n1 Learning English is easy and simple 2.然后，我们由master分支切换到一个新的分支develop，并修改hello文件内容如下：\n1 Learning English is easy \u0026amp; simple 3.随后将其提交到了本地develop分支。 我们又切换回master分支，并再次对hello内容进行了修改：\n1 Learning English is easy or simple 这样，当我们将develop分支合并到master分支的时候，就会出现冲突提示如下：\n1 2 3 Auto-merging hello CONFLICT (content): Merge conflict in hello Automatic merge failed; fix conflicts and then commit the result. 冲突出现的原因是，我们在develop分支和master分支上，都对hello文件的内容做了修改，这样当将develop合并到master时，Git就不确定究竟应该采用哪个修改。\n树冲突 方法文件名修改造成的冲突，称为树冲突。比如，A用户把文件C改名为A，B用户把文件C改名为B，那么B合并这两个提交时，就会出现冲突：\n1 2 CONFLICT (rename/rename): Rename \u0026#34;C\u0026#34;-\u0026gt;\u0026#34;B\u0026#34; in branch \u0026#34;HEAD\u0026#34; rename Automatic merge failed; fix conflicts and then commit the result. 此时如果使用git status查看版本库的状态，会得到如下提示信息：\n1 2 3 4 5 6 7 8 9 You have unmerged paths. (fix conflicts and run \u0026#34;git commit\u0026#34;) (use \u0026#34;git merge --abort\u0026#34; to abort the merge) Unmerged paths: (use \u0026#34;git add/rm \u0026lt;file\u0026gt;...\u0026#34; as appropriate to mark resolution) added by them: A added by us: B both deleted: C no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 树冲突产生的原因是，我们将同一文件名，在不同操作中，修改为不同的名字。\n解决冲突 内容冲突 当产生内容冲突时，如果你打开冲突发生的文件，你会在冲突区域发现类似于下面的内容：\n1 2 3 4 5 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;HEAD Learning English is easy or simple ======= Learning English is easy \u0026amp; simple \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; develop 这个就是我们上面所举的内容冲突的例子，冲突文件的内容。从中可以看到\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD与=======包括的是我们当前分支的内容，而=======和\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; develop之间的则是需要合并过来的内容，为了解决冲突我们可以手动解决这些冲突，也可以使用图形化工具帮助解决。如果以手动方式解决，我们可以编辑冲突区域内容为我们想要的内容，比如将其修改成如下内容：\n1 Learning English is easy and simple 然后再执行git add和git commit操作提交，这样就能将冲突解决了。 即解决冲突的一般过程为：\n1.手动编辑冲突区域；\n2.执行git add，将编辑提交到暂存区；\n3.执行git commit，将编辑提交到本地仓库以解决冲突。\n树冲突 解决树冲突时，对于上面示例中的树冲突，如果最终决定采用文件B，我们可以采用如下方式解决：\n1 2 3 4 git rm A git rm C git add B git commit 即从本地仓库中删除A和C文件，然后再添加B文件并最终提交。\n强制操作 强制操作的分类 使用最频繁的强制操作，主要在以下几个方面：\n强制推送 如果远程的某个分支的内容需要被覆盖，这个时候就需要你进行强制推送，使用本地内容去覆盖该分支。 强制合并 如果本地分支的内容需要被远程内容覆盖，这个时候就需要强制合并远程分支内容到本地。 强制删除 如果你需要强制删除版本库、暂存区或者工作区的内容时，就需要强制删除。比如我们之前介绍的checkout，就可以使用-f参数，强制丢弃本地修改。 强制操作方法 强制推送 强制推送和普通推送的区别，就在于在末尾加上了-f参数，即： 1 git push 远程主机名 本地分支名：远程分支名 -f 具体使用方法如下：\n1 2 #将本地分支强制推送到远程主机origin的master分支 git push origin master:master -f 强制合并 强制合并和普通合并的区别，也是其在末尾加上了-f参数，即： git pull 远程主机名 远程分支名：本地分支名 -f 具体使用方法示例如下：\n1 2 #将远程master分支强制合并到本地master分支 git pull origin master:master -f 忽略文件 如何忽略文件 在Git工作区的根目录下，创建一个特殊的.gitignore文件，把要忽略的文件名或者文件名的通配符填进去，然后将.gitignore提交到本地仓库，这样Git就会在你添加或者提交时，自动忽略这些文件。\n自定义忽略文件 如果我们需要自己定义忽略哪些文件，就需要将其添加到.gitignore文件中去。你可以使用文件的全称，或者使用正则匹配的通配符。如下所示：\n1 2 3 4 5 6 7 8 9 10 11 # 忽略指定文件 HelloWrold.class # 忽略指定文件夹 bin/ bin/gen/ # 忽略.class的所有文件 *.class # 忽略名称中末尾为ignore的文件夹 *ignore/ # 忽略名称中间包含ignore的文件夹 *ignore*/ ","date":"2024-12-10T11:48:04+08:00","image":"https://getshhi.github.io/hu1.png","permalink":"https://getshhi.github.io/p/git%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/","title":"Git进阶之冲突处理、忽略文件"},{"content":"创建标签 在开发过程中，commit ID是一串无序的字符，它虽然能唯一标记一次代码提交，即一个版本。但是，它很难记忆和辨识。所以，为了给不同的版本起一个容易辨识的名字，我们可以给这次提交打上一个标签，用不同的标签来对应不同的版本。这样，就相当于给这次提交生成了一个快照。实际上，在为某次提交创建标签的时候，Git会为标签生成一个指针，以指向其对应的提交。然后，我们就可以通过标签找到对应的提交，这样对我们版本发布和代码审查都很有帮助。\n如上图所示，我们为master分支上的三次提交，分别打上0.1、0.2、0.3三个标签。这样，当我们说0.1版本的时候，就对应了第一次提交的代码。这种方式大大降低了代码审查、团队交流及版本发布的复杂性。\n查看标签 查看标签需要用到git tag命令，其具体使用示例如下:\ngit tag\n这样就能列出所有的标签，显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。\n如果标签过多，而你指向显示指定的某些标签，则可以使用正则表达式：\n1 git tag -l \u0026#39;v5.1.2.*\u0026#39; 如上，使用-l参数，并使用v5.1.2.*这一正则表达式，就过滤除了符合要求的标签，其中v5.1.2.*为正则表达式，它能够匹配所有前缀为v5.1.2的标签。实际执行过程中会得到类似于下方的输出：\n1 2 3 4 v5.1.2.1 v5.1.2.2 v5.1.2.3 v5.1.2.4 上方输出信息，为我们列出了目前版本库中已有的四个标签。\n创建标签 不含附注的标签 创建标签的命令格式为：\n1 git tag 标签名 commitID 参数commitID标识了该标签对应的代码版本，如果不提供commitID，就默认为最近一次提交后的代码打标签。例如：\n1 2 git tag v1.0 git tag v1.0 7f8buir2 语句1表示，为最新一次提交后的代码打上v1.0的标签；语句2则表示，为指定的版本7f8buir2打上标签v1.0。\n包含附注的标签 如果需要像提交代码时增加提交日志那样，为每个标签添加说明信息，则需要使用：\n1 git tag -a 标签名 -m \u0026#34;说明信息\u0026#34; 如：\n1 git tag -a v1.0 -m \u0026#39;version 1.0\u0026#39; 表示为此次打的标签，增加一个version 1.0的说明信息。\n在查看标签时，可以使用git show命令，查看某个标签的附注信息。例如：\n1 git show v1.0 表示要查看标签v1.0对应的附注信息。\n推送指定标签 推送指定标签到远程仓库的Git命令如下：\n1 git push 远程主机名 tag名 其中，远程主机名为远程Git版本库对应的主机名，tag名为准备推送的标签名。\n该命令使用示例如下：\n1 git push origin v1.0 该语句表示将v1.0标签，推送到主机名为origin对应的远程仓库。\n推送全部标签 推送指定标签需要用到：\ngit push 远程主机名 \u0026ndash;tags\n其使用方法如下：\ngit push origin \u0026ndash;tags\n其中origin为远程主机名，这样就能将全部标签推送至远程仓库。\n推送全部标签 推送指定标签 推送指定标签，需要用到的命令格式为：\n1 git push 远程主机名 tag名 其使用方法示例如下：\n1 git push origin v1.0 其中origin为远程主机名，这样就能将v1.0推送至远程仓库。\n推送全部标签 推送全部标签需要用到：\n1 git push 远程主机名 --tags 其使用方法示例如下：\n1 git push origin --tags 其中origin为远程主机名，这样就能将全部标签推送至远程仓库。\n删除标签 删除本地标签 删除本地标签，需要用到的命令格式为：\n1 git tag -d 标签名 具体使用方法示例如下：\n1 git tag -d v1.0 这样就能实现删除v1.0标签。\n删除远程标签 删除远程tag，可以使用如下命令：\n1 git push origin --delete tag 标签名 或者如下所示的命令：\n1 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 即推送一个空的tag名到远程仓库，其中指某个标签的名字。\n这两种方式都能实现删除远程的指定标签。\n","date":"2024-12-09T11:48:00+08:00","image":"https://getshhi.github.io/fg2.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A0%87%E7%AD%BE/","title":"Git入门之标签"},{"content":"回到前一次提交 强大的git log 在之前，我们已经介绍了git log的基本使用方法，这里我们要进一步介绍git log的使用。\n查看提交的内容差异 git log提供了-p参数，用于查看每次提交之间的内容差异，如下： git log -p 即可显示每次提交之间的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 commit 92f972422350ef603beb2740a78f57d0f98c1738 (HEAD -\u0026gt; master, origin/mast Author: educoder \u0026lt;user@sample.com\u0026gt; Date: Sat Jan 6 15:57:52 2018 +0800 第一次提交 diff --git a/7-1.sh b/7-1.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-1.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-2.sh b/7-2.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-2.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-3.sh b/7-3.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-3.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-4.sh b/7-4.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-4.sh 而如果想限制显示的范围，则可以再添加参数用于限定：\ngit log -p -2\n如上，则仅显示最近的两次更新。\n如上所示，这一选项附带了每次commit的内容变化，这就为代码审查或者浏览某个搭档的修改内容，提供了很好的参考。\n其他git log选项：\n1.单词层面对比\nGit提供了\u0026ndash;word-diff选项，可以显示单词层面的差异。当需要在书籍、论文这种很大的文本文件上，进行对比的时候，这个功能就非常有用。\n2.显示简要的增改行数\nGit提供了\u0026ndash;stat选项，则可以仅显示增加或者减少了多少行。\n3.pretty选项\n使用\u0026ndash;pretty 选项选项，可以指定不同的显示属性，如oneline 将每个提交放在一行显示。 short，full 和 fuller 可以指定展示的信息的多少。\ngit revert实现版本回退 版本回退可以用git revert命令。git revert撤销提交时，会保留所撤销的提交的记录和历史，并将撤销操作做为一次新的提交。即提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。其具体的使用方法如下：\ngit revert HEAD 撤销前一次 commit git revert HEAD^ 撤销前前一次 commit git revert commit （比如：fa042ce57ebbe5b）撤销指定的版本，撤销也会作为一次提交进行保存 git reset实现版本回退 git reset也能实现版本回退，但是git revert 和 git reset也存在一定的区别 ：\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit；\n在回滚这一操作上看，效果差不多。但是，在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit，“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现。但是git reset是把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入；\ngit reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git reset用法如下：\ngit reset HEAD 回到前一次 commit。也可以用于将错误的文件添加进暂存区后，想回退取消，如： git reset HEAD 文件名\ngit reset HEAD^ 回到前前一次 commit。\ngit reset commit 比如：commit = fa042ce57ebbe5b，回到指定的版本，撤销也会作为一次提交进行保存。\n另外git reset也可以指定reset的模式：hard、soft、mixed、merged、keep。 这几种模式的差别如下：\n\u0026ndash;soft 缓存区和工作目录都不会被改变； \u0026ndash;mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响； \u0026ndash;hard – 缓存区和工作目录，都同步到你指定的提交。 几种模式的具体使用方法如下： 1 2 3 4 5 6 #直接丢弃工作区和暂存区的修改 git reset --hard HEAD #暂存区内容保留，工作区修改丢弃 git reset --mixed HEAD #暂存区和工作区内容都保留 git reset --soft HEAD 回到指定提交 git revert实现版本回退 版本回退可以用git revert命令。使用git revert撤销提交时，会保留所撤销的提交的记录和历史，并将撤销操作做为一次新的提交。即提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。其具体的使用方法如下：\ngit revert HEAD 撤销前一次 commit git revert HEAD^ 撤销前前一次 commit git revert commit （比如：fa042ce57ebbe5b）撤销指定的版本，撤销也会作为一次提交进行保存 git reset实现版本回退 git reset也能实现版本回退，但是git revert 和 git reset有一定的区别 ：\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit； 在回滚这一操作上看，效果差不多。但是，在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit，“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现。但是git reset是把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入； git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git reset用法如下：\ngit reset HEAD 回到前一次 commit。也可以用于将错误的文件添加进暂存区后，想回退取消，如： git reset HEAD 文件名\ngit reset HEAD^ 回到前前一次 commit。\ngit reset commit 比如：commit = fa042ce57ebbe5b，回到指定的版本，撤销也会作为一次提交进行保存。\n另外git reset也可以指定reset的模式：hard、soft、mixed、merged、keep。 这几种模式的差别如下：\n\u0026ndash;soft 缓存区和工作目录都不会被改变； \u0026ndash;mixed 默认选项。缓存区和你指定的提交同步，但工作目录不受影响； \u0026ndash;hard 缓存区和工作目录都同步到你指定的提交。 几种模式的具体使用方法如下： 1 2 3 4 5 6 #直接丢弃工作区和暂存区的修改 git reset --hard HEAD #暂存区内容保留，工作区修改丢弃 git reset --mixed HEAD #暂存区和工作区内容都保留 git reset --soft HEAD 撤销修改 git reset实现版本回退 当将有错误的文件add进暂存区后，可以使用git reset丢弃修改。即： git reset HEAD 文件名 但此时修改仍旧保留在工作区。\n如果尚未add进暂存区，则可以使用：\ngit reset \u0026ndash;hard HEAD\n这样就能彻底丢弃修改，即将修改从暂存区及工作区彻底删除。\ngit checkout丢弃修改 当将错误的文件add进暂存区后，使用git checkout无法将修改从暂存区中撤销，必须要先使用git reset将修改从暂存区中撤销。\n如果只是工作区有了修改，则可以直接使用git checkout进行撤销，具体操作如下：\ngit chekcout \u0026ndash; hello\n通过这种方式，就可将hello文件自上个commit之后，尚未add进暂存区的修改丢弃。\n删除文件 删除文件需要用到的命令是git rm，且git rm有参数\u0026ndash;cached。 当我们需要删除暂存区或分支上的文件，同时工作区也不再需要这个文件了，可以使用：\ngit rm 文件路径\n当我们需要删除暂存区或分支上的文件，但本地又需要使用， 只是不希望这个文件被提交到版本库，可以使用：\ngit rm \u0026ndash;cached 文件路径\n文件已添加至暂存区 如果文件被添加到了暂存区，这种情况下直接使用git rm file_path会报错：\n1 2 3 4 $ git rm hello.txt error: the following file has changes staged in the index: hello.txt (use --cached to keep the file, or -f to force removal) 根据提示我们可以得知，这个时候，如果不想保留hello.txt，则可以使用：\ngit rm hello.txt -f\n如果想保留hello.txt到工作区则可以使用：\ngit rm \u0026ndash;cached hello.txt\n","date":"2024-12-08T11:47:55+08:00","image":"https://getshhi.github.io/fg1.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E6%97%A5%E5%BF%97%E5%92%8C%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","title":"Git入门之日志和版本回退"},{"content":"入门之分支管理 创建本地分支 当初始化一个版本库并进行第一次提交的时候，如果没有创建指定分支，并切换到该分支，commit操作默认会在本地创建master分支，并将内容提交到master分支。一般我们会在版本库中维护一个master分支，如下图所示：\n我们在master分支上，进行了C1、C2、C3三次提交，且当前指针指向C3提交。一般情况下，我们只会将已经成熟的代码存放到master分支，而将正在开发的代码或者测试版的代码放到其他分支。这时，我们就需要新建分支，以在该分支进行开发。如下图：\n当我们在主分支进行了C2提交后，新建了develop分支，并在其上进行了两次提交。此时，工作区指针HEAD指向develop分支。 创建本地分支用到的命令是git branch，而分支切换用到的命令是git checkout。git checkout是有很多用途的命令，在这里我们只讲它在分支操作中的使用。下面我们详细介绍这两个命令的使用。\n分支切换 可以使用git checkout 命令切换到其他分支。如你本地有master分支和develop分支，目前你正处于develop分支进行开发，现在你想切换到master去，则可以执行操作： git checkout master 这样就能切换到master分支继续进行开发。\n创建新的分支 当你需要创建一个新的分支的时候，可以使用git branch命令，其具体使用格式为： git branch 新的分支名字 使用示例如下：\n1 2 #创建名为new_branch的新分支 git branch new_branch 创建新分支的同时切换 切换到一个新的分支，有一个更为简洁的命令：git checkout -b，它的使用格式为： git checkout -b 新的分支 名字 其具体使用方法如下：\ngit checkout -b new_branch\n这样就可以创建，并切换到了new_branch分支。\n删除本地分支 现在我们来看一个实际的例子。请看下图：\n首先，我们在master工作到 C1，然后开始一个新分支develop分支，做为测试版的代码分支。提交到C5的时候，又需要临时解决一个问题，于是从C5的地方又分出一个分支issue。提交到C7的时候，该issue被解决。issue分支已经失去其意义，则需要将其删除，以保持本地版本库分支树的干净。我们将issue分支上的代码，合并到develop上之后，就可将issue分支删除。删除issue分支后的分支树如下：\n其中，C8为合并issue分支所进行的提交。\n删除本地分支，需要用到git branch命令，且需要-D参数，具体命令格式为： git branch -D 需要删除的分支的名字\n具体使用示例如下：\n1 2 #删除develop分支 git branch -D develop 示例中的命令，能够将本地分支develop删除。\n删除远程分支 删除分支用到的git命令是git push，在具体的使用过程中有不同的用法。\n通过推送空分支到远程分支，实现删除。 一个删除远程分支的方法是，推送一个空分支到远程指定分支，以实现删除。推送本地分支到远程分支的方法是： git push 远程主机名 本地分支:远程分支 与之类似，推送空分支实现删除的方法是： git push 远程主机名 :远程分支 即：前没有指定本地分支名。具体的使用示例如下：\n1 2 #删除远程develop分支，其中origin为远程仓库名 git push origin :develop 通过delete参数删除远程分支： 除了推送空分支到远程分支外，也可以通过delete参数实现删除。具体的命令格式为： git push 远程主机名 \u0026ndash;delete 远程分支名 具体使用示例如下： 1 2 #删除远程develop分支,其中origin为远程主机名 git push origin --delete develop 本地分支合并 分支合并需要用到git merge命令，具体的命令格式为：\ngit merge 需要合并的分支\n在具体使用中，如当前处于master分支，需要将develop分支合并到master分支，则具体的使用方式如下：\ngit merge develop\n同时，分支合并也分为正常合并和快进式合并，通过为git merge添加参数，即可实现不同操作。\n快进式合并 默认情况下，Git执行\u0026quot;快进式合并\u0026quot;，即fast-farward merge，会直接将被合并的分支指向需要合并的分支。如下图： 当需要将右侧分支（develop）合并到左侧分支（master）时，master分支会生成一个指针，直接指向develop。快进式合并为默认合并方式，不需要添加任何其他参数，使用git merge 需要合并的分支即可完成。\n正常合并 正常合并的方式如下图： 如图所示，Master分支上产生了一次新的提交，也就是说生成一个新节点完成了合并，这样的话，版本演进更清晰。\n下面我们以一个具体的例子，来演示一下这两种合并方式的区别：\n1.创建master分支，并在其上提交hello文件；\n2.从master分支切换到新分支develop，并进行两次提交，分别将hello1、hello2两个文件提交到develop分支；\n3.切换回master分支，执行git merge develop进行快进式合并，然后查看master分支的日志，得到如下提示信息：\n如上图可知，master分支多了develop分支上的两次提交信息。\n4.将master分支回退到合并前状态，再次执行git merge \u0026ndash;no-ff develop，进行非快进式合并，然后再次查看日志：\n可见，master分支发生了分叉，且master多了一次提交。\n通过以上分析，两种合并方式的区别就很明显了。\n","date":"2024-12-07T11:47:50+08:00","image":"https://getshhi.github.io/nn1.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","title":"Git入门之分支管理"},{"content":"入门版本库 本地版本库创建 Linux基础操作 在现今的软件开发中，Linux系统及其命令行的使用，已经是一项必不可少的技能。虽然有其他基于Git的图形化软件，但是Git只能通过命令行进行操作。因此，掌握一些基础的Linux操作命令很有必要。\n创建某个目录 有时我们需要创建目录，这时就需要使用命令mkdir。通过mkdir，可以在指定的目录下创建文件夹，其用法如下：\n在当前目录下，创建目录helloGit: mkdir helloGit\n在/home目录下，创建目录helloGit：mkdir home/helloGit\nmkdir的其他高级用法请参考其他Linux资料。\n创建文件 创建文件可以使用命令touch，其用法如下:\n在当前目录下，创建文件helloGit.txt：touch helloGit.txt 在/home目录下，创建文件helloGit.txt：touch /home/helloGit.txt 进入目录 进入某个目录，需要用到命令cd，其用法如下：\n进入helloGit目录：cd helloGit 这样的用法默认了helloGit目录，存在于当前目录下。也可以在cd命令中，直接指定进入当前目录：cd ./helloGit\n进入/home/helloGit目录：cd /home/helloGit\n返回到上一级目录：\n在Linux系统下，上一级目录可以用‘..’代替，如：\n1 2 3 4 5 6 #进入上一级目录 cd .. #进入上一级目录的再上一级目录 cd ../../ #进入上一级目录下的helloGit cd ../helloGit 使用Git前的准备 安装 Git可以使用源码安装，具体的安装过程请参考Git官网教程或者Github上Git仓库的用户指南。\n但对于初学用户，还是建议大家直接安装。\nLinux下安装： 1 2 3 4 #Fedora下安装 yum install git-core #Ubuntu等Debian类体系结构系统下 apt-get install git Mac上安装： 在 Mac 上安装 Git 有两种方式。可以使用图形化的 Git 安装工具，网址为图形化Git工具安装地址；另一种是通过MacPorts 安装。如果已经装好了 MacPorts，请用下面的命令安装 Git：\nsudo port install git-core +svn +doc +bash_completion +gitweb\nWindows下安装：\n在 Windows 上安装 Git，可以到 Git官网 的页面上，下载 exe 安装文件并运行：\nGit官网下载\n完成安装之后，就可以使用命令行的 git 工具了。建议大家最好使用Unix风格的shell来运行Git。另外，Linux也有其他图形化的Git工具，如Tortoisegit。不过，还是建议大家直接使用shell来运行Git。\nGit配置 由于Git是一个分布式的版本控制系统，所以当利用它进行分工协作时，必须区分不同的机器。这一点可以通过配置机器的名字和邮箱完成。Git初始使用时，也会提示进行配置。配置命令如下：\n1 2 $ git config --global user.name \u0026#34;Your Name\u0026#34; $ git config --global user.email \u0026#34;email@example.com\u0026#34; 在实际的使用过程中，可以将“Your Name”、“email@example”替换为自己实际的名字和邮箱。\n如何创建一个本地版本库 首先，我们需要创建一个目录，做为我们的本地版本库，然后使用git init命令，将其初始化为一个本地版本库，如下：\n1 2 3 4 5 6 #在/home目录下，创建repo目录 mkdir /home/repo #进入repo目录 cd /home/repo #将repo初始化为一个本地版本库 git init 通过上述命令，即可在/home目录下，创建repo目录，并将其初始化为一个版本库。\n添加修改到暂存区域 如何将修改保存到暂存区 本地版本库就相当于一个存放在本地的仓库，里面记录了我们本地文件的各种版本及不同版本之间的差异。当我们添加、删除或者修改了文件之后，我们必须将修改添加至工作区以暂时保存（Git的工作原理请认真阅读背景知识部分）。\n添加修改，并保存至工作区，需要用到git add命令，git add命令的使用方式如下所示：\n1 2 3 4 #添加所有修改 git add . #添加hello.txt文件 git add hello.txt 如上所示，当需要添加所有文件至工作区时，使用git add .，如果想添加指定文件，只需要像示例中添加hello.txt一样，将文件名做为参数名，传给git add即可。\n查看工作区状态 当你创建完helloGit.txt，而且没有将其添加到暂存区域时，如果使用git status命令，你会得到类似于下面的输出（中文）：\n1 2 3 4 5 6 7 8 9 # 位于分支 master # # 初始提交 # # 未跟踪的文件: # （使用 \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; 以包含要提交的内容） # # helloGit.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 或者这种（英文）：\n1 2 3 4 5 6 7 8 9 On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: src/gitTraining no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 这是什么？这是提示你工作区有被修改的文件，未提交至暂存区。 当你执行完git add之后，会得到类似于下面的输出：\n1 2 3 4 5 6 7 8 9 # 位于分支 master # # 初始提交 # # 要提交的变更： # （使用 \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; 撤出暂存区） # # 新文件： helloGit.txt # 或者这种：\n1 2 3 4 5 6 On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: src/gitTraining.java 这是在提醒你，暂存区有哪些内容需要提交到本地仓库。\n其实git status命令用来查看当前工作区的状态，即有哪些已经修改，还尚未提交到暂存区的文件。在实际的开发过程中，面对复杂的程序文件，你经常需要查看一下，自己对哪些文件做了修改，此时git status命令就很有用了。\n撤销修改 checkout命令用法如下：\n1 git checkout helloGit.txt 这样就能把已经添加到本地的helloGit.txt从暂存区中移除。\n提交修改到本地仓库 如何将修改提交到本地仓库 将修改添加到暂存区，只是将你的工作暂时保存，并没有添加到本地的仓库中。这个过程可以类比写文件，将修改添加至暂存区，就相当于把内容先放入缓存区。因此，我们必须将工作区的内容提交到本地版本库去，才算是真正地保存了修改。\n提交修改到本地仓库，使用命令git commit，其使用方式如下所示：\n1 git commit -m \u0026#34;示例提交\u0026#34; -m参数后面跟的是本次提交的具体内容，用来说明你这次的提交，主要是做了哪些修改，这个说明内容是必须的。\n解析commit的输出结果 在执行完git commit命令之后，会得到类似于下面的返回结果：\n1 2 3 [master（根提交） 37302ce] 添加helloGit.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 helloGit.txt 其中：\n“添加helloGit.txt”为“-m”的参数，即执行的命令为git commit -m \u0026ldquo;添加helloGit.txt\u0026rdquo;； “1 file changed, 0 insertions(+), 0 deletions(-)” 提示改动信息； “37302ce”这个字符串则是本次提交的Id，commit Id唯一对应一次提交。 令人惊喜的git log和git status 当执行完git commit后，如果你试着执行以下git log你可能会得到如下的输出：\n1 2 3 4 5 commit 37302ce99137cf30fabc14784d23ea63cadb928b Author: hdu \u0026lt;hdu@163.com\u0026gt; Date: Sun Dec 24 23:35:48 2017 +0800 添加helloGit.txt 其中：\n“commit 37302ce99137cf30fabc14784d23ea63cadb928b”中的后面这一串字符就是完整的commit id； “Author”就是这次提交的作者，它就是我们在git config中配置的user.name； 最后输出的“添加helloGit.txt”，是我们在提交时添加的信息。 如果有多次提交即commit，在执行git log时，会输出每一次的提交的具体信息。这样的话，什么时候（Date）由什么人（Author）提交了什么内容（“添加helloGit.txt”）就一目了然了。\n入门远程版本库 克隆操作 克隆，顾名思义，就是要获取远程版本库的完整拷贝。通过克隆操作，你可以将整个远程版本库的各种细节复制到本地，并且会建立起本地版本库和远程版本库的对应关系。\n克隆操作需要用到的命令是git clone，它的具体用法如下所示：\n1 git clone https://sample.git 通过这样的操作，就能将远程版本库复制到本地了，而且会默认克隆到sample文件夹下（对应于远程版本库地址中指定的sample）。同时，你也可以根据需要，指定克隆到其他目录下，其命令格式为：\n1 git clone xxx.git \u0026#34;指定目录\u0026#34; 这样就能将代码都复制到指定目录下。\nGit服务器 在团队开发中，我们必须选用一台主机做为Git服务器来存放远程版本库。这样团队中的每个开发者，就可以基于一个共同的远程版本库进行开发。目前提供代码托管（即可以将远程版本库存放于其上的）的平台有Github、码云等，同时我们也可以搭建一台私有的运行Git的服务器，来做为远程Git服务器。Github等平台的使用，及本地Git服务器的搭建，会在后续的实训中具体介绍。本地Git服务器，可以配置不同的连接方式，如shell、git或bash。为了给挑战者提供一个便利的实训环境，我们为每个人配置了一台本地Git服务器，并允许以bash方式进行操作，即可以通过类似于/home/sample.git这种形式的地址，做为远程仓库地址进行操作，而不是像https://sample.git这种形式。\n添加远程版本库 添加远程版本库需要用到的命令是git remote add，其命令格式为：\n1 git remote add “远程仓库名” “远程仓库地址” 使用示例如下：\n1 git remote add origin https://sample.git 这样就将https://sample.git添加为远程仓库，并将其命名为origin。\n推送本地内容到远程仓库 推送本地内容时，会将所有未推送至远程仓库的内容，都提到远程仓库。它用到的命令是git push，使用方法如下：\n1 git push 远程仓库名 本地分支名 远程分支名 具体的使用方法如下：\n1 git push origin master master 这样就将本地分支的内容，推送到远程仓库origin的master分支了。 git push的另外一种用法如下：\n1 git push -u 远程仓库名 本地分支名 远程分支名 -u参数的作用是，建立起本地master分支和远程master分支之间的对应关系，下一次如果再推送master分支，就可以忽略远程分支名了，如下所示：\n1 2 3 4 #初次推送 git push -u origin master master #再次推送 git push origin master 拉取远程分支到本地 拉取远程仓库的内容到本地，需要使用git pull命令，其命令格式为：\n1 git pull 远程主机名 远程分支名 本地分支名 其使用示例如下：\n1 2 #将远程仓库origin的master分支的内容拉取到本地master分支 git pull origin master:master 但是，在使用过程中，也可能会出现一种情况：远程分支和本地分支对同一内容做了修改，这就会导致将远程分支的修改，合并到本地分支的时候发生冲突。这个时候，可以选择解决冲突，然后合并（解决冲突会在后续的实训中介绍）。也可以选择直接强制拉取，使用远程分支的修改，覆盖本地分支的修改。强制拉取需要用到-f参数，语法格式如下：\n1 git pull 远程主机名 远程分支名 本地分支名 -f 具体的使用示例如下：\n1 2 #将远程仓库origin的master分支的内容拉取到本地master分支 git pull origin master:master -f ","date":"2024-12-06T11:47:39+08:00","image":"https://getshhi.github.io/nn.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E7%89%88%E6%9C%AC%E5%BA%93%E5%92%8C%E5%85%A5%E9%97%A8%E8%BF%9C%E7%A8%8B%E7%89%88%E6%9C%AC%E5%BA%93/","title":"Git入门版本库和入门远程版本库"},{"content":"为啥MySQL InnoDB 选择B+tree作为索引的数据结构？ B+Tree vs B Tree: B+Tree只有叶子节点存储数据，而B Tree索引和数据都存，这样会导致在相同的条件下，B Tree的一个数据节点能够存储的索引减少，导致B Tree的深度会较长，从而造成IO时间较长，性能较差。 B+Tree 的叶子节点是用双链表进行连接的，进行范围查询较为方便。 B+Tree vs 二叉树 对于二叉树来说，有可能会退化成时间复杂度为O(n)的(对于插入操作一直插入大的或一直小的)。 对于二叉树来说，仅仅能存储一个索引，会导致层数增加，从而导致IO时间较长。 B+Tree vs Hash 对于Hash来说，Hash不能进行范围查询 啥时候使用索引？ 字段有限制的，适合当索引。 经常用于WHERE查询条件的字段。 经常用ORDER BY 和GROUP BY的字段。 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 啥时候不使用索引？ 字段中存在大量重复数据，不需要创建索引。 WHERE条件，GROUP BY，ORDER BY 里用不到的字段。 经常需要更新的表，查询频率较小的表。 字段中存在大量重复数据，不需要创建索引。 表数据较少的不用创建索引，数据较少时全表查询效率已经很高了，如果加入索引会增加存储压力。 啥时候索引会失效？ 不符合最左匹配原则的。 模糊查询用%x和%x%的。 将索引加入计算的表达式中。 将索引加入函数中。 在WHERE从句中的输入为字符串，但是字段的属性为INT类型。 WHERE 子句中的 OR 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。(解决方案:可以采让全部都是)\n有啥优化索引的方法？ 前缀索引优化 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\n覆盖索引优化 我们可以建立一个联合索引，即「分组ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。\n主键索引最好是自增的 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。\n如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。\n防止索引失效 如果索引失效的话，那么这个索引将会失效，这个索引将会不起作用。\n索引最好设置为NOT NULL 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。\n第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中至少会用 1 字节空间存储 NULL 值列表。\n啥是索引？ 索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。(可以类比书籍的目录，简单来说就是用于快速检索数据的数据结构)\n不同存储引擎支持的索引结构 索引 InnoDB MyISAM Memory B+tree索引 支持 支持 支持 Hash 索引 不支持 不支持 支持 R-tree 索引 不支持 支持 不支持 Full-text 5.6版本之后支持 支持 不支持 索引分类 按照数据结构分类 索引结构 描述 B+Tree索引 最常见的索引类型，大部分引擎都支持 B+ 树索引 Hash索引 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 R-tree (空间索引） 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-text(全文索引) 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES 按照物理存储分类 分类 含义 特点 聚集索引(ClusteredIndex) 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 必须有,而且只有一个 二级索引(SecondaryIndex) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 按照字段特性分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建, 只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 按照字段个数分类 分为单列索引和联合索引\n索引设计原则 1 针对于数据量较大，且查询比较频繁的表建立索引。 2 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。 3 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 4 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。 5 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 6 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。 7 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。 MySQL单表不要超过2000W行，靠谱吗？ 这个不是靠谱的，因为MySQL的行数与这个数据的大小有关系，对于不同的数据大小自然有不同的评判标准，我们应该根据B+树不能超过3层和具体的业务等等来进行判断。 哪种count性能最好？ count(*) = count(1) \u0026gt; count(主键字段) \u0026gt; count(普通字段)\ncount(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。 count(1) == count(*)的原因是 InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference. count(1) 和count(*) 比count(主键字段)高效的原因是前两者不用判断是否为null 不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。 为啥InnoDB要通过遍历的方式来计数？ 因为InnoDBInnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的 如何优化count(*)? 可以采用近似值。 浏览器的搜索就是采用这个的。 采用额外表保存计数值。 ","date":"2024-12-05T13:11:20+08:00","image":"https://getshhi.github.io/bk.png","permalink":"https://getshhi.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySql索引"},{"content":"MySql内部结构 执行一条select语句，期间发生了啥？ 先说结论\n首先客户端会与服务端的连接器进行连接，连接器会检查客户端传来的账号，密码，核对一下是否正确，如果正确，就会开始读取所属的用户和用户权限，并把这个信息保存在连接器中，如果不正确，会返回错误。 然后开始查询缓存(针对已经查过的数据，会以key-value的形式存储在缓存中)，如果key中有对应的值，则直接返回其value值。(MySQL 8.0已经删除这个模块) 其次会解析SQL，解析器会先进行词法分析，然后进行语法分析，构造语法树，如果语法错误，会返回错误。 最后执行SQL，首先在预处理器中会判断是否缺少字段，然后在优化器中选择合适的SQL查询方案，尽可能地提高性能，最后在执行器中按照执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端。 逐步分析 连接器 与客户端进行 TCP 三次握手建立连接； 校验客户端的用户名和密码，如果用户名或密码不对，则会报错； 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限； 查询缓存 如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。 如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。 其实这个很无用(对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。)，所以MySQL 8.0 版本直接将查询缓存删掉了。 解析SQL 第一件事，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from； 第二件事语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。 执行SQL 预处理器 检查 SQL 查询语句中的表或者字段是否存在； 将 select Fields 中的内容扩展为该有的列； 优化器 主要负责将SQL查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。 执行器 主键索引查询 全表扫描 索引下推 最终的效果图 MySql的数据存放在哪个文件？ 对于MySql5.7来说 db.opt，用来存储当前数据库的默认字符集和字符校验规则。 student.frm，student的表结构会保存在这个文件中。 student.ibd，student的表数据会保存在这个文件中。 对于MySql8.0来说 这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 表空间文件的结构是啥？ 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的。 InnoDB 行格式有哪些？ InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。\nRedundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。 Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。 COMPACT 行格式长什么样？ 主要分为真实数据和额外的信息，图如下\n为什么「变长字段长度列表」的信息要按照逆序存放？ 逆序存放变长字段长度列表可以使得位置靠前的记录的真实数据和数据对应的字段长度信息同时在一个CPU Cache Line中。这有助于提高CPU缓存的命中率，从而加快数据访问速度。 当读取记录时，首先读取的是记录头信息，然后根据变长字段长度列表中的信息，从后往前读取各个字段的长度，进而确定每个字段的起始位置和长度。 这种设计还有助于减少磁盘I/O操作，因为相关的长度信息和数据可以一起被加载到内存中，减少了额外的读取次数。 varchar(n)最大取值为多少？ 不管是单字段还是多字段，算 varchar(n) 中 n 最大值时，都需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\n行溢出后，MySQL是咋处理的? InnoDB存储引擎会自动将溢出的数据存放到[溢出页]中。\nCompact行溢出时，会保存该列的一部分数据，而把剩余的数据放在[溢出页]中，然后真实数据处用20字节存储指向溢出页的地址，从而可以找到剩余数据的页。 Compressed和Dynamic这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储20个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。 ","date":"2024-12-04T18:42:40+08:00","image":"https://getshhi.github.io/kj4.png","permalink":"https://getshhi.github.io/p/mysql%E5%9F%BA%E7%A1%80/","title":"MySql基础"},{"content":"HashMap和Hashtable的区别\nHashMap和HashSet的区别\nHashMap和TreeMap的区别\nHashSet如何检查重复\nHashMap的底层实现\nHashMap的长度为啥是2的幂次方\nHashMap多线程操作导致死循环问题\nHashMap为啥线程不安全\nHashMap的遍历方式有哪些？\nHashMap和Hashtable的区别 线程是否安全，HashMap的线程是不安全的，Hashtable的线程是安全的。 效率:因为线程安全的问题，HashMap要比Hashtable的效率高一点。另外，Hashtable被淘汰了。 HashMap可以有一个null键和多个null值，但HashTable不允许有null键和null值。 哈希函数的实现: HashMap对哈希值进行了高位和低位的混合扰动处理以减少冲突，而Hashtable直接使用键的hashCode()值。 HashMap和HashSet的区别 HashMap存储键值对，HashSet仅仅存储对象。 HashMap实现Map接口，HashSet实现了Set接口。 HashMap调用put()向map添加元素，HashSet调用add()方法向Set中添加元素。 HashMap和TreeMap的区别 相对于HashMap实现了AbstractMap，TreeMap还实现了NaivgableMap接口和SortedMap接口。 实现的Naivgable让TreeMap有了对集合内元素的搜索的能力。 实现SortedMap接口让TreeMap有了对集合中的元素根据键排序的能力。 HashSet如何检查重复 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。\nHashMap的底层实现 HashMap的底层代码分析与实现\nHashMap的长度为啥是2的幂次方 位运算效率更高: 位运算(\u0026amp;)比取余运算(%)更高效。当长度为2的幂次方相较于%length，\u0026amp;(length - 1)等价。 可以更好地保证哈希值的均匀分布:扩容之后，在旧数组元素hash值比较均匀的情况下，新数组元素也会被分配的比较均匀。 对于每次的扩容，不需要其他的操作，仅仅需要根据高危的变化进行重新分配(如果高位是1，则原位置 + 扩容的容量，高位是0，则位置不变)。 HashMap多线程操作导致死循环问题 JDK1.7及之前的版本导致的死循环问题的原因是当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。 而对于HashMap会出现数据覆盖的结果，所以在多线程也不推荐HashMap。 HashMap为啥线程不安全 两个线程同时put操作导致size的值不正确，进而导致数据覆盖的问题。 在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。 HashMap的遍历方式有哪些？ 迭代器EntrySet方式：通过获取HashMap的entrySet集合，然后使用迭代器进行遍历。这种方式可以同时访问键和值。\n迭代器KeySet方式：通过获取HashMap的keySet集合，然后使用迭代器进行遍历。这种方式只能访问键，需要通过键来获取对应的值。\nForEach EntrySet方式：使用增强型for循环直接遍历HashMap的entrySet集合。这种方式同样可以同时访问键和值。\nForEach KeySet方式：使用增强型for循环直接遍历HashMap的keySet集合。这种方式只能访问键，需要通过键来获取对应的值。\nLambda表达式方式：通过使用Lambda表达式对HashMap中的每个元素进行处理。这种方式代码简洁，易于理解。\nStreams API单线程方式：使用Streams API的stream()方法将HashMap转换为流，然后使用forEach方法进行遍历。这种方式适用于单线程环境。\nStreams API多线程方式：使用Streams API的parallelStream()方法将HashMap转换为并行流，然后使用forEach方法进行遍历。这种方式适用于多线程环境，可以提高遍历效率。\n","date":"2024-12-03T17:32:54+08:00","image":"https://getshhi.github.io/kj2.png","permalink":"https://getshhi.github.io/p/java%E9%9B%86%E5%90%882/","title":"Java集合(2)"},{"content":"1.DDL语句 DDL用于定义和修改数据库结构，包括创建、修改和删除表、索引等。\nCREATE: 创建数据库、表或视图。 1 2 CREATE DATABASE my_database; CREATE TABLE my_table (id INT PRIMARY KEY, name VARCHAR(255)); ALTER: 修改现有的数据库结构。 1 ALTER TABLE my_table ADD COLUMN age INT; DROP: 删除数据库、表或视图。 1 2 DROP DATABASE my_database; DROP TABLE my_table; TRUNCATE: 清空表中的所有数据，但保留表结构。 1 TRUNCATE TABLE my_table; DML (Data Manipulation Language) DML用于插入、更新和删除表中的数据。 INSERT: 向表中插入新数据。 1 INSERT INTO my_table (id, name) VALUES (1, \u0026#39;John Doe\u0026#39;); UPDATE: 更新表中的现有数据。 1 UPDATE my_table SET name = \u0026#39;Jane Doe\u0026#39; WHERE id = 1; DELETE: 从表中删除数据。 1 DELETE FROM my_table WHERE id = 1; DCL (Data Control Language) DCL用于控制对数据库的访问权限。 GRANT: 授予用户权限。 1 GRANT ALL PRIVILEGES ON my_database.* TO \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39;; REVOKE: 撤销用户权限。 1 REVOKE ALL PRIVILEGES ON my_database.* FROM \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39;; TCL (Transaction Control Language) TCL用于管理事务，确保数据的一致性和完整性。 COMMIT: 提交当前事务。 1 COMMIT; ROLLBACK: 回滚当前事务。 1 ROLLBACK; SAVEPOINT: 设置保存点（在事务中）。 1 SAVEPOINT savepoint_name; RELEASE SAVEPOINT: 释放保存点。 1 RELEASE SAVEPOINT savepoint_name; DQL (Data Query Language) DQL用于查询数据库中的数据。 SELECT: 从表中检索数据。 1 2 SELECT * FROM my_table; SELECT name FROM my_table WHERE id = 1; JOIN: 连接多个表。 1 SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.id; 6.Other Common SQL Clauses and Functions 其他常见的SQL子句和函数：\nWHERE: 过滤条件。 1 SELECT * FROM my_table WHERE id \u0026gt; 10; ORDER BY: 排序结果。 1 SELECT * FROM my_table ORDER BY name ASC; GROUP BY: 分组数据。 1 SELECT name, COUNT(*) as count FROM my_table GROUP BY name; HAVING: 过滤分组后的数据。 1 SELECT name, COUNT(*) as count FROM my_table GROUP BY name HAVING count \u0026gt; 1; 1 SELECT * FROM my_table LIMIT 10; UNION: 合并多个查询的结果。 1 SELECT id FROM table1 UNION SELECT id FROM table2; 7.注意事项 在编写MySQL查询时，SQL语句的子句和函数的顺序通常遵循一定的规则。\nSELECT: 指定要选择的列。 FROM: 指定数据来源的表。 JOIN: 如果有多个表进行连接，使用 JOIN 子句。 WHERE: 过滤记录的条件。 GROUP BY: 对结果集进行分组。 HAVING: 对分组后的结果进行过滤。 ORDER BY: 对结果集进行排序。 LIMIT: 限制返回的记录数。 OFFSET: 跳过指定数量的记录（通常与 LIMIT 一起使用）。 1 2 3 4 5 6 7 8 SELECT column1, column2, aggregate_function(column3) FROM table1 JOIN table2 ON table1.common_column = table2.common_column WHERE condition GROUP BY column1, column2 HAVING aggregate_condition ORDER BY column1 ASC, column2 DESC LIMIT 10 OFFSET 5; ","date":"2024-11-30T16:37:58+08:00","image":"https://getshhi.github.io/jk1.png","permalink":"https://getshhi.github.io/p/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","title":"MySql的基本用法"},{"content":"Java集合概览\n说说List，Map，Set，Queue的区别\n集合框架底层数据结构总结\n如何选用集合？\n为啥要使用集合？\nArrayList和Array(数组)的区别\nArrayList和Vector的区别\nVector和Stack的区别\nArrayList可以添加null值吗\nArrayList插入和删除元素的时间复杂度\nLinkedList插入和删除元素的时间复杂度是多少\nLinkedList为啥不能实现RandomAccess接口\nArrayList与LinkedList区别\nArrayList的扩容机制\nComparable和Comparator的区别\n无序性和不可重复性的含义是啥\n比较HashSet，LikedHashSet和TreeSet三者的异同\nQueue与Deque的区别\nArrayDeque与LikedList的区别\n说一说PriorityQueue\n啥是BlockingQueue\nBlockingQueue的实现类有哪些\nArrayBlockingQueue和LinkedBlockingQueue有啥区别？\nJava集合概览 Java集合分为Collection和Map，其中Collection接口分为Set，List，Queue，用来存储单一元素，而Map接口用来存储键值对。 说说List，Map，Set，Queue的区别 List(对付顺序的好帮手):存储有序的，可重复的元素。\nMap存储键值对，通常用这个查询键值对组合。value是无序的，可重复的，Key是无序的，不可重复的。\nSet(注重独一无二的性质):存储不重复的元素。\nQueue(实现排队功能的叫号机):按特定的排队规则来确定先后顺序，存储的元素是有序的，可重复的。\n集合框架底层数据结构总结 List\nArrayList: Object[]数组。 Vector: Object[]数组。 LinkedList: 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) Set\nHashSet(无序，唯一):基于HashMap实现的，底层采用HashMap来保存元素。 LinkedHashSet:LinkedHashSet是HashSet的子类，并且内部是通过LinkedHashMap来实现的。 TreeSet(有序，唯一):红黑树(自平衡的排序二叉树)。 Queue\nPriorityQueue:Object[]数组来实现小顶堆。 DelayQueue:PriorQueue。 ArrayDeque:可扩容动态双向数组 Map\nHashMap:JDK1.8以前HashMap是由数组+链表组成的，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。JDK1.8以后数组+链表+红黑树。 LinkedHashMap:LinkedHashMap继承自HashMap，所以它的底层是数组+链表+红黑树，并且加了一条双向链表。 Hashtable:数组+链表组成的，数组是Hashtable的主体，链表则主要是为了解决哈希冲突而存在的。 TreeMap:红黑树(自平衡的排序二叉树)。 如何选用集合？ 根据键值获取元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap。 我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后根据实现这些接口的集合的特点来选用。 为啥要使用集合？ 根据我们开发时存储的形式是各种各样的，传统的数组已经不能满足这个需求，我们需要一个容器能过够存储各种各样的，这就是集合。\nArrayList和Array(数组)的区别 ArrayList会根据实际存储元素动态地扩容或者缩容，而Array被创建之后就不能改变它的长度。 ArrayList让你使用泛型来确保类型安全，Array则不可以。 ArrayList提供了丰富的API操作方法，比如add()，remove()等。Array只是一个固定长度的数组，只能按照下标访问其中的元素或者增强循环访问其中的元素，不具有动态添加，删除元素的能力 ArrayList创建时不需要指定大小，而Array创建时必须指定大小。 ArrayList只能存储对象，而Array都可以存(基本数据类型和对象) ArrayList和Vector的区别 ArrayList是List接口的主要实现类，线程不安全，用于单线程且查询频繁的场景(线程不安全)。 Vector用于多线程，它是线程安全的。 Vector和Stack的区别 Vector和Stack两者都是线程安全的，都是使用synchronized关键字进行同步处理。 Stack继承自Vector，是一个后进后出的栈，而Vector是一个列表。 随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap、CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。\nArrayList可以添加null值吗 ArrayList可以存储任何类型的对象，包括null值。不过，不建议向ArrayList中添加null值，null值毫无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\nArrayList插入和删除元素的时间复杂度 对于插入\n头部插入:对于在头部插入的，要往后移动n个元素，所以时间复杂度为O(n) 尾部插入: 对于在尾部插入的，如果不扩容的话，时间复杂度位O(1)，如果扩容的话，时间复杂度为O(n) 指定位置插入:需要将目标位置之后的所有元素都往后移动一个位置，然后再把新元素放入指定位置，这个元素需要移动平均n/2个元素，因此时间复杂度为O(n) 对于删除:\n头部删除:O(n) 尾部删除:O(1) 指定位置删除:O(n) 总结:这种的话可以直接从数组的角度来分析时间复杂度\nLinkedList插入和删除元素的时间复杂度是多少 头部插入/删除:O(1) 尾部插入/删除:O(1) 指定位置插入/删除:O(n) 总结:这种的话可以根据双向链表来分析时间复杂度。\nLinkedList为啥不能实现RandomAccess接口 RandomAccess(是一个标记接口)就是用来表明实现该接口的类支持随机访问(即索引访问)，而LinkedList底层是链表，内存不一定连续，是不支持随机访问(即索引访问)的，所以不能实现RandomAccess这个接口。\nArrayList与LinkedList区别 是否线程安全，两者都是不安全的，在多线程的情况下都不是安全的。 时间复杂度: ArrayList的底层是动态数组，LinkedList的底层是链表，可以从这个底层来进行分析。 内存占用:有于LinkedList得存下一个节点的地址，所以LinkedList所占的内存偏大。 是否支持随机访问，ArrayList支持随机访问，LinkedList不支持随机访问。 使用场景，ArrayList用于大多数场景。因此建议能用ArrayList就用ArrayList。 ArrayList的扩容机制 当 ArrayList 中的元素数量超过其当前容量时，会触发扩容机制。默认情况下，ArrayList 的初始容量为 10。\n当发生扩容时，ArrayList 会创建一个新的数组，其容量为原数组的 1.5 倍（即 oldCapacity + (oldCapacity \u0026raquo; 1)），然后将原数组中的元素复制到新数组中。\n复制过程是通过 Arrays.copyOf() 方法实现的。\n源码分析(add方法):\n1.首先会进入add方法，在add方法中首先判断(size + 1)是否需要扩容，如果需要则扩容，然后赋值。 2.判断扩容在ensureCapacityInternal这个函数，这个函数内部会调用ensureExplicitCapacity，如果(minCapacity - elementData.length \u0026gt; 0)即容量不够了，则会调用grow方法。 3.grow即是核心方法，grow方法中首先将旧的容量扩容成1.5倍，与minCapacity进行比较，如果小于，则新的容量为minCapacity,然后进行(newCapacity - MAX_ARRAY_SIZE \u0026gt; 0)，然后进行 return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :MAX_ARRAY_SIZE;。 4.最终通过 Arrays.copyOf(elementData, newCapacity); 复制老数组的数据到新数组，完成扩容。 Comparable和Comparator的区别 Comparable接口出自java.lang包，它有一个compareTo(Object obj)方法用来排序。 Comparator接口出自java.util包，它有一个compare(Object obj1, Object obj2)方法用来排序。 无序性和不可重复性的含义是啥 无序性指的数组的元素的添加不是按照数组索引的顺序来进行添加的，而是按照根据数值的哈希值来进行加的。 不可重复性指的是equals()判断时，返回false，必须重写equals()和hashcode()方法。 比较HashSet，LikedHashSet和TreeSet三者的异同 相同点:这三者都只能存储不重复的元素，这三者都是线程不安全的。 不同点:内部数据结构不同，HashSet的底层是基于HashMap实现的，底层的数据结构跟HashMap的一样，数组+链表+红黑树，而LinkedHashSet的底层是LinkedHashMap，底层是数组+链表(双向链表)+红黑树，TreeSet的底层是TreeMap的，底层的数据结构为红黑树(一种自平衡的树)。 应用场景不同，HashSet常常用于不需要保证元素插入和取出顺序的场景，LinkedHashSet用于保证元素的插入和取出顺序满足FIFO的场景，TreeSet用于支持对元素自定义排序规则的场景。 Queue与Deque的区别 Queue的底层是单向队列，支持FIFO，从一端进从一端出。 Deque的底层是双向队列，支持两端添加和删除，这个可以模拟栈。 ArrayDeque与LikedList的区别 ArrayDeque的底层是变长的数组加双指针，LinkedListd的底层是双链表。 ArrayDeque不支持存储NULL数据，但LinkedList支持。 ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。 说一说PriorityQueue PriorityQueue按照某种优先级进行取出和插入。 PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据。 啥是BlockingQueue 就是阻塞队列，符合生产者-消费者模式，当队列没有时进入阻塞状态，当队列已经满时，一直等到队列可以放入新元素时再放入 BlockingQueue的实现类有哪些 ArrayBlockingQueue和LinkedBlockingQueue。 ArrayBlockingQueue和LinkedBlockingQueue有啥区别？ 底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。 是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。 ","date":"2024-11-26T23:34:44+08:00","image":"https://getshhi.github.io/jk2.png","permalink":"https://getshhi.github.io/p/java%E9%9B%86%E5%90%881/","title":"Java集合(1)"},{"content":"Java异常类层次结构图\nException和Error有啥区别\nChecked Exception和Unchecked Exception有啥区别\nThrowable类常用方法有哪些\ntry-catch-finally如何使用\n咋用try-with-resources代替try-catch-finally\n异常使用有哪些需要注意的地方\n啥是泛型？有啥作用\n泛型的使用方式有哪几种\n何为反射\n反射的优缺点\n反射的应用场景\n啥是注解\n注解的解析方法有哪几种\n啥是SPI\nSPI和API有啥区别\nSPI的优缺点\n啥是序列化？啥是反序列化?\n如果有些字段不想进行序列化咋办\n常见的序列化协议有哪些\n为啥不推荐使用JDK自带的序列化\nJava异常类层次结构图 Exception和Error有啥区别 Exception:程序本身可以处理的异常，可以通过catch来进行捕获。 Error:Error属于程序无法处理的错误，如果出现异常线程就直接结束。 Checked Exception和Unchecked Exception有啥区别 Checked Exception就是编译异常(常见的有SQL异常，超时异常，找不到方法异常) Unchecked Exception就是运行异常(常见的有算术异常，数组下标越界异常，空指针异常) Throwable类常用方法有哪些 String getMessage():返回异常发生时的详细信息。 String toString():返回异常发生的简要描述。 String getLocalizedMessage():返回异常对象的本地化信息。 void printStackTrace():在控制台上打印Trowable对象封装的异常信息。 try-catch-finally如何使用 将可能出现异常的放在try代码块中，对异常的处理放在 catch代码块中，finally放最后肯定执行的(除了cpu关闭，所在线程提前死亡或者JVM提前死亡)。\n咋用try-with-resources代替try-catch-finally 适用范围（资源的定义）： 任何实现 java.lang.Closeable或者 java.io.Closeable 的对象 关闭资源和 finally 块的执行顺序：在 -try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。 异常使用有哪些需要注意的地方 1.尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常。 2.只在需要try-catch的地方try-catch，try-catch的范围能小则小 3.不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。 4.不要延迟处理异常 啥是泛型？有啥作用 Java泛型是JDK5中引入的一个新特性 作用很直接，就是能把运行时异常转为编译时异常\n泛型的使用方式有哪几种 泛型一般有三种使用方式\n泛型类 泛型接口 泛型方法 何为反射 Java的反射机制就是指在运行获取类的结构信息(如方法，字段，构造函数)并操作对象的一种机制。\n反射的优缺点 优点\n反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。 缺点\n不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。 另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。 相关阅读Java Reflection: Why is it so slow?\n反射的应用场景 主要运用在框架的开发和动态代理的实现\n啥是注解 1.注解其实就是一个标记，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。 2.有了标记之后，就可以在解析的时候获取标记，然后做特别处理。 3.注解的使用可以通过编译时、类加载时或者运行时的反射机制来实现特殊的处理逻辑。 注解的解析方法有哪几种 编译期直接扫描: 比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n运行期通过反射通过反射处理: 像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。\n啥是SPI SPI就是我调用你实现的接口(其他的不用管)，简单来说就是用就完了。\nSPI和API有啥区别 调用方直接调用实现方接口实现服务就是API\n实现方实现实现方提供的接口从而提供服务就是SPI\nSPI的优缺点 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。 当多个 ServiceLoader 同时 load 时，会有并发问题。 啥是序列化？啥是反序列化? 序列化就是将对象转化为能在网络中传输的，通常是二进制字节流，也可以是JSON，XML等文本格式。 反序列化就是将在网络中传输的转化为对象的过程。 如果有些字段不想进行序列化咋办 可以用transient关键字修饰\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化； 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 常见的序列化协议有哪些 JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。 像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。 为啥不推荐使用JDK自带的序列化 不能兼容其他的语言 性能差 存在安全问题 Java IO流了解吗 Java IO流简单来说就是输入和输出，输入到计算机内存中进行处理，而输出就是输出到外部存储器进行存储(比如磁盘等之类的外部存储器) Java IO流主要有四个抽象类，分别是InputStream/Reader:所有的输入流的基类，前者是字节输入流，后者是字符输入流， OutputStream/Writer:所有输出流的基类，前者是字节输出流，后者是字符输出流。 I/O流为啥要分为字节流和字符流呢 部分场景需要对字符进行操作，用字符流更加高效 如果我们不知道编码类型的话使用字节流的过程中很容易出现乱码问题。 啥是语法糖 编程语言为了方便程序员开发程序而设计的一种特殊语法。\nJava有哪些常见的语法糖 lambda表达式，泛型，自动拆装箱，内部类，增强for循环等等。\n","date":"2024-11-25T19:25:16+08:00","image":"https://getshhi.github.io/jk3.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%803/","title":"Java基础(3)"},{"content":"面向对象和面向过程的区别\n创建一个对象用啥运算符？对象实体与对象引用有何不同\n对象的相等和引用相等的区别\n如果一个类没有声明构造方法，该程序能正确执行吗\n构造方法有啥特点？是否可被override\n面向对象三大特怔\n接口和抽象类有啥共同点和区别\n深度拷贝和浅拷贝了解吗？啥是引用拷贝？\nObject类的常见方法有哪些\n== 和 equals()的区别\nhashCode()有啥用\n为啥要有hashCode\n为啥重写equals()时必须重写hashCode()方法\nString， StringBuffer， StringBuilder的区别\nString为啥是不可变的\n字符串拼接用 \u0026ldquo;+\u0026rdquo; 还是StringBuilder\nString#equals()和Object#equals()有啥区别\n字符串的常量池了解过吗\n创建String对象的两种方式以及不同\nString s1 = new String(\u0026ldquo;abc\u0026rdquo;)创建了几个对象\nString#intern方法有啥作用\nString 类型的变量和常量做“+”运算时发生了什么\n面向对象和面向过程的区别 面向对象会先抽象出对象，然后用对象执行方法的方式来解决问题 面向过程会把解决问题的过程拆成一个个方法，通过一个个方法来执行解决问题\n面向过程具有良好的性能，但扩展性较差，面向对象具有较好的扩展性，但性能较差。\n创建一个对象用啥运算符？对象实体与对象引用有何不同 创建一个对象用new运算符\n对象实体与对象引用的区别\n对象实体存储在堆中。 对象实体指向对象实体。 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）。 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 对象的相等和引用相等的区别 对象相等是指内存中的内容是否相等\n引用相等时指指针内存地址是否相等\n如果一个类没有声明构造方法，该程序能正确执行吗 可以的\n系统会生成一个默认的无参构造器 当我们如果实现有参构造器，最好手动加一个无参构造器，这个可以帮助我们少踩坑。\n构造方法有啥特点？是否可被override 名字与类名相同。 没有返回值。 自动执行，在生成类的对象时，构造方法会自动执行，无需显式调用。 构造方法不能被重写，只能被重载。 面向对象三大特怔 封装\n简单来说就是将一个对象的属性封装在一起，对外仅仅暴露方法调用。(比如你用空调遥控器时，空调遥控器内部的细节不知道，但你可以通过它提供的按钮来使用) 继承\n子类拥有父类的属性和方法(私有方法和私有属性有但不能继承)。提高代码的复用性，程序的可维护性。 多态\n一个对象可以有多种状态，即父类引用指向子类的多种实例。 接口和抽象类有啥共同点和区别 接口和抽象类的共同点\n实例化: 接口和抽象类都不能直接实例化，只能被实现(接口)或继承(抽象类)后才能创建具体的对象 抽象方法: 接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。 接口和抽象类的区别 接口和抽象类在设计动机上有所不同。\n接口的设计是自上而下的。我们知晓某一行为，于是基于这些行为约束定义了接口，一些类需要有这些行为，因此实现对应的接口。\n抽象类的设计是自下而上的。我们写了很多类，发现它们之间有共性，有很多代码可以复用，因此将公共逻辑封装成一个抽象类，减少代码冗余。\n简单来说就是接口是先规范然后去实现，抽象是先实现然后再抽象出来一个类。\n深度拷贝和浅拷贝了解吗？啥是引用拷贝？ 浅拷贝：浅拷贝后的对象和原对象共享引用对象的实例。\n深拷贝：会重现创建一个实例，使得深拷贝后的对象与原对象完全独立。修改一个对象不会影响另一个对象。\n引用拷贝就是两个不同的引用指向同一个对象 Object类的常见方法有哪些 == 和 equals()的区别 == 对于基本数据类型就是比较值，而对于引用类型就是比较对象的内存地址 equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。 hashCode()有啥用 hashCode用于返回对象的哈希码，确定该对象在哈希表中的索引位置。\n为啥要有hashCode 大大提高索引速度，从而提高执行速度。\n为啥重写equals()时必须重写hashCode()方法 因为根据业务来说我们想的时equals()判断的相等就一定相等，而不重写的hashCode返回的是对象的哈希码，这与我们最初的想法相违背，所以必须重写hashCode()。\nString， StringBuffer， StringBuilder的区别 可变性: String不可变，StringBuilder可变，StringBuffer可变。 线程安全性: String中的对象是不可变的，可以理解为常量，线程安全。StringBuffer安全，加了同步锁。StringBuilder并没有对方法进行加同步锁，所以不安全。 性能： String性能最低，因为每次改变时生成的是一个新的String对象。StringBuffer，StringBuilder性能较高。 总结:\n操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer String为啥是不可变的 1.String的类是用final修饰的，不可以被其他类继承，因此方法不能被重写，里面的数据都不能被改变。\n2.String的char数组是私有的而且用final修饰，因此不能改变其字符数组的引用变量，因此改变不了String。\n字符串拼接用 \u0026ldquo;+\u0026rdquo; 还是StringBuilder 字符串拼接用StringBuffer，因为用\u0026quot;+\u0026ldquo;拼接的话底层会创建一个新的StringBuilder对象(对于大多数场景比如说循环)比较耗时间，效率比较低。\nString#equals()和Object#equals()有啥区别 String的equals()会比较字符串是否相等而Object的equals会比较内存的地址是否相等。\n字符串的常量池了解过吗 字符串的常量池是JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的一块区域，主要是为了避免字符串的重复创建。 创建String对象的两种方式以及不同 String s1 = new String(\u0026ldquo;abc\u0026rdquo;)创建了几个对象 这得分情况讨论\n1.如果是常量池中已经存在\u0026quot;abc\u0026quot;则创建一个对象。(即s1直接指向常量池中的\u0026quot;abc\u0026rdquo;) 2.如果是常量池中不存在\u0026quot;abc\u0026quot;则创建二个对象。(即首先在常量池中创建\u0026quot;abc\u0026quot;，然后s1指向常量池中的\u0026quot;abc\u0026quot;) String#intern方法有啥作用 intern方法是一个本地方法，目的返回字符串在常量池中的引用\nString 类型的变量和常量做“+”运算时发生了什么 对于编译期可以确定值的字符串，也就是常量字符串 ， jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池， 这个得益于编译器的优化。 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。(可以加final进行优化) ","date":"2024-11-23T19:48:17+08:00","image":"https://getshhi.github.io/jk4.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%802/","title":"Java基础(2)"},{"content":"java语言有啥特点？\nJavaSE是啥？JavaEE是啥？\nJVM是啥？JDK是啥？JRE是啥？\nAOT有啥优点？为啥不全用AOT呢？\n啥是字节码？采用字节码的好处是啥？\n为啥说Java语言 \u0026ldquo;编译与解释共存\u0026rdquo;?\nOracleJDK 和 OpenJDK 有啥区别？\nJava与C++的区别？\nJava注释有几种？\n标识符 和 关键字 的区别是啥？\n自增，自减符号\n移位运算符\nJava的几种基本数据类型\n基本类型和包装类型的区别？\n包装类型的缓存机制了解吗？\n自动装箱与拆箱了解吗？ 原理是啥？\n为啥浮点数运算的时候会有精度丢失的风险？\n如何解决浮点数运算的精度丢失问题\n超过long整形的数据应该如何表示\n成员变量与局部变量的区别\n静态变量有啥用？\n字符型常量和字符串常量的区别\n啥是方法的返回值？方法有哪几种类型？\n静态方法为啥不能调用非静态方法\n静态方法和实例方法有啥不同？\n重载和重写有啥区别？\n啥是可变长参数？\njava语言有啥特点？ 1.面向对象，java语言是面向对象的(封装，继承，多态)\n2.具有丰富的生态和类库。\n3.具有跨平台特点，一次编译，随处运行。\n4.简单易学。\n5.支持网络编程。\n6.本身提供多线程处理的解决办法。\n7.编译和解释并存。\nJavaSE是啥？JavaEE是啥？ JavaSE-Java平台的平台标准版，用于构建桌面应用程序或简单的服务器应用程序。\nJavaEE-Java平台的企业标准版，用于构建分布式，健壮的服务端Java应用程序。\nJVM是啥？JDK是啥？JRE是啥？ JDK = JRE + 开发工具(JDK是Java完整的工具包)\nJRE = JVM + 核心类库(JRE是可以直接运行.class文件的运行环境，JVM就是虚拟机)\nAOT有啥优点？为啥不全用AOT呢？ AOT模式与JIT模式比较\nAOT就是静态编译，优点是启动时间少，内存占用少，打包体积小。\nJIT是即时编译，优点是有高的处理延迟能力，可以降低请求的最大延迟。\nAOT不支持Java的反射，动态代理，动态加载，而很多框架都是用这个特性，AOT更适合当下的云原生场景，对微服务架构的支持更友好。\n啥是字节码？采用字节码的好处是啥？ 字节码就是JVM可以直接识别的代码(即扩展名为.class文件的文件)，由于可直接在JVM上运行，所以可以无需编译直接在不同平台上运行(即跨平台性)。 为啥说Java语言 \u0026ldquo;编译与解释共存\u0026rdquo;? 编译是因为Java先经过编译阶段，即将Java代码编译成.class文件。\n解释是因为Java运行时是Java解释器一行一行解释并执行代码的。\n所以编译与解释共存。\nOracleJDK 和 OpenJDK 有啥区别？ 简单来说就是前期这两个没有啥大的区别，后面OracleJDK为了恰钱产生这两个，前者是要付钱的，后者是开源版本。 Java与C++的区别 Java内存更安全，Java不支持单指针直接操作内存。\nJava是编译与解释共存，而C++是编译性语言。\nJava支持单继承，C++支持多继承。\nC ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载。\nJava 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\nJava注释有几种 三种\n单行注释 -用于注释单行代码的作用\n多行注释 -用于注释多行代码的作用\n文档注释 -用于生成 Java 开发文档\n标识符 和 关键字 的区别是啥？ 标识符就是一个名字\n关键字是被赋予特殊含义的标识符\n自增，自减符号 ++a，- -a (前缀形式，计算时先减1或加1，再用a的变量)\na++， a- - (后缀形式，计算时用a的值，再将a的值减1或加1)\n移位运算符 三种运算符\n\u0026lt;\u0026lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x \u0026lt;\u0026lt; n，相当于 x 乘以 2 的 n 次方(不溢出的情况下)。 \u0026gt;\u0026gt; :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0，负数高位补 1。x \u0026gt;\u0026gt; n，相当于 x 除以 2 的 n 次方。 \u0026gt;\u0026gt;\u0026gt; :无符号右移，忽略符号位，空位都以 0 补齐。 Java的几种基本数据类型 四种八类\n布尔型 boolean占一个字节 false或者true\n字符型 char占两个字节\n数值型 byte占一个字节 short占两个字节 int 占4个字节 long(后面加L)占8个字节\n浮点型 float(后面加f或者F)占4个字节 double占8个字节\n基本类型和包装类型的区别 存储方式 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。 包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。 用途 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。 占用空间 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。 包装类型的默认值为null， 基本类型的默认值不是null == 可以比较基本类型的值，而包装类型的值得用equals比较 包装类型的缓存机制了解吗？ Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。\nInteger，Byte，Long，Short默认创建了数值[-128， 127]的相应类型的缓存数据 Character创建了[0，127]范围的缓存数据， Boolean直接返回True or False 自动装箱与拆箱了解吗？ 原理是啥？ 装箱就是将基本数据类型转变为包装类型\n拆箱就是将包装类型转变为基本数据类型\n如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作\n为啥浮点数运算的时候会有精度丢失的风险？ 二进制表示的限制：十进制系统中的某些小数（如0.1、0.2等）在二进制系统中只能通过无限循环小数来近似表示。 舍入误差：由于计算机只能存储有限的位数，因此在进行浮点数运算时，不可避免地会产生舍入误差。 浮点数存储结构：浮点数在计算机中的存储遵循IEEE 754标准，该标准将浮点数拆分为符号位、指数位和尾数位 如何解决浮点数运算的精度丢失问题 BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 超过long整形的数据应该如何表示？ 可以用BigInteger处理\nBigInteger内部用int[]数组来存储任意大小的整形数据 相对于常规整数类型的运算来说，BigInteger运算的效率会相对较低 成员变量与局部变量的区别 语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public，private，static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。 静态变量有啥用？ 静态变量可以节省内存\n静态变量随着类的加载而创建，所以它可以被类的所有实例共享，所以可以节省内存 字符型常量和字符串常量的区别 形式: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符 含义: 字符常量相当于一个整形值(ASCII值)，可以参加表达式运算;字符串常量代表一个地址值(该字符串在内存中存放位置)。 占内存大小： 字符常量只占2个字节;字符串常量占若干个字节。\n啥是方法的返回值？方法有哪几种类型？ 返回值就是方法体返回的数值。 方法有4种 无参数，无返回的 有参数，无返回的 无参数，有返回的 有参数，有返回的 静态方法为啥不能调用非静态方法？ 静态方法随着类的加载而加载，而非静态方法只有类被实例化时才能加载，所以可以得到静态方法存在时而非静态方法不存在的情况，由此得到静态方法不能调用非静态方法。\n静态方法和实例方法有啥不同？ 调用方式不同， 调用静态方法可以无需创建对象，用类名.方法名的方式来调用静态方法。 访问类成员是否存在限制， 静态方法在访问本类的成员时，仅仅让访问静态成员，而实例方法不存在这个限制。 重载和重写有啥区别？ 重载就是在同样的一个方法能够根据输入数据的不同，做出不同的处理。 重写就是子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应，你就要覆盖父类的方法\n区别点 重载方法 重写方法 发生范围 本类中 子类中 参数列表 必须修改 不能修改 返回类型 可修改 子类的返回类型与父类返回的类型相同或者时父类返回类型的子类 异常 可修改 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 啥是可变长参数？ 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。\n","date":"2024-11-22T11:05:52+08:00","image":"https://getshhi.github.io/jk5.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%801/","title":"Java基础(1)"},{"content":"下面是我弄的思维导图 大致图片 json 这个可以在菜鸟工具上看到 在线思维导图(创建json文件,然后再复制下面的,在该网站导入json文件即可)\n1 {\u0026#34;root\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jmvl5bc00\u0026#34;,\u0026#34;created\u0026#34;:1729824575835,\u0026#34;text\u0026#34;:\u0026#34;计算机网络\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jz9mhdzc0\u0026#34;,\u0026#34;created\u0026#34;:1729825546760,\u0026#34;text\u0026#34;:\u0026#34;计算机网络概论\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k4ihvpgg0\u0026#34;,\u0026#34;created\u0026#34;:1729825957894,\u0026#34;text\u0026#34;:\u0026#34;计算机网络概述\u0026#34;,\u0026#34;layout_filetree-down_offset\u0026#34;:{\u0026#34;x\u0026#34;:-60.99999818205839,\u0026#34;y\u0026#34;:49.99999850988394},\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k5vgz9yo0\u0026#34;,\u0026#34;created\u0026#34;:1729826064502,\u0026#34;text\u0026#34;:\u0026#34;计算机网络是一个功能完善的软件实现资源共享和信息传递的系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k5z8z79c0\u0026#34;,\u0026#34;created\u0026#34;:1729826072725,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的组成\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k91ea69c0\u0026#34;,\u0026#34;created\u0026#34;:1729826312492,\u0026#34;text\u0026#34;:\u0026#34;从组成部分看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kah8m64o0\u0026#34;,\u0026#34;created\u0026#34;:1729826425343,\u0026#34;text\u0026#34;:\u0026#34;硬件，软件，协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k924cofk0\u0026#34;,\u0026#34;created\u0026#34;:1729826314068,\u0026#34;text\u0026#34;:\u0026#34;从工作方式看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kav8xrhk0\u0026#34;,\u0026#34;created\u0026#34;:1729826455836,\u0026#34;text\u0026#34;:\u0026#34;边缘部分和核心部分\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k9qnqss80\u0026#34;,\u0026#34;created\u0026#34;:1729826367484,\u0026#34;text\u0026#34;:\u0026#34;从功能组成看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kaw2yz340\u0026#34;,\u0026#34;created\u0026#34;:1729826457652,\u0026#34;text\u0026#34;:\u0026#34;通信子网和资源子网\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcd31www0\u0026#34;,\u0026#34;created\u0026#34;:1729826573027,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcno842w0\u0026#34;,\u0026#34;created\u0026#34;:1729826596075,\u0026#34;text\u0026#34;:\u0026#34;数据通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcr3o3mo0\u0026#34;,\u0026#34;created\u0026#34;:1729826603539,\u0026#34;text\u0026#34;:\u0026#34;资源共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcs6lcts0\u0026#34;,\u0026#34;created\u0026#34;:1729826605893,\u0026#34;text\u0026#34;:\u0026#34;分布式处理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kctcd8i80\u0026#34;,\u0026#34;created\u0026#34;:1729826608419,\u0026#34;text\u0026#34;:\u0026#34;提高可靠性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcu9h7340\u0026#34;,\u0026#34;created\u0026#34;:1729826610421,\u0026#34;text\u0026#34;:\u0026#34;负载均衡\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kee93af40\u0026#34;,\u0026#34;created\u0026#34;:1729826732297,\u0026#34;text\u0026#34;:\u0026#34;电路交换，报文交换，分组交换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kg3tx1ns0\u0026#34;,\u0026#34;created\u0026#34;:1729826866340,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgczz9lc0\u0026#34;,\u0026#34;created\u0026#34;:1729826886298,\u0026#34;text\u0026#34;:\u0026#34;按分布范围分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj5uurp40\u0026#34;,\u0026#34;created\u0026#34;:1729827105843,\u0026#34;text\u0026#34;:\u0026#34;广域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj6ztzq00\u0026#34;,\u0026#34;created\u0026#34;:1729827108321,\u0026#34;text\u0026#34;:\u0026#34;城域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj82vbz40\u0026#34;,\u0026#34;created\u0026#34;:1729827110681,\u0026#34;text\u0026#34;:\u0026#34;局域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj9evejk0\u0026#34;,\u0026#34;created\u0026#34;:1729827113584,\u0026#34;text\u0026#34;:\u0026#34;个人区域网\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgdzlk940\u0026#34;,\u0026#34;created\u0026#34;:1729826888451,\u0026#34;text\u0026#34;:\u0026#34;按传输技术分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kk2a5u5k0\u0026#34;,\u0026#34;created\u0026#34;:1729827176425,\u0026#34;text\u0026#34;:\u0026#34;广播式网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kk36tiw80\u0026#34;,\u0026#34;created\u0026#34;:1729827178400,\u0026#34;text\u0026#34;:\u0026#34;点对点网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgj77s1s0\u0026#34;,\u0026#34;created\u0026#34;:1729826899796,\u0026#34;text\u0026#34;:\u0026#34;按拓扑结构分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kks5bmag0\u0026#34;,\u0026#34;created\u0026#34;:1729827232729,\u0026#34;text\u0026#34;:\u0026#34;总线形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kktf3fvk0\u0026#34;,\u0026#34;created\u0026#34;:1729827235497,\u0026#34;text\u0026#34;:\u0026#34;星形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kkv1l1e80\u0026#34;,\u0026#34;created\u0026#34;:1729827239033,\u0026#34;text\u0026#34;:\u0026#34;环形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kkwqg0yg0\u0026#34;,\u0026#34;created\u0026#34;:1729827242713,\u0026#34;text\u0026#34;:\u0026#34;网状网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kh7m33kw0\u0026#34;,\u0026#34;created\u0026#34;:1729826952938,\u0026#34;text\u0026#34;:\u0026#34;按使用者分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54klqe076o0\u0026#34;,\u0026#34;created\u0026#34;:1729827307265,\u0026#34;text\u0026#34;:\u0026#34;公用网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54klu78ks00\u0026#34;,\u0026#34;created\u0026#34;:1729827315563,\u0026#34;text\u0026#34;:\u0026#34;专用网\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kh8nl4fs0\u0026#34;,\u0026#34;created\u0026#34;:1729826955205,\u0026#34;text\u0026#34;:\u0026#34;按传输介质分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54km5x9ck00\u0026#34;,\u0026#34;created\u0026#34;:1729827341081,\u0026#34;text\u0026#34;:\u0026#34;有线\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54km6zckm00\u0026#34;,\u0026#34;created\u0026#34;:1729827343384,\u0026#34;text\u0026#34;:\u0026#34;无线\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54korvds7k0\u0026#34;,\u0026#34;created\u0026#34;:1729827545585,\u0026#34;text\u0026#34;:\u0026#34;计算机性能指标\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kozzmbc80\u0026#34;,\u0026#34;created\u0026#34;:1729827563255,\u0026#34;text\u0026#34;:\u0026#34;速率，带宽等等\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k4trsc6w0\u0026#34;,\u0026#34;created\u0026#34;:1729825982438,\u0026#34;text\u0026#34;:\u0026#34;计算机网络体系结构与参考模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kshbr58g0\u0026#34;,\u0026#34;created\u0026#34;:1729827836087,\u0026#34;text\u0026#34;:\u0026#34;体系结构是抽象的，而实现则是具体的\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ksimksbk0\u0026#34;,\u0026#34;created\u0026#34;:1729827838918,\u0026#34;text\u0026#34;:\u0026#34;计算机网络协议，接口，服务的概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kums6vy00\u0026#34;,\u0026#34;created\u0026#34;:1729828004693,\u0026#34;text\u0026#34;:\u0026#34;协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kwwrjasw0\u0026#34;,\u0026#34;created\u0026#34;:1729828183149,\u0026#34;text\u0026#34;:\u0026#34;语法\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxkaa5uw0\u0026#34;,\u0026#34;created\u0026#34;:1729828234349,\u0026#34;text\u0026#34;:\u0026#34;数据与控制信息的格式\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kwxuls7c0\u0026#34;,\u0026#34;created\u0026#34;:1729828185512,\u0026#34;text\u0026#34;:\u0026#34;语义\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxlc52sw0\u0026#34;,\u0026#34;created\u0026#34;:1729828236638,\u0026#34;text\u0026#34;:\u0026#34;需要发出何种控制信息，完成何种动作及做出何种应答\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:17.999999463558197,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kx2cieao0\u0026#34;,\u0026#34;created\u0026#34;:1729828195302,\u0026#34;text\u0026#34;:\u0026#34;同步\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:7.999999761581421,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxmzscps0\u0026#34;,\u0026#34;created\u0026#34;:1729828240245,\u0026#34;text\u0026#34;:\u0026#34;执行各种操作的条件和时序关系\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kunkmxmg0\u0026#34;,\u0026#34;created\u0026#34;:1729828006413,\u0026#34;text\u0026#34;:\u0026#34;同一接口内相邻两层的实体交换信息的逻辑接口为服务访问点\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kuos5yu00\u0026#34;,\u0026#34;created\u0026#34;:1729828009045,\u0026#34;text\u0026#34;:\u0026#34;服务是指下层为紧邻的上层提供的功能调用\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l1zetp5s0\u0026#34;,\u0026#34;created\u0026#34;:1729828580732,\u0026#34;text\u0026#34;:\u0026#34;模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l24w3nbk0\u0026#34;,\u0026#34;created\u0026#34;:1729828592661,\u0026#34;text\u0026#34;:\u0026#34;学术上的模型\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2l2e0xs0\u0026#34;,\u0026#34;created\u0026#34;:1729828627869,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2oblctc0\u0026#34;,\u0026#34;created\u0026#34;:1729828634956,\u0026#34;text\u0026#34;:\u0026#34;表示层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2p92lhc0\u0026#34;,\u0026#34;created\u0026#34;:1729828636980,\u0026#34;text\u0026#34;:\u0026#34;会话层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2qfsz540\u0026#34;,\u0026#34;created\u0026#34;:1729828639564,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2slci7c0\u0026#34;,\u0026#34;created\u0026#34;:1729828644253,\u0026#34;text\u0026#34;:\u0026#34;网络层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2tsgnhs0\u0026#34;,\u0026#34;created\u0026#34;:1729828646860,\u0026#34;text\u0026#34;:\u0026#34;数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2x0rzy80\u0026#34;,\u0026#34;created\u0026#34;:1729828653893,\u0026#34;text\u0026#34;:\u0026#34;物理层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l25x4oko0\u0026#34;,\u0026#34;created\u0026#34;:1729828594900,\u0026#34;text\u0026#34;:\u0026#34;实际的模型\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2m6g9wg0\u0026#34;,\u0026#34;created\u0026#34;:1729828630292,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l433nutk0\u0026#34;,\u0026#34;created\u0026#34;:1729828745492,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l4458dx40\u0026#34;,\u0026#34;created\u0026#34;:1729828747764,\u0026#34;text\u0026#34;:\u0026#34;网际层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l458wi2o0\u0026#34;,\u0026#34;created\u0026#34;:1729828750163,\u0026#34;text\u0026#34;:\u0026#34;网络接口层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzardkig0\u0026#34;,\u0026#34;created\u0026#34;:1729825549233,\u0026#34;text\u0026#34;:\u0026#34;物理层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9gvwxyg0\u0026#34;,\u0026#34;created\u0026#34;:1729829167320,\u0026#34;text\u0026#34;:\u0026#34;通信基础\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lcg8jwqg0\u0026#34;,\u0026#34;created\u0026#34;:1729829401000,\u0026#34;text\u0026#34;:\u0026#34;奈式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lcis0d9s0\u0026#34;,\u0026#34;created\u0026#34;:1729829406530,\u0026#34;text\u0026#34;:\u0026#34;香农定理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lm5sv2k00\u0026#34;,\u0026#34;created\u0026#34;:1729830161925,\u0026#34;text\u0026#34;:\u0026#34;不归0编码，归0编码，反向非归零编码，曼彻斯特编码，差分曼彻斯特编码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9pbu59c0\u0026#34;,\u0026#34;created\u0026#34;:1729829185697,\u0026#34;text\u0026#34;:\u0026#34;传输介质\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ltgugi680\u0026#34;,\u0026#34;created\u0026#34;:1729830734515,\u0026#34;text\u0026#34;:\u0026#34;双绞线，同轴电缆，光纤\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ltiy4tuo0\u0026#34;,\u0026#34;created\u0026#34;:1729830739091,\u0026#34;text\u0026#34;:\u0026#34;物理层接口的特性\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwfjiw600\u0026#34;,\u0026#34;created\u0026#34;:1729830966770,\u0026#34;text\u0026#34;:\u0026#34;机械特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lxa6145s0\u0026#34;,\u0026#34;created\u0026#34;:1729831033434,\u0026#34;text\u0026#34;:\u0026#34;指名所用接线器的形状和尺寸\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwgipyiw0\u0026#34;,\u0026#34;created\u0026#34;:1729830968898,\u0026#34;text\u0026#34;:\u0026#34;电气特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lxuj57c80\u0026#34;,\u0026#34;created\u0026#34;:1729831077763,\u0026#34;text\u0026#34;:\u0026#34;电压范围\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwhips2o0\u0026#34;,\u0026#34;created\u0026#34;:1729830971074,\u0026#34;text\u0026#34;:\u0026#34;功能特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ly1ua9r40\u0026#34;,\u0026#34;created\u0026#34;:1729831093674,\u0026#34;text\u0026#34;:\u0026#34;指名功能\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwka2jl40\u0026#34;,\u0026#34;created\u0026#34;:1729830977082,\u0026#34;text\u0026#34;:\u0026#34;过程特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ly9v8g8w0\u0026#34;,\u0026#34;created\u0026#34;:1729831111145,\u0026#34;text\u0026#34;:\u0026#34;指明各种可能事件的出现词序\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9r9ajyo0\u0026#34;,\u0026#34;created\u0026#34;:1729829189897,\u0026#34;text\u0026#34;:\u0026#34;物理层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lzycu8vk0\u0026#34;,\u0026#34;created\u0026#34;:1729831242817,\u0026#34;text\u0026#34;:\u0026#34;中继器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m0g5h17k0\u0026#34;,\u0026#34;created\u0026#34;:1729831281553,\u0026#34;text\u0026#34;:\u0026#34;信号再生\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lzza7mj40\u0026#34;,\u0026#34;created\u0026#34;:1729831244835,\u0026#34;text\u0026#34;:\u0026#34;集线器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m0h6jitk0\u0026#34;,\u0026#34;created\u0026#34;:1729831283795,\u0026#34;text\u0026#34;:\u0026#34;中继器的集合\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:7.999999761581421,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzeebe5k0\u0026#34;,\u0026#34;created\u0026#34;:1729825557151,\u0026#34;text\u0026#34;:\u0026#34; 数据链路层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m190l6v40\u0026#34;,\u0026#34;created\u0026#34;:1729831344385,\u0026#34;text\u0026#34;:\u0026#34;数据链路层的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6ec6vug0\u0026#34;,\u0026#34;created\u0026#34;:1729831747791,\u0026#34;text\u0026#34;:\u0026#34;为网络层提供服务\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6f94r7c0\u0026#34;,\u0026#34;created\u0026#34;:1729831749783,\u0026#34;text\u0026#34;:\u0026#34;链路管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6wcvvvs0\u0026#34;,\u0026#34;created\u0026#34;:1729831787015,\u0026#34;text\u0026#34;:\u0026#34;封装成帧与透明传输\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6xjmh7s0\u0026#34;,\u0026#34;created\u0026#34;:1729831789599,\u0026#34;text\u0026#34;:\u0026#34;流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mc33f1yg0\u0026#34;,\u0026#34;created\u0026#34;:1729832193501,\u0026#34;text\u0026#34;:\u0026#34;差错检测\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m1a1i88w0\u0026#34;,\u0026#34;created\u0026#34;:1729831346617,\u0026#34;text\u0026#34;:\u0026#34;组帧\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdh435zc0\u0026#34;,\u0026#34;created\u0026#34;:1729832302381,\u0026#34;text\u0026#34;:\u0026#34;字符计数法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdi8povk0\u0026#34;,\u0026#34;created\u0026#34;:1729832304837,\u0026#34;text\u0026#34;:\u0026#34;字节填充法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdjivt1k0\u0026#34;,\u0026#34;created\u0026#34;:1729832307629,\u0026#34;text\u0026#34;:\u0026#34;零比特填充法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdkqa79c0\u0026#34;,\u0026#34;created\u0026#34;:1729832310253,\u0026#34;text\u0026#34;:\u0026#34;违规编码法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m1b18ipk0\u0026#34;,\u0026#34;created\u0026#34;:1729831348777,\u0026#34;text\u0026#34;:\u0026#34;差错控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mm8cy0hk0\u0026#34;,\u0026#34;created\u0026#34;:1729832988603,\u0026#34;text\u0026#34;:\u0026#34;奇偶检验码\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mm9h0rlc0\u0026#34;,\u0026#34;created\u0026#34;:1729832991026,\u0026#34;text\u0026#34;:\u0026#34;循环冗余码\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mofn051c0\u0026#34;,\u0026#34;created\u0026#34;:1729833161177,\u0026#34;text\u0026#34;:\u0026#34;纠错编码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m2r0swk80\u0026#34;,\u0026#34;created\u0026#34;:1729831461944,\u0026#34;text\u0026#34;:\u0026#34;流量控制与可靠传输机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mpn3xi0o0\u0026#34;,\u0026#34;created\u0026#34;:1729833255802,\u0026#34;text\u0026#34;:\u0026#34;流量控制与滑动窗口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mrszhttc0\u0026#34;,\u0026#34;created\u0026#34;:1729833425323,\u0026#34;text\u0026#34;:\u0026#34;停止-等待流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mru0y8200\u0026#34;,\u0026#34;created\u0026#34;:1729833427587,\u0026#34;text\u0026#34;:\u0026#34;滑动窗口流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mpo89oio0\u0026#34;,\u0026#34;created\u0026#34;:1729833258241,\u0026#34;text\u0026#34;:\u0026#34;可靠传输机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mtixgbew0\u0026#34;,\u0026#34;created\u0026#34;:1729833560160,\u0026#34;text\u0026#34;:\u0026#34;ARQ\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mu8b5l600\u0026#34;,\u0026#34;created\u0026#34;:1729833615408,\u0026#34;text\u0026#34;:\u0026#34;停止-等待协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mu9c2q2g0\u0026#34;,\u0026#34;created\u0026#34;:1729833617640,\u0026#34;text\u0026#34;:\u0026#34;后退N帧协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54muai56880\u0026#34;,\u0026#34;created\u0026#34;:1729833620184,\u0026#34;text\u0026#34;:\u0026#34;选择重传协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m332mkg00\u0026#34;,\u0026#34;created\u0026#34;:1729831488176,\u0026#34;text\u0026#34;:\u0026#34;介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n13vr4yo0\u0026#34;,\u0026#34;created\u0026#34;:1729834154318,\u0026#34;text\u0026#34;:\u0026#34;信道划分介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n20zjv2g0\u0026#34;,\u0026#34;created\u0026#34;:1729834226382,\u0026#34;text\u0026#34;:\u0026#34;频分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n226f1gw0\u0026#34;,\u0026#34;created\u0026#34;:1729834228974,\u0026#34;text\u0026#34;:\u0026#34;时分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n239bc1k0\u0026#34;,\u0026#34;created\u0026#34;:1729834231326,\u0026#34;text\u0026#34;:\u0026#34;波分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n248sdq80\u0026#34;,\u0026#34;created\u0026#34;:1729834233471,\u0026#34;text\u0026#34;:\u0026#34;码分复用\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n15hji0g0\u0026#34;,\u0026#34;created\u0026#34;:1729834157813,\u0026#34;text\u0026#34;:\u0026#34;随机访问介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3do245s0\u0026#34;,\u0026#34;created\u0026#34;:1729834332349,\u0026#34;text\u0026#34;:\u0026#34;ALOHA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3f26es00\u0026#34;,\u0026#34;created\u0026#34;:1729834335380,\u0026#34;text\u0026#34;:\u0026#34;时隙ALOHA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3nbhjk00\u0026#34;,\u0026#34;created\u0026#34;:1729834353357,\u0026#34;text\u0026#34;:\u0026#34;CSMA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3r5csco0\u0026#34;,\u0026#34;created\u0026#34;:1729834361693,\u0026#34;text\u0026#34;:\u0026#34;CSMA/CD协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3s3w1q00\u0026#34;,\u0026#34;created\u0026#34;:1729834363781,\u0026#34;text\u0026#34;:\u0026#34;CSMA/CA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n8rzjgzc0\u0026#34;,\u0026#34;created\u0026#34;:1729834755339,\u0026#34;text\u0026#34;:\u0026#34;轮询访问:令牌传递协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3e81nz40\u0026#34;,\u0026#34;created\u0026#34;:1729831512448,\u0026#34;text\u0026#34;:\u0026#34;局域网\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd3bsx1c0\u0026#34;,\u0026#34;created\u0026#34;:1729835093482,\u0026#34;text\u0026#34;:\u0026#34;数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54neoev6a80\u0026#34;,\u0026#34;created\u0026#34;:1729835217744,\u0026#34;text\u0026#34;:\u0026#34;介质访问控制子层\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nepe2jaw0\u0026#34;,\u0026#34;created\u0026#34;:1729835219872,\u0026#34;text\u0026#34;:\u0026#34;逻辑链路控制子层\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd6gsmeo0\u0026#34;,\u0026#34;created\u0026#34;:1729835100314,\u0026#34;text\u0026#34;:\u0026#34;以太网与IEE802.3\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd7ueksw0\u0026#34;,\u0026#34;created\u0026#34;:1729835103314,\u0026#34;text\u0026#34;:\u0026#34;IEEE 802.11无线局域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd8zjka80\u0026#34;,\u0026#34;created\u0026#34;:1729835105801,\u0026#34;text\u0026#34;:\u0026#34;VLAN基本概念与基本原理\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3i0q0sg0\u0026#34;,\u0026#34;created\u0026#34;:1729831520712,\u0026#34;text\u0026#34;:\u0026#34;广域网\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54njg5rm4o0\u0026#34;,\u0026#34;created\u0026#34;:1729835591600,\u0026#34;text\u0026#34;:\u0026#34;PPP协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54njhvy3zc0\u0026#34;,\u0026#34;created\u0026#34;:1729835595360,\u0026#34;text\u0026#34;:\u0026#34;广域网通俗来讲就是覆盖很大的网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3lntx2g0\u0026#34;,\u0026#34;created\u0026#34;:1729831528640,\u0026#34;text\u0026#34;:\u0026#34;数据链路层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nl546dn40\u0026#34;,\u0026#34;created\u0026#34;:1729835724288,\u0026#34;text\u0026#34;:\u0026#34;网桥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nlai9v6w0\u0026#34;,\u0026#34;created\u0026#34;:1729835736024,\u0026#34;text\u0026#34;:\u0026#34;以太网交换器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nmcj851k0\u0026#34;,\u0026#34;created\u0026#34;:1729835818799,\u0026#34;text\u0026#34;:\u0026#34;自学习\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nmdkuc940\u0026#34;,\u0026#34;created\u0026#34;:1729835821074,\u0026#34;text\u0026#34;:\u0026#34;工作在数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzf530i80\u0026#34;,\u0026#34;created\u0026#34;:1729825558769,\u0026#34;text\u0026#34;:\u0026#34;网络层 \u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nno151iw0\u0026#34;,\u0026#34;created\u0026#34;:1729835922191,\u0026#34;text\u0026#34;:\u0026#34;网络层的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54npthgvvc0\u0026#34;,\u0026#34;created\u0026#34;:1729836090791,\u0026#34;text\u0026#34;:\u0026#34;异构网络互联\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nq92yjmw0\u0026#34;,\u0026#34;created\u0026#34;:1729836124742,\u0026#34;text\u0026#34;:\u0026#34;路由与转发\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nqux0dy00\u0026#34;,\u0026#34;created\u0026#34;:1729836172272,\u0026#34;text\u0026#34;:\u0026#34;网络层提供的两种服务\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nr4o4by00\u0026#34;,\u0026#34;created\u0026#34;:1729836193502,\u0026#34;text\u0026#34;:\u0026#34;虚电路\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nr5zr01k0\u0026#34;,\u0026#34;created\u0026#34;:1729836196382,\u0026#34;text\u0026#34;:\u0026#34;数据报\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nrp17a8w0\u0026#34;,\u0026#34;created\u0026#34;:1729836237829,\u0026#34;text\u0026#34;:\u0026#34;SDN\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ns906crs0\u0026#34;,\u0026#34;created\u0026#34;:1729836281302,\u0026#34;text\u0026#34;:\u0026#34;拥塞控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nsczgicg0\u0026#34;,\u0026#34;created\u0026#34;:1729836289966,\u0026#34;text\u0026#34;:\u0026#34;开环控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nse1ew7c0\u0026#34;,\u0026#34;created\u0026#34;:1729836292261,\u0026#34;text\u0026#34;:\u0026#34;闭环控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnr409p40\u0026#34;,\u0026#34;created\u0026#34;:1729835928895,\u0026#34;text\u0026#34;:\u0026#34;IPV4\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntdmsduo0\u0026#34;,\u0026#34;created\u0026#34;:1729836369741,\u0026#34;text\u0026#34;:\u0026#34;ip分组\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nywgvno80\u0026#34;,\u0026#34;created\u0026#34;:1729836802563,\u0026#34;text\u0026#34;:\u0026#34;ip数据报分片\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o09kqilk0\u0026#34;,\u0026#34;created\u0026#34;:1729836909459,\u0026#34;text\u0026#34;:\u0026#34;划分子网与路由聚合\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0t2rank0\u0026#34;,\u0026#34;created\u0026#34;:1729836951907,\u0026#34;text\u0026#34;:\u0026#34;划分子网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0u1y7g00\u0026#34;,\u0026#34;created\u0026#34;:1729836954035,\u0026#34;text\u0026#34;:\u0026#34;子网掩码和默认网关\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0vjt6kw0\u0026#34;,\u0026#34;created\u0026#34;:1729836957292,\u0026#34;text\u0026#34;:\u0026#34;无分类编址CIDR\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o22fxf8g0\u0026#34;,\u0026#34;created\u0026#34;:1729837050659,\u0026#34;text\u0026#34;:\u0026#34;路由聚合\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o2b22d140\u0026#34;,\u0026#34;created\u0026#34;:1729837069412,\u0026#34;text\u0026#34;:\u0026#34;子网的划分\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntrnyqyw0\u0026#34;,\u0026#34;created\u0026#34;:1729836400287,\u0026#34;text\u0026#34;:\u0026#34;ip地址与NAT\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nziz8ye00\u0026#34;,\u0026#34;created\u0026#34;:1729836851563,\u0026#34;text\u0026#34;:\u0026#34;IPv4地址与NAT(网络地址转换)\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntszfbkw0\u0026#34;,\u0026#34;created\u0026#34;:1729836403157,\u0026#34;text\u0026#34;:\u0026#34;地址解析协议\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o3cnsgps0\u0026#34;,\u0026#34;created\u0026#34;:1729837151266,\u0026#34;text\u0026#34;:\u0026#34;物理地址与ip地址的映射\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntu5i8b40\u0026#34;,\u0026#34;created\u0026#34;:1729836405701,\u0026#34;text\u0026#34;:\u0026#34;动态主机配置协议DHCP\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o4gkd49s0\u0026#34;,\u0026#34;created\u0026#34;:1729837238130,\u0026#34;text\u0026#34;:\u0026#34;动态分配ip地址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntxhrumo0\u0026#34;,\u0026#34;created\u0026#34;:1729836412973,\u0026#34;text\u0026#34;:\u0026#34;网际控制报文协议ICMP\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nns2j6jk0\u0026#34;,\u0026#34;created\u0026#34;:1729835930983,\u0026#34;text\u0026#34;:\u0026#34;IPV6\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o5j4e2sw0\u0026#34;,\u0026#34;created\u0026#34;:1729837322059,\u0026#34;text\u0026#34;:\u0026#34;为了打破ipv4快没的问题\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nntkwwps0\u0026#34;,\u0026#34;created\u0026#34;:1729835934271,\u0026#34;text\u0026#34;:\u0026#34;路由算法与路由协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7bd6ng00\u0026#34;,\u0026#34;created\u0026#34;:1729837461905,\u0026#34;text\u0026#34;:\u0026#34;静态路由\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7cbl9iw0\u0026#34;,\u0026#34;created\u0026#34;:1729837463985,\u0026#34;text\u0026#34;:\u0026#34;动态路由\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7pp1m5c0\u0026#34;,\u0026#34;created\u0026#34;:1729837493097,\u0026#34;text\u0026#34;:\u0026#34;距离-向量路由算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o88n6x5s0\u0026#34;,\u0026#34;created\u0026#34;:1729837534344,\u0026#34;text\u0026#34;:\u0026#34;链路状态路由算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9f2jlr40\u0026#34;,\u0026#34;created\u0026#34;:1729837626697,\u0026#34;text\u0026#34;:\u0026#34;路由选择协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9oi6gbc0\u0026#34;,\u0026#34;created\u0026#34;:1729837647233,\u0026#34;text\u0026#34;:\u0026#34;内部网关协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oajvdj2o0\u0026#34;,\u0026#34;created\u0026#34;:1729837715511,\u0026#34;text\u0026#34;:\u0026#34;RIP路由信息协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oawwjrow0\u0026#34;,\u0026#34;created\u0026#34;:1729837743881,\u0026#34;text\u0026#34;:\u0026#34;OSPF开放最短路径优先协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9pccsm80\u0026#34;,\u0026#34;created\u0026#34;:1729837649058,\u0026#34;text\u0026#34;:\u0026#34;外部网关协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54obejgvq00\u0026#34;,\u0026#34;created\u0026#34;:1729837782272,\u0026#34;text\u0026#34;:\u0026#34; 边界网关协议BGP\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnxunue80\u0026#34;,\u0026#34;created\u0026#34;:1729835943567,\u0026#34;text\u0026#34;:\u0026#34;IP多播\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnyv2m800\u0026#34;,\u0026#34;created\u0026#34;:1729835945769,\u0026#34;text\u0026#34;:\u0026#34;移动IP\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54no032q140\u0026#34;,\u0026#34;created\u0026#34;:1729835948430,\u0026#34;text\u0026#34;:\u0026#34;网络层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oggo80bk0\u0026#34;,\u0026#34;created\u0026#34;:1729838178734,\u0026#34;text\u0026#34;:\u0026#34;冲突域\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oghpxvb40\u0026#34;,\u0026#34;created\u0026#34;:1729838181014,\u0026#34;text\u0026#34;:\u0026#34;广播域\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ohbmnue80\u0026#34;,\u0026#34;created\u0026#34;:1729838246119,\u0026#34;text\u0026#34;:\u0026#34;路由表由路由处理机和交换结构组成\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oiopb2jc0\u0026#34;,\u0026#34;created\u0026#34;:1729838352942,\u0026#34;text\u0026#34;:\u0026#34;路由表与分组转发\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzhljw4w0\u0026#34;,\u0026#34;created\u0026#34;:1729825564118,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ol1ap5b40\u0026#34;,\u0026#34;created\u0026#34;:1729838537085,\u0026#34;text\u0026#34;:\u0026#34;传输层提供的服务\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ome4ic9c0\u0026#34;,\u0026#34;created\u0026#34;:1729838643373,\u0026#34;text\u0026#34;:\u0026#34;应用进程之间的逻辑通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54omf28nmg0\u0026#34;,\u0026#34;created\u0026#34;:1729838645413,\u0026#34;text\u0026#34;:\u0026#34;复用与分用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oo8f4jz40\u0026#34;,\u0026#34;created\u0026#34;:1729838787683,\u0026#34;text\u0026#34;:\u0026#34;检错检测\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oohr72t40\u0026#34;,\u0026#34;created\u0026#34;:1729838808003,\u0026#34;text\u0026#34;:\u0026#34;提供面向连接和无连接的传输协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ol310mf40\u0026#34;,\u0026#34;created\u0026#34;:1729838540853,\u0026#34;text\u0026#34;:\u0026#34;UDP协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54opducdgg0\u0026#34;,\u0026#34;created\u0026#34;:1729838877851,\u0026#34;text\u0026#34;:\u0026#34;udp首部为20b\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oqdozlc00\u0026#34;,\u0026#34;created\u0026#34;:1729838955891,\u0026#34;text\u0026#34;:\u0026#34;udp检验\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54olts28zs0\u0026#34;,\u0026#34;created\u0026#34;:1729838599085,\u0026#34;text\u0026#34;:\u0026#34;TCP协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oqn81t940\u0026#34;,\u0026#34;created\u0026#34;:1729838976635,\u0026#34;text\u0026#34;:\u0026#34;面向字节流\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54osruvn9s0\u0026#34;,\u0026#34;created\u0026#34;:1729839143451,\u0026#34;text\u0026#34;:\u0026#34;三握手\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ost0a7fs0\u0026#34;,\u0026#34;created\u0026#34;:1729839145954,\u0026#34;text\u0026#34;:\u0026#34;四挥手\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54otymmnds0\u0026#34;,\u0026#34;created\u0026#34;:1729839236554,\u0026#34;text\u0026#34;:\u0026#34;TCP流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54otzlpf680\u0026#34;,\u0026#34;created\u0026#34;:1729839238674,\u0026#34;text\u0026#34;:\u0026#34;TCP拥塞控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k2igfggw0\u0026#34;,\u0026#34;created\u0026#34;:1729825801078,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om4n6v680\u0026#34;,\u0026#34;created\u0026#34;:1729838622735,\u0026#34;text\u0026#34;:\u0026#34;网络应用模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ouw5n5e00\u0026#34;,\u0026#34;created\u0026#34;:1729839309537,\u0026#34;text\u0026#34;:\u0026#34;客户/服务器模型\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ouxghae00\u0026#34;,\u0026#34;created\u0026#34;:1729839312369,\u0026#34;text\u0026#34;:\u0026#34;P2P模型\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om5p4law0\u0026#34;,\u0026#34;created\u0026#34;:1729838625029,\u0026#34;text\u0026#34;:\u0026#34;DNS(域名系统)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54owijm3q00\u0026#34;,\u0026#34;created\u0026#34;:1729839436635,\u0026#34;text\u0026#34;:\u0026#34;层次域名空间\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ox4pim5c0\u0026#34;,\u0026#34;created\u0026#34;:1729839484881,\u0026#34;text\u0026#34;:\u0026#34;从后往前域名等级减小\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54owjp0khs0\u0026#34;,\u0026#34;created\u0026#34;:1729839439138,\u0026#34;text\u0026#34;:\u0026#34;域名服务器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyb66cdc0\u0026#34;,\u0026#34;created\u0026#34;:1729839577313,\u0026#34;text\u0026#34;:\u0026#34;根域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyc9po4w0\u0026#34;,\u0026#34;created\u0026#34;:1729839579704,\u0026#34;text\u0026#34;:\u0026#34;顶级域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oydm51rs0\u0026#34;,\u0026#34;created\u0026#34;:1729839582632,\u0026#34;text\u0026#34;:\u0026#34;权限域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyek10j40\u0026#34;,\u0026#34;created\u0026#34;:1729839584681,\u0026#34;text\u0026#34;:\u0026#34;本地域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om6p93vs0\u0026#34;,\u0026#34;created\u0026#34;:1729838627213,\u0026#34;text\u0026#34;:\u0026#34;文件传输协议(FTP)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oma91zig0\u0026#34;,\u0026#34;created\u0026#34;:1729838634941,\u0026#34;text\u0026#34;:\u0026#34;电子邮件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54omb7305s0\u0026#34;,\u0026#34;created\u0026#34;:1729838636998,\u0026#34;text\u0026#34;:\u0026#34;万维网\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},\u0026#34;template\u0026#34;:\u0026#34;structure\u0026#34;,\u0026#34;theme\u0026#34;:\u0026#34;fresh-blue\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.4.33\u0026#34;} ","date":"2024-10-25T15:17:45+08:00","image":"https://getshhi.github.io/kj1.png","permalink":"https://getshhi.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","title":"计算机网络思维导图"},{"content":"下面是我弄的思维导图 大致图片 json 这个可以在菜鸟工具上看到 在线思维导图(创建json文件,然后再复制下面的,在该网站导入json文件即可)\n1 {\u0026#34;root\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtfin28kg0\u0026#34;,\u0026#34;created\u0026#34;:1717055655662,\u0026#34;text\u0026#34;:\u0026#34;操作系统\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtikgl32w0\u0026#34;,\u0026#34;created\u0026#34;:1717055894717,\u0026#34;text\u0026#34;:\u0026#34;计算机系统概述\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:-50.0000234842297,\u0026#34;y\u0026#34;:27.499998621642987}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtle0xqow0\u0026#34;,\u0026#34;created\u0026#34;:1717056115802,\u0026#34;text\u0026#34;:\u0026#34;操作系统的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtmg261eg0\u0026#34;,\u0026#34;created\u0026#34;:1717056198594,\u0026#34;text\u0026#34;:\u0026#34;操作系统的特怔\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto55h7cg0\u0026#34;,\u0026#34;created\u0026#34;:1717056331578,\u0026#34;text\u0026#34;:\u0026#34;并发\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto68ribs0\u0026#34;,\u0026#34;created\u0026#34;:1717056333954,\u0026#34;text\u0026#34;:\u0026#34;共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto7aqv000\u0026#34;,\u0026#34;created\u0026#34;:1717056336250,\u0026#34;text\u0026#34;:\u0026#34;虚拟\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto875mpk0\u0026#34;,\u0026#34;created\u0026#34;:1717056338210,\u0026#34;text\u0026#34;:\u0026#34;异步\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtmgze06o0\u0026#34;,\u0026#34;created\u0026#34;:1717056200603,\u0026#34;text\u0026#34;:\u0026#34;操作系统的目标和功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtr270l400\u0026#34;,\u0026#34;created\u0026#34;:1717056560233,\u0026#34;text\u0026#34;:\u0026#34;计算机资源的管理者\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrktsxbk0\u0026#34;,\u0026#34;created\u0026#34;:1717056600793,\u0026#34;text\u0026#34;:\u0026#34;处理机\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrpewyfk0\u0026#34;,\u0026#34;created\u0026#34;:1717056610777,\u0026#34;text\u0026#34;:\u0026#34;存储器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mts8lpj740\u0026#34;,\u0026#34;created\u0026#34;:1717056652547,\u0026#34;text\u0026#34;:\u0026#34;文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtsd33b8g0\u0026#34;,\u0026#34;created\u0026#34;:1717056662305,\u0026#34;text\u0026#34;:\u0026#34;设备\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrbo3bs00\u0026#34;,\u0026#34;created\u0026#34;:1717056580857,\u0026#34;text\u0026#34;:\u0026#34;用户与计算机的接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtuavjtds0\u0026#34;,\u0026#34;created\u0026#34;:1717056814224,\u0026#34;text\u0026#34;:\u0026#34;命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtve7wp280\u0026#34;,\u0026#34;created\u0026#34;:1717056899865,\u0026#34;text\u0026#34;:\u0026#34;联机命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtw6ps09k0\u0026#34;,\u0026#34;created\u0026#34;:1717056961896,\u0026#34;text\u0026#34;:\u0026#34;一条命令一条作业\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtvpkbtgw0\u0026#34;,\u0026#34;created\u0026#34;:1717056924561,\u0026#34;text\u0026#34;:\u0026#34;脱机命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtwpj2ahs0\u0026#34;,\u0026#34;created\u0026#34;:1717057002849,\u0026#34;text\u0026#34;:\u0026#34;多条命令多条作业\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtushp87s0\u0026#34;,\u0026#34;created\u0026#34;:1717056852568,\u0026#34;text\u0026#34;:\u0026#34;程序接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtx0dh1u80\u0026#34;,\u0026#34;created\u0026#34;:1717057026455,\u0026#34;text\u0026#34;:\u0026#34;gui接口\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtxrpya200\u0026#34;,\u0026#34;created\u0026#34;:1717057085983,\u0026#34;text\u0026#34;:\u0026#34;操作系统发展历程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty5enjjc0\u0026#34;,\u0026#34;created\u0026#34;:1717057115775,\u0026#34;text\u0026#34;:\u0026#34;手工操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty68tgtc0\u0026#34;,\u0026#34;created\u0026#34;:1717057117599,\u0026#34;text\u0026#34;:\u0026#34;批处理系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu0awpr2o0\u0026#34;,\u0026#34;created\u0026#34;:1717057284479,\u0026#34;text\u0026#34;:\u0026#34;单道批处理系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu0btwuhc0\u0026#34;,\u0026#34;created\u0026#34;:1717057286486,\u0026#34;text\u0026#34;:\u0026#34;多道批处理系统\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty70ly3k0\u0026#34;,\u0026#34;created\u0026#34;:1717057119279,\u0026#34;text\u0026#34;:\u0026#34;分时操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty7yc8zk0\u0026#34;,\u0026#34;created\u0026#34;:1717057121319,\u0026#34;text\u0026#34;:\u0026#34;实时操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty8r1xfc0\u0026#34;,\u0026#34;created\u0026#34;:1717057123055,\u0026#34;text\u0026#34;:\u0026#34;网络操作系统和分步式计算机系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu3wtfbsg0\u0026#34;,\u0026#34;created\u0026#34;:1717057567262,\u0026#34;text\u0026#34;:\u0026#34;个人操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu81h0m0o0\u0026#34;,\u0026#34;created\u0026#34;:1717057890852,\u0026#34;text\u0026#34;:\u0026#34;操作系统的运行环境\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu8hukjew0\u0026#34;,\u0026#34;created\u0026#34;:1717057926500,\u0026#34;text\u0026#34;:\u0026#34;内核态\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua5d0f5s0\u0026#34;,\u0026#34;created\u0026#34;:1717058056045,\u0026#34;text\u0026#34;:\u0026#34;时钟管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua67ojgg0\u0026#34;,\u0026#34;created\u0026#34;:1717058057900,\u0026#34;text\u0026#34;:\u0026#34;中断机制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua73z3wo0\u0026#34;,\u0026#34;created\u0026#34;:1717058059852,\u0026#34;text\u0026#34;:\u0026#34;原语\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muatq16k00\u0026#34;,\u0026#34;created\u0026#34;:1717058109075,\u0026#34;text\u0026#34;:\u0026#34;系统控制的数据结构与处理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muc2wlbl40\u0026#34;,\u0026#34;created\u0026#34;:1717058207427,\u0026#34;text\u0026#34;:\u0026#34;进程管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mucdbszfs0\u0026#34;,\u0026#34;created\u0026#34;:1717058230115,\u0026#34;text\u0026#34;:\u0026#34;存储器管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mucn1rbts0\u0026#34;,\u0026#34;created\u0026#34;:1717058251275,\u0026#34;text\u0026#34;:\u0026#34;设备管理\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu9lyf76o0\u0026#34;,\u0026#34;created\u0026#34;:1717058013804,\u0026#34;text\u0026#34;:\u0026#34;非内核态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mudmh184w0\u0026#34;,\u0026#34;created\u0026#34;:1717058328386,\u0026#34;text\u0026#34;:\u0026#34;中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muduyiupc0\u0026#34;,\u0026#34;created\u0026#34;:1717058346858,\u0026#34;text\u0026#34;:\u0026#34;外部中断(硬件)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsazmwxag0\u0026#34;,\u0026#34;created\u0026#34;:1717154039684,\u0026#34;text\u0026#34;:\u0026#34;可屏蔽中断INTR\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsb0ji1oo0\u0026#34;,\u0026#34;created\u0026#34;:1717154041655,\u0026#34;text\u0026#34;:\u0026#34;不可屏蔽中断NMI\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mudwaev8o0\u0026#34;,\u0026#34;created\u0026#34;:1717058349754,\u0026#34;text\u0026#34;:\u0026#34;内部异常\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mueg4mezs0\u0026#34;,\u0026#34;created\u0026#34;:1717058392939,\u0026#34;text\u0026#34;:\u0026#34;软件中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mufr3qty80\u0026#34;,\u0026#34;created\u0026#34;:1717058495195,\u0026#34;text\u0026#34;:\u0026#34;故障\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muh1murs00\u0026#34;,\u0026#34;created\u0026#34;:1717058596482,\u0026#34;text\u0026#34;:\u0026#34;自己写的指令\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mufs7jsdc0\u0026#34;,\u0026#34;created\u0026#34;:1717058497602,\u0026#34;text\u0026#34;:\u0026#34;自陷\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muh79scg00\u0026#34;,\u0026#34;created\u0026#34;:1717058608753,\u0026#34;text\u0026#34;:\u0026#34;系统调用\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muexa77480\u0026#34;,\u0026#34;created\u0026#34;:1717058430282,\u0026#34;text\u0026#34;:\u0026#34;硬件中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mug7ruvz40\u0026#34;,\u0026#34;created\u0026#34;:1717058531482,\u0026#34;text\u0026#34;:\u0026#34;终止\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muj4z7h340\u0026#34;,\u0026#34;created\u0026#34;:1717058760488,\u0026#34;text\u0026#34;:\u0026#34;操作系统结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mujdppck80\u0026#34;,\u0026#34;created\u0026#34;:1717058779504,\u0026#34;text\u0026#34;:\u0026#34;分层法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mujxwy1dc0\u0026#34;,\u0026#34;created\u0026#34;:1717058823478,\u0026#34;text\u0026#34;:\u0026#34;模块化\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muk8o7e740\u0026#34;,\u0026#34;created\u0026#34;:1717058846894,\u0026#34;text\u0026#34;:\u0026#34;宏内核和微内核\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muq9mgihs0\u0026#34;,\u0026#34;created\u0026#34;:1717059319150,\u0026#34;text\u0026#34;:\u0026#34;虚拟机\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muqvy826o0\u0026#34;,\u0026#34;created\u0026#34;:1717059367751,\u0026#34;text\u0026#34;:\u0026#34;第一类虚拟机管理程序\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muqwwmkw00\u0026#34;,\u0026#34;created\u0026#34;:1717059369831,\u0026#34;text\u0026#34;:\u0026#34;第二类虚拟机管理程序\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtjbmprtk0\u0026#34;,\u0026#34;created\u0026#34;:1717055953860,\u0026#34;text\u0026#34;:\u0026#34;进程与线程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu4k41qg0\u0026#34;,\u0026#34;created\u0026#34;:1717059621581,\u0026#34;text\u0026#34;:\u0026#34;进程与线程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsdrvxlbs0\u0026#34;,\u0026#34;created\u0026#34;:1717154257908,\u0026#34;text\u0026#34;:\u0026#34;进程的概念与特怔\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nseocfyj40\u0026#34;,\u0026#34;created\u0026#34;:1717154328563,\u0026#34;text\u0026#34;:\u0026#34;进程是进程实体的运行过程，是资源分配和调度的独立单位\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsgbekhvs0\u0026#34;,\u0026#34;created\u0026#34;:1717154457122,\u0026#34;text\u0026#34;:\u0026#34;动态性，并发性，独立性，异步性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nshas1yfc0\u0026#34;,\u0026#34;created\u0026#34;:1717154534125,\u0026#34;text\u0026#34;:\u0026#34;进程由进程控制块，程序段，数据段组成\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsibvkm800\u0026#34;,\u0026#34;created\u0026#34;:1717154614878,\u0026#34;text\u0026#34;:\u0026#34;进程有五个状态运行态，阻塞态，就绪态，创建态，终止态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nspjy6w680\u0026#34;,\u0026#34;created\u0026#34;:1717155181000,\u0026#34;text\u0026#34;:\u0026#34;进程的通信分为共享存储，消息传递，管道通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nswdh2kps0\u0026#34;,\u0026#34;created\u0026#34;:1717155715453,\u0026#34;text\u0026#34;:\u0026#34;线程\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu6xc0o00\u0026#34;,\u0026#34;created\u0026#34;:1717059626734,\u0026#34;text\u0026#34;:\u0026#34;cpu调度\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ntccptjts0\u0026#34;,\u0026#34;created\u0026#34;:1717156967632,\u0026#34;text\u0026#34;:\u0026#34;调度的层次分为高级调度(作业调度)，中级调度(内存调度)，低级调度(进程调度)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ok77pee740\u0026#34;,\u0026#34;created\u0026#34;:1717232734870,\u0026#34;text\u0026#34;:\u0026#34;调度器分为排队器，分派器，上下文切换器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ok99b2low0\u0026#34;,\u0026#34;created\u0026#34;:1717232895085,\u0026#34;text\u0026#34;:\u0026#34;进程调度的方式分为非抢占调度方式和抢占调度方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1oke5mnivk0\u0026#34;,\u0026#34;created\u0026#34;:1717233278899,\u0026#34;text\u0026#34;:\u0026#34;调度算法评价的标准主要有cpu利用率，系统吞吐量，周转时间，等待时间，响应时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1okmld8vew0\u0026#34;,\u0026#34;created\u0026#34;:1717233940072,\u0026#34;text\u0026#34;:\u0026#34;调度算法分为先来先服务算法(FCFS)调度算法，短作业优先调度算法(SJF)和短进程优先(SPF)可以是抢占式的，高响比优先调度算法，优先调度算法，时间片轮转算法，多级队列调度算法，多级反馈队列调度算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu7z5w5k0\u0026#34;,\u0026#34;created\u0026#34;:1717059629022,\u0026#34;text\u0026#34;:\u0026#34;同步与互斥\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph4o728io0\u0026#34;,\u0026#34;created\u0026#34;:1717325632301,\u0026#34;text\u0026#34;:\u0026#34;同步与互斥的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pguwpw2140\u0026#34;,\u0026#34;created\u0026#34;:1717324867212,\u0026#34;text\u0026#34;:\u0026#34;一次仅让一个进程使用的资源叫临界资源\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pgvu4687s0\u0026#34;,\u0026#34;created\u0026#34;:1717324939909,\u0026#34;text\u0026#34;:\u0026#34;同步也叫直接制约关系，源于进程之间的合作\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pgvvx6qps0\u0026#34;,\u0026#34;created\u0026#34;:1717324943840,\u0026#34;text\u0026#34;:\u0026#34;互斥也叫间接制约关系，源于对临界资源的访问\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph10ww5x40\u0026#34;,\u0026#34;created\u0026#34;:1717325346527,\u0026#34;text\u0026#34;:\u0026#34;实现临界区要遵循的原则-空闲让进，忙则等待，有限等待，让权等待\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph32kq97s0\u0026#34;,\u0026#34;created\u0026#34;:1717325506874,\u0026#34;text\u0026#34;:\u0026#34;实现临界区互斥的方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph6kyvso00\u0026#34;,\u0026#34;created\u0026#34;:1717325782004,\u0026#34;text\u0026#34;:\u0026#34;软件方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph74c33mo0\u0026#34;,\u0026#34;created\u0026#34;:1717325824161,\u0026#34;text\u0026#34;:\u0026#34;单标志法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph9focoww0\u0026#34;,\u0026#34;created\u0026#34;:1717326005576,\u0026#34;text\u0026#34;:\u0026#34;若p1进程一直不进去，则p0进程想进去也进不去，违反空闲让进原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph7f6kxqo0\u0026#34;,\u0026#34;created\u0026#34;:1717325847773,\u0026#34;text\u0026#34;:\u0026#34;双标志位先检查法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phc8g0jaw0\u0026#34;,\u0026#34;created\u0026#34;:1717326224927,\u0026#34;text\u0026#34;:\u0026#34;违反忙则等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phdvgmtfs0\u0026#34;,\u0026#34;created\u0026#34;:1717326353394,\u0026#34;text\u0026#34;:\u0026#34;双标志位后检查法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phf5bsjbs0\u0026#34;,\u0026#34;created\u0026#34;:1717326453234,\u0026#34;text\u0026#34;:\u0026#34;违反空闲让进和有限等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phle64ryg0\u0026#34;,\u0026#34;created\u0026#34;:1717326942667,\u0026#34;text\u0026#34;:\u0026#34;Peterson算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phlqlsfoo0\u0026#34;,\u0026#34;created\u0026#34;:1717326969736,\u0026#34;text\u0026#34;:\u0026#34;违反让权等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph6m1iovc0\u0026#34;,\u0026#34;created\u0026#34;:1717325784340,\u0026#34;text\u0026#34;:\u0026#34;硬件方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phpokah4g0\u0026#34;,\u0026#34;created\u0026#34;:1717327278748,\u0026#34;text\u0026#34;:\u0026#34;中断屏蔽方法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phr0iobhk0\u0026#34;,\u0026#34;created\u0026#34;:1717327383136,\u0026#34;text\u0026#34;:\u0026#34;TestAndset指令\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phrenu5000\u0026#34;,\u0026#34;created\u0026#34;:1717327413923,\u0026#34;text\u0026#34;:\u0026#34;Swap指令\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph63wsygw0\u0026#34;,\u0026#34;created\u0026#34;:1717325744873,\u0026#34;text\u0026#34;:\u0026#34;互斥锁\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phuvxzctk0\u0026#34;,\u0026#34;created\u0026#34;:1717327686634,\u0026#34;text\u0026#34;:\u0026#34;自旋锁\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phvy1fob40\u0026#34;,\u0026#34;created\u0026#34;:1717327769561,\u0026#34;text\u0026#34;:\u0026#34;信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phwzdg89k0\u0026#34;,\u0026#34;created\u0026#34;:1717327850828,\u0026#34;text\u0026#34;:\u0026#34;整型信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1piu1sxxb40\u0026#34;,\u0026#34;created\u0026#34;:1717330442136,\u0026#34;text\u0026#34;:\u0026#34;未遵循让权等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phx0fodr40\u0026#34;,\u0026#34;created\u0026#34;:1717327853141,\u0026#34;text\u0026#34;:\u0026#34;记录型信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pixuaq9mw0\u0026#34;,\u0026#34;created\u0026#34;:1717330739254,\u0026#34;text\u0026#34;:\u0026#34;实现进程互斥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pizy9l2a00\u0026#34;,\u0026#34;created\u0026#34;:1717330904620,\u0026#34;text\u0026#34;:\u0026#34;信号量实现同步前v后p\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj16e94d40\u0026#34;,\u0026#34;created\u0026#34;:1717331000681,\u0026#34;text\u0026#34;:\u0026#34;信号量实现前前驱关系\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj2o424ig0\u0026#34;,\u0026#34;created\u0026#34;:1717331117611,\u0026#34;text\u0026#34;:\u0026#34;经典同步问题\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj35z3d3c0\u0026#34;,\u0026#34;created\u0026#34;:1717331156492,\u0026#34;text\u0026#34;:\u0026#34;生产者消费者问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj370krhc0\u0026#34;,\u0026#34;created\u0026#34;:1717331158759,\u0026#34;text\u0026#34;:\u0026#34;读者-写者问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj382g5ds0\u0026#34;,\u0026#34;created\u0026#34;:1717331161049,\u0026#34;text\u0026#34;:\u0026#34;哲学家进餐问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj54lkogg0\u0026#34;,\u0026#34;created\u0026#34;:1717331310226,\u0026#34;text\u0026#34;:\u0026#34;吸烟者问题\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pk1bwx1ag0\u0026#34;,\u0026#34;created\u0026#34;:1717333833803,\u0026#34;text\u0026#34;:\u0026#34;管程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pk4tx4qfs0\u0026#34;,\u0026#34;created\u0026#34;:1717334108091,\u0026#34;text\u0026#34;:\u0026#34;管程的名称，局限于管程内部共享局部说明，对该数据结构进行操作的一组过程，对局部于管程内部的共享数据设置初始值的语句\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu98jufs0\u0026#34;,\u0026#34;created\u0026#34;:1717059631766,\u0026#34;text\u0026#34;:\u0026#34;死锁\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbrczzq740\u0026#34;,\u0026#34;created\u0026#34;:1717412043602,\u0026#34;text\u0026#34;:\u0026#34;死锁的概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc3yvmbu00\u0026#34;,\u0026#34;created\u0026#34;:1717413031596,\u0026#34;text\u0026#34;:\u0026#34;所谓死锁，是指多个进程因竟争资源而造成的一种僵局\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcaiiez4w0\u0026#34;,\u0026#34;created\u0026#34;:1717413544519,\u0026#34;text\u0026#34;:\u0026#34;发生死锁的进程必定大于或等于2个\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcby4cdsg0\u0026#34;,\u0026#34;created\u0026#34;:1717413656860,\u0026#34;text\u0026#34;:\u0026#34;发生饥饿的进程可能处于就绪态，也可能处于阻塞态，死锁一定处于阻塞态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcfyojso80\u0026#34;,\u0026#34;created\u0026#34;:1717413971539,\u0026#34;text\u0026#34;:\u0026#34;产生死锁的必要条件互斥条件，不可剥夺条件，请求并保持条件，循环等待条件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qchstnnag0\u0026#34;,\u0026#34;created\u0026#34;:1717414115515,\u0026#34;text\u0026#34;:\u0026#34;死锁的处理办法死锁预防，避免死锁，死锁的检测与解除\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbre6slbs0\u0026#34;,\u0026#34;created\u0026#34;:1717412046190,\u0026#34;text\u0026#34;:\u0026#34;死锁的预防\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc6u72pmo0\u0026#34;,\u0026#34;created\u0026#34;:1717413256498,\u0026#34;text\u0026#34;:\u0026#34;破坏死锁产生的几个必要条件之一即可\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmt1bd3k0\u0026#34;,\u0026#34;created\u0026#34;:1717414507799,\u0026#34;text\u0026#34;:\u0026#34;循环等待\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmu3vtrk0\u0026#34;,\u0026#34;created\u0026#34;:1717414510131,\u0026#34;text\u0026#34;:\u0026#34;互斥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmv3z3zs0\u0026#34;,\u0026#34;created\u0026#34;:1717414512314,\u0026#34;text\u0026#34;:\u0026#34;请求并保持\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmwa2ns00\u0026#34;,\u0026#34;created\u0026#34;:1717414514859,\u0026#34;text\u0026#34;:\u0026#34;不可剥夺\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbrf8jl7k0\u0026#34;,\u0026#34;created\u0026#34;:1717412048472,\u0026#34;text\u0026#34;:\u0026#34;死锁的检测和解除\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc6v2yqs00\u0026#34;,\u0026#34;created\u0026#34;:1717413258426,\u0026#34;text\u0026#34;:\u0026#34;死锁的检测\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd5sddsmo0\u0026#34;,\u0026#34;created\u0026#34;:1717415995271,\u0026#34;text\u0026#34;:\u0026#34;用资源分配图来检测系统所处的状态是否为死锁状态\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd4hhw46g0\u0026#34;,\u0026#34;created\u0026#34;:1717415893235,\u0026#34;text\u0026#34;:\u0026#34;死锁的解除\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8eaibdc0\u0026#34;,\u0026#34;created\u0026#34;:1717416199715,\u0026#34;text\u0026#34;:\u0026#34;资源剥夺法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8jvso740\u0026#34;,\u0026#34;created\u0026#34;:1717416211886,\u0026#34;text\u0026#34;:\u0026#34;撤销进程法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8kyy7z40\u0026#34;,\u0026#34;created\u0026#34;:1717416214254,\u0026#34;text\u0026#34;:\u0026#34;进程回退法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qckg0h73k0\u0026#34;,\u0026#34;created\u0026#34;:1717414322722,\u0026#34;text\u0026#34;:\u0026#34;死锁的避免\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qckx6btfs0\u0026#34;,\u0026#34;created\u0026#34;:1717414360081,\u0026#34;text\u0026#34;:\u0026#34;系统安全状态\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcxtkw77s0\u0026#34;,\u0026#34;created\u0026#34;:1717415370989,\u0026#34;text\u0026#34;:\u0026#34;所谓安全状态是指系统能按某种进程推进顺序分配所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可完成\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcu1ss3yw0\u0026#34;,\u0026#34;created\u0026#34;:1717415075423,\u0026#34;text\u0026#34;:\u0026#34;银行家算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd2c0xm3s0\u0026#34;,\u0026#34;created\u0026#34;:1717415724597,\u0026#34;text\u0026#34;:\u0026#34;安全性算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtjquaiw80\u0026#34;,\u0026#34;created\u0026#34;:1717055986970,\u0026#34;text\u0026#34;:\u0026#34;内存管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muvhtnn340\u0026#34;,\u0026#34;created\u0026#34;:1717059728821,\u0026#34;text\u0026#34;:\u0026#34;内存管理概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rwz0aypb40\u0026#34;,\u0026#34;created\u0026#34;:1717573446145,\u0026#34;text\u0026#34;:\u0026#34;内存的基本原理和要求\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx0m4dlf40\u0026#34;,\u0026#34;created\u0026#34;:1717573572000,\u0026#34;text\u0026#34;:\u0026#34;程序的链接与装入\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5bwipdc0\u0026#34;,\u0026#34;created\u0026#34;:1717573941578,\u0026#34;text\u0026#34;:\u0026#34;编译\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5cwrmw00\u0026#34;,\u0026#34;created\u0026#34;:1717573943770,\u0026#34;text\u0026#34;:\u0026#34;链接\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5dwhvqg0\u0026#34;,\u0026#34;created\u0026#34;:1717573945930,\u0026#34;text\u0026#34;:\u0026#34;装入\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx0zq8um00\u0026#34;,\u0026#34;created\u0026#34;:1717573601620,\u0026#34;text\u0026#34;:\u0026#34;逻辑地址与物理地址\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx191i24o0\u0026#34;,\u0026#34;created\u0026#34;:1717573621892,\u0026#34;text\u0026#34;:\u0026#34;进程的内存映像\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx1m09l1c0\u0026#34;,\u0026#34;created\u0026#34;:1717573650116,\u0026#34;text\u0026#34;:\u0026#34;内存保护\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx1uxctq80\u0026#34;,\u0026#34;created\u0026#34;:1717573669531,\u0026#34;text\u0026#34;:\u0026#34;内存共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx21umdo00\u0026#34;,\u0026#34;created\u0026#34;:1717573684603,\u0026#34;text\u0026#34;:\u0026#34;内存分配与回收\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rwz13lkjs0\u0026#34;,\u0026#34;created\u0026#34;:1717573447876,\u0026#34;text\u0026#34;:\u0026#34;基本分页存储管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxnk5onf40\u0026#34;,\u0026#34;created\u0026#34;:1717575370101,\u0026#34;text\u0026#34;:\u0026#34;分页存储的几个概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxojd0vnk0\u0026#34;,\u0026#34;created\u0026#34;:1717575446732,\u0026#34;text\u0026#34;:\u0026#34;逻辑地址分为页号和偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxok6xx5s0\u0026#34;,\u0026#34;created\u0026#34;:1717575448541,\u0026#34;text\u0026#34;:\u0026#34;页表分为页号与块号(页号是隐藏的)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxsp4c5600\u0026#34;,\u0026#34;created\u0026#34;:1717575772724,\u0026#34;text\u0026#34;:\u0026#34;基本地址变换结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxtwf0le80\u0026#34;,\u0026#34;created\u0026#34;:1717575866972,\u0026#34;text\u0026#34;:\u0026#34;具有快表的地址变换结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxvpwb2i00\u0026#34;,\u0026#34;created\u0026#34;:1717576009508,\u0026#34;text\u0026#34;:\u0026#34;两级页表的逻辑地址空间一级页号，二级页号，页内偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx2rtdhmo0\u0026#34;,\u0026#34;created\u0026#34;:1717573741124,\u0026#34;text\u0026#34;:\u0026#34;连续分配管理方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxgvu0jyw0\u0026#34;,\u0026#34;created\u0026#34;:1717574846968,\u0026#34;text\u0026#34;:\u0026#34;单一连续分配\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxgwofrww0\u0026#34;,\u0026#34;created\u0026#34;:1717574848807,\u0026#34;text\u0026#34;:\u0026#34;固定分区分配\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxhnrsavc0\u0026#34;,\u0026#34;created\u0026#34;:1717574907783,\u0026#34;text\u0026#34;:\u0026#34;动态分区分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxiiirnao0\u0026#34;,\u0026#34;created\u0026#34;:1717574974718,\u0026#34;text\u0026#34;:\u0026#34;首次适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxijhkik00\u0026#34;,\u0026#34;created\u0026#34;:1717574976822,\u0026#34;text\u0026#34;:\u0026#34;邻近适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxim41cnk0\u0026#34;,\u0026#34;created\u0026#34;:1717574982534,\u0026#34;text\u0026#34;:\u0026#34;最佳适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rximybhk80\u0026#34;,\u0026#34;created\u0026#34;:1717574984365,\u0026#34;text\u0026#34;:\u0026#34;最坏适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx3lejrts0\u0026#34;,\u0026#34;created\u0026#34;:1717573805531,\u0026#34;text\u0026#34;:\u0026#34;基本分段存储管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxyqodn600\u0026#34;,\u0026#34;created\u0026#34;:1717576246298,\u0026#34;text\u0026#34;:\u0026#34;段的逻辑地址分为段号与段内偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ry0ic1m680\u0026#34;,\u0026#34;created\u0026#34;:1717576384866,\u0026#34;text\u0026#34;:\u0026#34;段表分为段号，段长，本段在主存的始址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx45i4skg0\u0026#34;,\u0026#34;created\u0026#34;:1717573849283,\u0026#34;text\u0026#34;:\u0026#34;段页式存储管理\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muvtsk6xs0\u0026#34;,\u0026#34;created\u0026#34;:1717059754876,\u0026#34;text\u0026#34;:\u0026#34;虚拟内存管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt6yqllz40\u0026#34;,\u0026#34;created\u0026#34;:1717765905124,\u0026#34;text\u0026#34;:\u0026#34;局部性原理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt86tna5c0\u0026#34;,\u0026#34;created\u0026#34;:1717766001086,\u0026#34;text\u0026#34;:\u0026#34;时间局部性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt87mmd3k0\u0026#34;,\u0026#34;created\u0026#34;:1717766002838,\u0026#34;text\u0026#34;:\u0026#34;空间局部性\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt6zo5f1k0\u0026#34;,\u0026#34;created\u0026#34;:1717765907152,\u0026#34;text\u0026#34;:\u0026#34;概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tta7wlzhc0\u0026#34;,\u0026#34;created\u0026#34;:1717766160171,\u0026#34;text\u0026#34;:\u0026#34;之所以称为虚拟存储器，是因为这种存储器实际上并不存在\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttcfvk68w0\u0026#34;,\u0026#34;created\u0026#34;:1717766334250,\u0026#34;text\u0026#34;:\u0026#34;请求分页管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttg8qguxs0\u0026#34;,\u0026#34;created\u0026#34;:1717766632161,\u0026#34;text\u0026#34;:\u0026#34;页表机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tth3jqsww0\u0026#34;,\u0026#34;created\u0026#34;:1717766699235,\u0026#34;text\u0026#34;:\u0026#34;页号，物理块号，状态位，访问字段，修改位，外存地址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttgev7vkw0\u0026#34;,\u0026#34;created\u0026#34;:1717766645509,\u0026#34;text\u0026#34;:\u0026#34;缺页中断机构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tx886y2ug0\u0026#34;,\u0026#34;created\u0026#34;:1717777288507,\u0026#34;text\u0026#34;:\u0026#34;属于内部异常\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttgnz2a200\u0026#34;,\u0026#34;created\u0026#34;:1717766665333,\u0026#34;text\u0026#34;:\u0026#34;地址变换机构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttcgrj9q00\u0026#34;,\u0026#34;created\u0026#34;:1717766336183,\u0026#34;text\u0026#34;:\u0026#34;页框分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txb3omng80\u0026#34;,\u0026#34;created\u0026#34;:1717777513785,\u0026#34;text\u0026#34;:\u0026#34;给一个进程分配的页框的集合就是驻留集\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txe3otbds0\u0026#34;,\u0026#34;created\u0026#34;:1717777748888,\u0026#34;text\u0026#34;:\u0026#34;内存置换分配方案\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txf9b93sw0\u0026#34;,\u0026#34;created\u0026#34;:1717777839493,\u0026#34;text\u0026#34;:\u0026#34;固定分配局部置换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txfagxulc0\u0026#34;,\u0026#34;created\u0026#34;:1717777842014,\u0026#34;text\u0026#34;:\u0026#34;可变分配局部置换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txfbf3nns0\u0026#34;,\u0026#34;created\u0026#34;:1717777844080,\u0026#34;text\u0026#34;:\u0026#34;可变分配全局分配\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttdja05ps0\u0026#34;,\u0026#34;created\u0026#34;:1717766420018,\u0026#34;text\u0026#34;:\u0026#34;抖动与工作集\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tyaa3ltgw0\u0026#34;,\u0026#34;created\u0026#34;:1717780270497,\u0026#34;text\u0026#34;:\u0026#34;刚刚换入的页面又要换出内存，刚刚换出的页面又要换入内存就叫抖动\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tymbtisd40\u0026#34;,\u0026#34;created\u0026#34;:1717781214611,\u0026#34;text\u0026#34;:\u0026#34;工作集指段时间间隔内，进程要访问的页面集合\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttdzb1ca00\u0026#34;,\u0026#34;created\u0026#34;:1717766454909,\u0026#34;text\u0026#34;:\u0026#34;内存映射文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txom40elc0\u0026#34;,\u0026#34;created\u0026#34;:1717778572631,\u0026#34;text\u0026#34;:\u0026#34;页面置换算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txoucoz3k0\u0026#34;,\u0026#34;created\u0026#34;:1717778590570,\u0026#34;text\u0026#34;:\u0026#34;最佳置换算法OPT\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txtaxyxzk0\u0026#34;,\u0026#34;created\u0026#34;:1717778940142,\u0026#34;text\u0026#34;:\u0026#34;选择淘汰的是最长时间内不再访问的页面\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txtc9ddjc0\u0026#34;,\u0026#34;created\u0026#34;:1717778943008,\u0026#34;text\u0026#34;:\u0026#34;理想的算法，还未实现\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txovn4cu00\u0026#34;,\u0026#34;created\u0026#34;:1717778593378,\u0026#34;text\u0026#34;:\u0026#34;先进先出页面置换算法FIFO\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txvcsgyew0\u0026#34;,\u0026#34;created\u0026#34;:1717779100891,\u0026#34;text\u0026#34;:\u0026#34;淘汰的页面是最早进来的\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txwt6aq2o0\u0026#34;,\u0026#34;created\u0026#34;:1717779214920,\u0026#34;text\u0026#34;:\u0026#34; 会出现Belady异常（当为进程分配的物理块增加时，缺页次数不减反而增的现象）\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txowv6uv40\u0026#34;,\u0026#34;created\u0026#34;:1717778596042,\u0026#34;text\u0026#34;:\u0026#34;最近最久未使用置换算法LRU\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ty05ebe7c0\u0026#34;,\u0026#34;created\u0026#34;:1717779476619,\u0026#34;text\u0026#34;:\u0026#34;LRU选择淘汰的页面是最近最长时间没有使用的页面\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:6.999999791383743,\u0026#34;y\u0026#34;:1.999999940395469}},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ty06gv1iw0\u0026#34;,\u0026#34;created\u0026#34;:1717779478950,\u0026#34;text\u0026#34;:\u0026#34;堆栈的算法，不会出现Belady现象\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txrb89u5c0\u0026#34;,\u0026#34;created\u0026#34;:1717778784037,\u0026#34;text\u0026#34;:\u0026#34;时钟算法CLOCK NRU算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tygp02atc0\u0026#34;,\u0026#34;created\u0026#34;:1717780773119,\u0026#34;text\u0026#34;:\u0026#34;操作系统中的置换算法，尽可能保留访问过的页面，而淘汰未访问的页面\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtk0ufheg0\u0026#34;,\u0026#34;created\u0026#34;:1717056008746,\u0026#34;text\u0026#34;:\u0026#34;文件管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muw7q4q3k0\u0026#34;,\u0026#34;created\u0026#34;:1717059785204,\u0026#34;text\u0026#34;:\u0026#34;文件系统基础\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugi2uxq9c0\u0026#34;,\u0026#34;created\u0026#34;:1717831661627,\u0026#34;text\u0026#34;:\u0026#34;文件的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugjbl6dcg0\u0026#34;,\u0026#34;created\u0026#34;:1717831758992,\u0026#34;text\u0026#34;:\u0026#34;文件是以硬盘为载体的存储在计算机的信息集合\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugk0zgtfs0\u0026#34;,\u0026#34;created\u0026#34;:1717831814275,\u0026#34;text\u0026#34;:\u0026#34;文件的基本结构分为数据项，记录，文件（自底向上的方定义）\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugl8zy0o80\u0026#34;,\u0026#34;created\u0026#34;:1717831910083,\u0026#34;text\u0026#34;:\u0026#34;文件的属性名称，类型，所有者，创建者，位置，大小等等\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugmm4la3k0\u0026#34;,\u0026#34;created\u0026#34;:1717832017026,\u0026#34;text\u0026#34;:\u0026#34;文件控制块与索引节点\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugnicnr1k0\u0026#34;,\u0026#34;created\u0026#34;:1717832087171,\u0026#34;text\u0026#34;:\u0026#34;FCB即是文件控制块,FCB的有序集合即为目录，一个FCB即是一个文件目录项\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugoc4b5u00\u0026#34;,\u0026#34;created\u0026#34;:1717832151970,\u0026#34;text\u0026#34;:\u0026#34;在文件目录的每个目录项由文件名和相应的索引结点构成\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uguspumjc0\u0026#34;,\u0026#34;created\u0026#34;:1717832658286,\u0026#34;text\u0026#34;:\u0026#34;文件的操作\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugvm2hq080\u0026#34;,\u0026#34;created\u0026#34;:1717832722177,\u0026#34;text\u0026#34;:\u0026#34;创建，删除，读写文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugw1a8u9k0\u0026#34;,\u0026#34;created\u0026#34;:1717832755297,\u0026#34;text\u0026#34;:\u0026#34;文件的打开与关闭open与close函数\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugxykko940\u0026#34;,\u0026#34;created\u0026#34;:1717832906120,\u0026#34;text\u0026#34;:\u0026#34;文件的保护\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugy6aycsw0\u0026#34;,\u0026#34;created\u0026#34;:1717832922952,\u0026#34;text\u0026#34;:\u0026#34;控制用户对文件的访问类型，口令，密码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugyy3uyg00\u0026#34;,\u0026#34;created\u0026#34;:1717832983473,\u0026#34;text\u0026#34;:\u0026#34;文件的逻辑结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugz7yop340\u0026#34;,\u0026#34;created\u0026#34;:1717833004928,\u0026#34;text\u0026#34;:\u0026#34;无结构文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzn60tug0\u0026#34;,\u0026#34;created\u0026#34;:1717833038024,\u0026#34;text\u0026#34;:\u0026#34;流式文件，由字符流构成的文件\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzhzzug00\u0026#34;,\u0026#34;created\u0026#34;:1717833026775,\u0026#34;text\u0026#34;:\u0026#34;有结构文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzvw9d2g0\u0026#34;,\u0026#34;created\u0026#34;:1717833057024,\u0026#34;text\u0026#34;:\u0026#34;顺序文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh2k0ouls0\u0026#34;,\u0026#34;created\u0026#34;:1717833266263,\u0026#34;text\u0026#34;:\u0026#34;串结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh2qdgp2w0\u0026#34;,\u0026#34;created\u0026#34;:1717833280096,\u0026#34;text\u0026#34;:\u0026#34;顺序结构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh13tpgv40\u0026#34;,\u0026#34;created\u0026#34;:1717833152648,\u0026#34;text\u0026#34;:\u0026#34;索引文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh3tg8qyo0\u0026#34;,\u0026#34;created\u0026#34;:1717833365159,\u0026#34;text\u0026#34;:\u0026#34;索引表(本身也是一个定长记录的文件)和逻辑文件\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh14qe6iw0\u0026#34;,\u0026#34;created\u0026#34;:1717833154625,\u0026#34;text\u0026#34;:\u0026#34;索引顺序文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh5q7a4yw0\u0026#34;,\u0026#34;created\u0026#34;:1717833514815,\u0026#34;text\u0026#34;:\u0026#34;索引表（同一个组的关键字可以无序，不同组的关键字必须有序)和逻辑文件(检索时，首先查找索引表，找改记录所在的组，然后在该组中使用顺序查找）\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhbp700n40\u0026#34;,\u0026#34;created\u0026#34;:1717833982806,\u0026#34;text\u0026#34;:\u0026#34;物理结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhbsda8dc0\u0026#34;,\u0026#34;created\u0026#34;:1717833989716,\u0026#34;text\u0026#34;:\u0026#34;连续分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhh7bauds0\u0026#34;,\u0026#34;created\u0026#34;:1717834414069,\u0026#34;text\u0026#34;:\u0026#34;连续分配要求每个文件在磁盘中占有连续的块\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhj7xn5dk0\u0026#34;,\u0026#34;created\u0026#34;:1717834572148,\u0026#34;text\u0026#34;:\u0026#34;链接分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhjybm3u00\u0026#34;,\u0026#34;created\u0026#34;:1717834629589,\u0026#34;text\u0026#34;:\u0026#34;隐式链接\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhl03t6h40\u0026#34;,\u0026#34;created\u0026#34;:1717834711835,\u0026#34;text\u0026#34;:\u0026#34;目录项含有文件第一块的指针和最后一块的指针\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhke7td1c0\u0026#34;,\u0026#34;created\u0026#34;:1717834664188,\u0026#34;text\u0026#34;:\u0026#34;显式链接\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhmnflejk0\u0026#34;,\u0026#34;created\u0026#34;:1717834840978,\u0026#34;text\u0026#34;:\u0026#34;有个FAT文件分配表\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhng51gjc0\u0026#34;,\u0026#34;created\u0026#34;:1717834903467,\u0026#34;text\u0026#34;:\u0026#34;索引分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhqqjms280\u0026#34;,\u0026#34;created\u0026#34;:1717835161209,\u0026#34;text\u0026#34;:\u0026#34;单级索引分配方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uicft1gv40\u0026#34;,\u0026#34;created\u0026#34;:1717836861845,\u0026#34;text\u0026#34;:\u0026#34;多级索引分配方式\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwf0rg0g0\u0026#34;,\u0026#34;created\u0026#34;:1717059801084,\u0026#34;text\u0026#34;:\u0026#34;目录\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujic276f40\u0026#34;,\u0026#34;created\u0026#34;:1717840144987,\u0026#34;text\u0026#34;:\u0026#34;目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmpupnag0\u0026#34;,\u0026#34;created\u0026#34;:1717840488466,\u0026#34;text\u0026#34;:\u0026#34;单级目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujoelze8g0\u0026#34;,\u0026#34;created\u0026#34;:1717840620721,\u0026#34;text\u0026#34;:\u0026#34;实现了按名存取，但不能让文件重名，查找速度慢\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmyipuow0\u0026#34;,\u0026#34;created\u0026#34;:1717840507331,\u0026#34;text\u0026#34;:\u0026#34;两级目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukik9lkbs0\u0026#34;,\u0026#34;created\u0026#34;:1717842983958,\u0026#34;text\u0026#34;:\u0026#34;主文件目录和用户文件目录，缺少灵活性，不能对文件分类\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujnac65qg0\u0026#34;,\u0026#34;created\u0026#34;:1717840533057,\u0026#34;text\u0026#34;:\u0026#34;树形目录结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujnh3vt340\u0026#34;,\u0026#34;created\u0026#34;:1717840547793,\u0026#34;text\u0026#34;:\u0026#34;无环图目录结构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujictumtk0\u0026#34;,\u0026#34;created\u0026#34;:1717840146659,\u0026#34;text\u0026#34;:\u0026#34;目录操作\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukmbk1zy80\u0026#34;,\u0026#34;created\u0026#34;:1717843278456,\u0026#34;text\u0026#34;:\u0026#34;搜索，创建文件，删除文件，创建目录，删除目录\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujidl8r7c0\u0026#34;,\u0026#34;created\u0026#34;:1717840148315,\u0026#34;text\u0026#34;:\u0026#34;目录实现\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukl4z67ig0\u0026#34;,\u0026#34;created\u0026#34;:1717843185769,\u0026#34;text\u0026#34;:\u0026#34;线性列表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukl5o1sbk0\u0026#34;,\u0026#34;created\u0026#34;:1717843187273,\u0026#34;text\u0026#34;:\u0026#34;哈希表\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmeraafc0\u0026#34;,\u0026#34;created\u0026#34;:1717840464314,\u0026#34;text\u0026#34;:\u0026#34;文件共享\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uknehqk4w0\u0026#34;,\u0026#34;created\u0026#34;:1717843363210,\u0026#34;text\u0026#34;:\u0026#34;基于索引结点的共享方式(硬链接)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uknff2mo00\u0026#34;,\u0026#34;created\u0026#34;:1717843365226,\u0026#34;text\u0026#34;:\u0026#34;利用符号链实现文件共享（软链接)\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwiun2zs0\u0026#34;,\u0026#34;created\u0026#34;:1717059809421,\u0026#34;text\u0026#34;:\u0026#34;文件系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukzqnyjs00\u0026#34;,\u0026#34;created\u0026#34;:1717844330078,\u0026#34;text\u0026#34;:\u0026#34;文件系统结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul28r06ew0\u0026#34;,\u0026#34;created\u0026#34;:1717844526173,\u0026#34;text\u0026#34;:\u0026#34;应用程序\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul2kjb7fk0\u0026#34;,\u0026#34;created\u0026#34;:1717844551829,\u0026#34;text\u0026#34;:\u0026#34;逻辑文件系统\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul2r6se0w0\u0026#34;,\u0026#34;created\u0026#34;:1717844566309,\u0026#34;text\u0026#34;:\u0026#34;文件组织模块\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul30ud3yg0\u0026#34;,\u0026#34;created\u0026#34;:1717844587326,\u0026#34;text\u0026#34;:\u0026#34;基本文件系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul38nf9iw0\u0026#34;,\u0026#34;created\u0026#34;:1717844604320,\u0026#34;text\u0026#34;:\u0026#34;I/O控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul3kyuv7c0\u0026#34;,\u0026#34;created\u0026#34;:1717844631133,\u0026#34;text\u0026#34;:\u0026#34;设备\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukzrogwd40\u0026#34;,\u0026#34;created\u0026#34;:1717844332286,\u0026#34;text\u0026#34;:\u0026#34;文件系统布局\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul852svt40\u0026#34;,\u0026#34;created\u0026#34;:1717844988364,\u0026#34;text\u0026#34;:\u0026#34;文件系统在磁盘中的结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul99jfe9k0\u0026#34;,\u0026#34;created\u0026#34;:1717845076440,\u0026#34;text\u0026#34;:\u0026#34;主引导记录\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulbpas9gw0\u0026#34;,\u0026#34;created\u0026#34;:1717845267475,\u0026#34;text\u0026#34;:\u0026#34;位于磁盘的0号扇区，用来引导计算机\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulb3a5p5c0\u0026#34;,\u0026#34;created\u0026#34;:1717845219548,\u0026#34;text\u0026#34;:\u0026#34;引导块\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uldn0hhkg0\u0026#34;,\u0026#34;created\u0026#34;:1717845419227,\u0026#34;text\u0026#34;:\u0026#34;负责启动该分区中的操作系统，分区引导扇区\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulb43njo80\u0026#34;,\u0026#34;created\u0026#34;:1717845221331,\u0026#34;text\u0026#34;:\u0026#34;超级块\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulf2cx09k0\u0026#34;,\u0026#34;created\u0026#34;:1717845530994,\u0026#34;text\u0026#34;:\u0026#34;包含文件系统的所有信息\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulh2cnigo0\u0026#34;,\u0026#34;created\u0026#34;:1717845687707,\u0026#34;text\u0026#34;:\u0026#34;文件系统中空闲块的信息\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul85v3o9s0\u0026#34;,\u0026#34;created\u0026#34;:1717844990075,\u0026#34;text\u0026#34;:\u0026#34;文件系统在内存中的结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulhx0bxk80\u0026#34;,\u0026#34;created\u0026#34;:1717845754442,\u0026#34;text\u0026#34;:\u0026#34;内存中的安装表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uliawdwao0\u0026#34;,\u0026#34;created\u0026#34;:1717845784678,\u0026#34;text\u0026#34;:\u0026#34;内存中目录结构的缓存\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uljlgcgts0\u0026#34;,\u0026#34;created\u0026#34;:1717845886017,\u0026#34;text\u0026#34;:\u0026#34;整个系统的打开文件表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uljwpqr5s0\u0026#34;,\u0026#34;created\u0026#34;:1717845910530,\u0026#34;text\u0026#34;:\u0026#34;每个进程的打开文件表\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul0kgov1s0\u0026#34;,\u0026#34;created\u0026#34;:1717844394942,\u0026#34;text\u0026#34;:\u0026#34;外存空闲空间管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls2f5s280\u0026#34;,\u0026#34;created\u0026#34;:1717846549864,\u0026#34;text\u0026#34;:\u0026#34;空闲表法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls3bpgvs0\u0026#34;,\u0026#34;created\u0026#34;:1717846551832,\u0026#34;text\u0026#34;:\u0026#34;空闲链表法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulxfkoyps0\u0026#34;,\u0026#34;created\u0026#34;:1717846970318,\u0026#34;text\u0026#34;:\u0026#34;空闲盘块链\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulxgi1bpc0\u0026#34;,\u0026#34;created\u0026#34;:1717846972334,\u0026#34;text\u0026#34;:\u0026#34;空闲盘区链\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls4iudgo0\u0026#34;,\u0026#34;created\u0026#34;:1717846554440,\u0026#34;text\u0026#34;:\u0026#34;位示图法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls5vegug0\u0026#34;,\u0026#34;created\u0026#34;:1717846557376,\u0026#34;text\u0026#34;:\u0026#34;成组链接法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtk24mrmo0\u0026#34;,\u0026#34;created\u0026#34;:1717056011540,\u0026#34;text\u0026#34;:\u0026#34;输入输出管理（I/O管理）\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:32.99999901652325,\u0026#34;y\u0026#34;:9.99999970197672}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwpkhz3k0\u0026#34;,\u0026#34;created\u0026#34;:1717059824045,\u0026#34;text\u0026#34;:\u0026#34;io管理概述\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5qwj7njc0\u0026#34;,\u0026#34;created\u0026#34;:1717902880882,\u0026#34;text\u0026#34;:\u0026#34;i/o设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5tgfero00\u0026#34;,\u0026#34;created\u0026#34;:1717903080916,\u0026#34;text\u0026#34;:\u0026#34;块设备，字符设备（按照信息交换的单位分类）低速，中速，高速（按照设备的传速速率分类）存储设备，输入/输出设备（按照设备的使用特性分类）\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5ts1cwww0\u0026#34;,\u0026#34;created\u0026#34;:1717903106188,\u0026#34;text\u0026#34;:\u0026#34;i/o接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v61r3m4880\u0026#34;,\u0026#34;created\u0026#34;:1717903731061,\u0026#34;text\u0026#34;:\u0026#34;i/o接口是cpu与设备之间的接口，以实现设备与计算机之间的信息交换\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5ravnckg0\u0026#34;,\u0026#34;created\u0026#34;:1717902912109,\u0026#34;text\u0026#34;:\u0026#34;i/o控制方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64qljlhs0\u0026#34;,\u0026#34;created\u0026#34;:1717903965061,\u0026#34;text\u0026#34;:\u0026#34;程序直接控制方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64sg15dk0\u0026#34;,\u0026#34;created\u0026#34;:1717903969081,\u0026#34;text\u0026#34;:\u0026#34;中断驱动方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64uivqyw0\u0026#34;,\u0026#34;created\u0026#34;:1717903973607,\u0026#34;text\u0026#34;:\u0026#34;DMA方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7iz3n1oo0\u0026#34;,\u0026#34;created\u0026#34;:1717907901778,\u0026#34;text\u0026#34;:\u0026#34;数据传输以\\\u0026#34;块\\\u0026#34;为单位，cpu介入的频率降低\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64wtfu680\u0026#34;,\u0026#34;created\u0026#34;:1717903978599,\u0026#34;text\u0026#34;:\u0026#34;通道控制方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7ktd9ekg0\u0026#34;,\u0026#34;created\u0026#34;:1717908046027,\u0026#34;text\u0026#34;:\u0026#34;弱鸡版cpu\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5rkz86600\u0026#34;,\u0026#34;created\u0026#34;:1717902934093,\u0026#34;text\u0026#34;:\u0026#34;i/o软件层次结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65a25lq00\u0026#34;,\u0026#34;created\u0026#34;:1717904007424,\u0026#34;text\u0026#34;:\u0026#34;用户层软件\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7m8y51800\u0026#34;,\u0026#34;created\u0026#34;:1717908158305,\u0026#34;text\u0026#34;:\u0026#34;设备独立性软件\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7maal1c80\u0026#34;,\u0026#34;created\u0026#34;:1717908161235,\u0026#34;text\u0026#34;:\u0026#34;设备驱动程序\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7mc4k3k80\u0026#34;,\u0026#34;created\u0026#34;:1717908165224,\u0026#34;text\u0026#34;:\u0026#34;中断处理程序\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7mdgqt8o0\u0026#34;,\u0026#34;created\u0026#34;:1717908168137,\u0026#34;text\u0026#34;:\u0026#34;硬件\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5skmz5ko0\u0026#34;,\u0026#34;created\u0026#34;:1717903011717,\u0026#34;text\u0026#34;:\u0026#34;应用程序i/o接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65hbgjnk0\u0026#34;,\u0026#34;created\u0026#34;:1717904023224,\u0026#34;text\u0026#34;:\u0026#34;i/o接口的分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zhgwbzk0\u0026#34;,\u0026#34;created\u0026#34;:1717909195588,\u0026#34;text\u0026#34;:\u0026#34;字符设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zilxh4g0\u0026#34;,\u0026#34;created\u0026#34;:1717909198069,\u0026#34;text\u0026#34;:\u0026#34;块设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zjj0ffc0\u0026#34;,\u0026#34;created\u0026#34;:1717909200069,\u0026#34;text\u0026#34;:\u0026#34;网络设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65jelo1c0\u0026#34;,\u0026#34;created\u0026#34;:1717904027768,\u0026#34;text\u0026#34;:\u0026#34;阻塞i/o和非阻塞i/o\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muxfg1y1k0\u0026#34;,\u0026#34;created\u0026#34;:1717059880373,\u0026#34;text\u0026#34;:\u0026#34;设备独立性软件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v89pjmrp40\u0026#34;,\u0026#34;created\u0026#34;:1717909996809,\u0026#34;text\u0026#34;:\u0026#34;磁盘高速缓存在逻辑上属于磁盘，在物理上属于内存\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v89snxy400\u0026#34;,\u0026#34;created\u0026#34;:1717910003600,\u0026#34;text\u0026#34;:\u0026#34;缓冲区\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bqry6rc0\u0026#34;,\u0026#34;created\u0026#34;:1717910156217,\u0026#34;text\u0026#34;:\u0026#34;单缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8brrntqg0\u0026#34;,\u0026#34;created\u0026#34;:1717910158377,\u0026#34;text\u0026#34;:\u0026#34;双缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bv5nsc80\u0026#34;,\u0026#34;created\u0026#34;:1717910165753,\u0026#34;text\u0026#34;:\u0026#34;循环缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bw22ce00\u0026#34;,\u0026#34;created\u0026#34;:1717910167713,\u0026#34;text\u0026#34;:\u0026#34;缓冲池\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8d7drgy00\u0026#34;,\u0026#34;created\u0026#34;:1717910270729,\u0026#34;text\u0026#34;:\u0026#34;设备分配与回收\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m2931lk0\u0026#34;,\u0026#34;created\u0026#34;:1717910964839,\u0026#34;text\u0026#34;:\u0026#34;设备控制表DCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m36o7q00\u0026#34;,\u0026#34;created\u0026#34;:1717910966870,\u0026#34;text\u0026#34;:\u0026#34;控制器控制表COCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m42jsig0\u0026#34;,\u0026#34;created\u0026#34;:1717910968798,\u0026#34;text\u0026#34;:\u0026#34;通道控制表CHCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m4xeli80\u0026#34;,\u0026#34;created\u0026#34;:1717910970664,\u0026#34;text\u0026#34;:\u0026#34;系统设备表SDT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8v97igww0\u0026#34;,\u0026#34;created\u0026#34;:1717911685259,\u0026#34;text\u0026#34;:\u0026#34;SPOOLing技术(假脱机技术)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8w4zyju80\u0026#34;,\u0026#34;created\u0026#34;:1717911754460,\u0026#34;text\u0026#34;:\u0026#34;操作系统采用的一项将独占设备改造成共享设备的技术\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muxqio8kg0\u0026#34;,\u0026#34;created\u0026#34;:1717059904476,\u0026#34;text\u0026#34;:\u0026#34;磁盘与固态硬盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaa9yfftc0\u0026#34;,\u0026#34;created\u0026#34;:1717915683459,\u0026#34;text\u0026#34;:\u0026#34;磁盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vabqqlf680\u0026#34;,\u0026#34;created\u0026#34;:1717915798355,\u0026#34;text\u0026#34;:\u0026#34;磁盘是表面涂有磁性物质的物理盘片\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaajxwac00\u0026#34;,\u0026#34;created\u0026#34;:1717915705195,\u0026#34;text\u0026#34;:\u0026#34;磁盘的管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaesoqsu00\u0026#34;,\u0026#34;created\u0026#34;:1717916037690,\u0026#34;text\u0026#34;:\u0026#34;磁盘初始化\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaetd5p4g0\u0026#34;,\u0026#34;created\u0026#34;:1717916039165,\u0026#34;text\u0026#34;:\u0026#34;分区\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaeua7dn40\u0026#34;,\u0026#34;created\u0026#34;:1717916041164,\u0026#34;text\u0026#34;:\u0026#34;引导块\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaev8fs9k0\u0026#34;,\u0026#34;created\u0026#34;:1717916043234,\u0026#34;text\u0026#34;:\u0026#34;坏块\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaapd1ys00\u0026#34;,\u0026#34;created\u0026#34;:1717915716995,\u0026#34;text\u0026#34;:\u0026#34;磁盘调度算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vagm9g9zc0\u0026#34;,\u0026#34;created\u0026#34;:1717916180432,\u0026#34;text\u0026#34;:\u0026#34;磁盘的存取时间\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahffuvlk0\u0026#34;,\u0026#34;created\u0026#34;:1717916243946,\u0026#34;text\u0026#34;:\u0026#34;寻道时间跨越n条隧道的时间和磁头臂启动的时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahko3lz40\u0026#34;,\u0026#34;created\u0026#34;:1717916255329,\u0026#34;text\u0026#34;:\u0026#34;旋转延迟时间，磁头定位到读/写扇区所需要的时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahlnpa9c0\u0026#34;,\u0026#34;created\u0026#34;:1717916257481,\u0026#34;text\u0026#34;:\u0026#34;传输时间从磁盘读出或向磁盘写入数据所需的时间\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vagnzi0u80\u0026#34;,\u0026#34;created\u0026#34;:1717916184184,\u0026#34;text\u0026#34;:\u0026#34;磁盘调度算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vanvxytc00\u0026#34;,\u0026#34;created\u0026#34;:1717916750055,\u0026#34;text\u0026#34;:\u0026#34;先来先服务算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaph66zu00\u0026#34;,\u0026#34;created\u0026#34;:1717916874629,\u0026#34;text\u0026#34;:\u0026#34;最短寻道时间优先算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1var4hmhjk0\u0026#34;,\u0026#34;created\u0026#34;:1717917003750,\u0026#34;text\u0026#34;:\u0026#34;扫描算法(SCAN),电梯调度算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vasg972080\u0026#34;,\u0026#34;created\u0026#34;:1717917107726,\u0026#34;text\u0026#34;:\u0026#34;循环扫描算法(C-SCAN)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vau0hcpig0\u0026#34;,\u0026#34;created\u0026#34;:1717917230119,\u0026#34;text\u0026#34;:\u0026#34;SCAN算法的改进教LOCK调度\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vautuz4l40\u0026#34;,\u0026#34;created\u0026#34;:1717917294069,\u0026#34;text\u0026#34;:\u0026#34;C-SCAN算法的改进叫作C-LOCK调度\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vab7xcbf40\u0026#34;,\u0026#34;created\u0026#34;:1717915757404,\u0026#34;text\u0026#34;:\u0026#34;固态硬盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vayl077k80\u0026#34;,\u0026#34;created\u0026#34;:1717917588251,\u0026#34;text\u0026#34;:\u0026#34;是一种基于闪存技术的存储器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb048dilc0\u0026#34;,\u0026#34;created\u0026#34;:1717917708468,\u0026#34;text\u0026#34;:\u0026#34;磨损均衡\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb0tnwjh40\u0026#34;,\u0026#34;created\u0026#34;:1717917763827,\u0026#34;text\u0026#34;:\u0026#34;动态磨损均衡\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb0uliqw00\u0026#34;,\u0026#34;created\u0026#34;:1717917765859,\u0026#34;text\u0026#34;:\u0026#34;静态磨损均衡\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]},\u0026#34;template\u0026#34;:\u0026#34;structure\u0026#34;,\u0026#34;theme\u0026#34;:\u0026#34;fresh-blue\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.4.33\u0026#34;} ","date":"2024-10-09T12:20:39+08:00","image":"https://getshhi.github.io/jk7.png","permalink":"https://getshhi.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","title":"计算机操作系统思维导图"},{"content":"实现原理分析 HashMap的底层是红黑树,数组,链表;默认其初始容量为16;当put时首先就会进入到putVal这个函数,到这个函数中首先先判断底层的table是否为空或者长度为0,若是则会扩容到16,然后根据key值计算出table值,若table值为空,则直接加入到这个table位置上;若不是则会判断加入的key和旧的key是否是同一对象或者euqals相同,若是,则不用加了;若不是，先判断是否是为红黑树,如果是,则按照红黑树的逻辑加,若不是则会进入死循环,死循环中如果有key相同就只是替换value,如果不是则尾插到链表末尾,若单个链表超过8个,则会进行树化,在树化这个函数中先判断容量是否超过64,如果是则树化否则扩容。最后判断是否需要扩容。\n源码分析 首先会进入put函数 1 2 3 4 5 public V put(K key, V value) { //传入其哈希值和key和value //(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16) 计算key的hash值,让高位和低位进行异或 return putVal(hash(key), key, value, false, true); } 然后执行putval方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//辅助变量 //如果底层的table数组为null,或者length = 0,就扩容到16 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //取出hash值对应的table的索引位置的Node,如果为空,则直接创建一个新的节点,填入key和value,加入该位置 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; // 辅助变量 //如果table的索引位置的key的hash相同和新的key的hash值相同 //并满足(table现有的结点的key和添加的key是同一对象 || equals返回真,就认为不能加这个k-v) if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //如果当前的table的已有的Node是红黑树,就按照红黑树的方式处理 e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { //如果找到的结点，后面是链表，就循环比较 for (int binCount = 0; ; ++binCount) {//死循环 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //加入后，判断当前链表的个数，是否已经到达八个，到八个，后面就调用treeifyBin方法进行红黑树的转化,不进行树化 //其中树化里面会判断是否超过64,没有就扩容 /* if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); */ if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果在循环中相同就只是替换value if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //替换value afterNodeAccess(e); return oldValue; } } ++modCount; //每次加入一个都加一 if (++size \u0026gt; threshold) //判断是否需要扩容 resize(); afterNodeInsertion(evict); return null; } 结论总结 HashMap底层维护了Node类型的数组table,默认为null。\n当创建对象时,将加载因子初始化为0.75。\n当添加key-val时,通过key的哈希值得到在table的索引,然后判断索引是否有元素,如果没有元素直接加入。如果索引处有元素,则判断key值是否相同,若相同,则直接替换value;如果不相同,则会判断是树结构还是链表结构,分别进行相应的处理。如果添加时发现容量不够,则会进行扩容。\n第一次添加，则需要扩容table容量为16，临界值为12(16 * 0.75)\n以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推。\n在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，并且table的大小 \u0026gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化\n","date":"2024-10-03T16:55:42+08:00","image":"https://getshhi.github.io/jk6.png","permalink":"https://getshhi.github.io/p/hashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93/","title":"HashMap的实现原理与总结"},{"content":"题目分析 力扣题目链接\n要统计二叉树的节点个数，一般是编历一遍二叉树直接统计(可以用后序遍历或者层序遍历，这里就不说了)。\n而这个是完全二叉树,我们可以根据完全二叉树的特点进行求解。\n完全二叉树的定义如下:在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面的节点都集中在该层最左边的若干位置。若最低层为第h层，则该层包含1-2h个节点。\n则可以设完全二叉树有 h 层，则其前h-1的节点都是满的，共有节点 2^(h-1) - 1 个节点。而最后一层最少有 1 个节点，最多有 2^(h-1) 个节点。因此 h 层的完全二叉树的节点个数范围为：[2^(h-1) - 1 + 1, 2^(h-1) - 1 + 2^(h-1)] = [2^(h-1), 2^h - 1]【或 [2^(h-1), 2^h) 】\n位运算 我们把每个节点编号转成二进制，可以发现以下几个规律：\n第 h 层的节点编号的二进制刚好有 h 位； 定义左子节点为 0， 右子节点为 1 。那么每一个节点编号的二进制从高位到低位刚好表示根节点到这个节点的路径。【根节点为最高位，始终为 1】即节点编号的二进制为节点路径的编码； 则可以发现第h层的节点编号一定是有h位。我们可以根据已知的节点走一遍节点路径，来查找这个节点是否存在。\n代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int countNodes(TreeNode root) { if(root == null) //如果根结点为null，直接返回0 return 0; TreeNode node = root; int leavl = 0; while(node != null){ //统计完全二叉树的层数 leavl++; node = node.left; } int min = 1 \u0026lt;\u0026lt; (leavl - 1); //最小可以有多少 int max = ( 1 \u0026lt;\u0026lt; leavl) - 1; //最大可以有多少 int ans = 0; //存储结果 while(min \u0026lt;= max){ int middle = min + ((max - min) \u0026gt;\u0026gt; 1); if(check(middle, root, leavl)){ ans = middle; min = middle + 1; //利用二分确定结果 } else{ max = middle - 1; } } return ans; } public boolean check(int middle, TreeNode root, int leavl){ int jk = 1 \u0026lt;\u0026lt; (leavl - 2); //抛去根节点(因为根节点是1) while(jk \u0026gt; 0){ if((jk \u0026amp; middle) == 0) root = root.left; //为0说明在左子树上 else root = root.right; //为1说明在右子树上 jk \u0026gt;\u0026gt;= 1; //逐层进行查找 } return root != null; //为空则说明不存在 } } 本文引自于https://leetcode.cn/problems/count-complete-tree-nodes/solutions/2456908/javapython3cer-fen-cha-zhao-wei-yun-suan-idof/\n","date":"2024-10-03T11:25:04+08:00","image":"https://getshhi.github.io/jk8.png","permalink":"https://getshhi.github.io/p/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E5%8A%9B%E6%89%A3/","title":"完全二叉树的节点个数(力扣)"},{"content":"Java的网络编程 1.Java网络编程的基本概念 IP 地址：用于标识网络中的计算机。\n端口号：用于标识计算机上的具体应用程序或进程。\nSocket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n协议：网络通信的规则，如 TCP（传输控制协议）和 UDP（用户数据报协议）。\n2.网络编程的核心类 Socket：用于创建客户端套接字。\nServerSocket：用于创建服务器套接字。\nDatagramSocket：用于创建支持 UDP 协议的套接字。\nURL：用于处理统一资源定位符。\nURLConnection：用于读取和写入 URL 引用的资源。\n3.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.io.*; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TCPServer { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { while (true) { Socket socket = serverSocket.accept(); new ServerThread(socket).start(); //synchronized } } catch (IOException e) { e.printStackTrace(); } } } class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket){ this.socket = socket; } public void start(){ try(PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))){ String message = in.readLine(); //接受消息 out.println(\u0026#34;Hello Server~\u0026#34;); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (IOException e) { e.printStackTrace(); } } } import java.io.*; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TCPClient { public static void main(String[] args) { try(Socket socket = new Socket(\u0026#34;localhost\u0026#34;,8080); PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) { out.println(\u0026#34;Hello Server~\u0026#34;); String message = in.readLine(); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (Exception e) { e.printStackTrace(); } } } 4.总结 IP地址：外卖员要送餐到的大楼（例如：腾讯大楼）。\n端口号：外卖员要到大楼里的具体房间（例如：1001）。\nSocket：外卖员通过手机（Socket）与我们通信，告知外卖已到。\n协议：我们默认使用中文对话。\n","date":"2024-09-27T12:33:05+08:00","image":"https://getshhi.github.io/kj3.png","permalink":"https://getshhi.github.io/p/javaweb/","title":"JavaWeb"}]