[{"content":"实现原理分析 HashMap的底层是红黑树,数组,链表;默认其初始容量为16;当put时首先就会进入到putVal这个函数,到这个函数中首先先判断底层的table是否为空或者长度为0,若是则会扩容到16,然后根据key值计算出table值,若table值为空,则直接加入到这个table位置上;若不是则会判断加入的key和旧的key是否是同一对象或者euqals相同,若是,则不用加了;若不是，先判断是否是为红黑树,如果是,则按照红黑树的逻辑加,若不是则会进入死循环,死循环中如果有key相同就只是替换value,如果不是则尾插到链表末尾,若单个链表超过8个,则会进行树化,在树化这个函数中先判断容量是否超过64,如果是则树化否则扩容。最后判断是否需要扩容。\n源码分析 首先会进入put函数 1 2 3 4 5 public V put(K key, V value) { //传入其哈希值和key和value //(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16) 计算key的hash值,让高位和低位进行异或 return putVal(hash(key), key, value, false, true); } 然后执行putval方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//辅助变量 //如果底层的table数组为null,或者length = 0,就扩容到16 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //取出hash值对应的table的索引位置的Node,如果为空,则直接创建一个新的节点,填入key和value,加入该位置 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; // 辅助变量 //如果table的索引位置的key的hash相同和新的key的hash值相同 //并满足(table现有的结点的key和添加的key是同一对象 || equals返回真,就认为不能加这个k-v) if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //如果当前的table的已有的Node是红黑树,就按照红黑树的方式处理 e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { //如果找到的结点，后面是链表，就循环比较 for (int binCount = 0; ; ++binCount) {//死循环 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //加入后，判断当前链表的个数，是否已经到达八个，到八个，后面就调用treeifyBin方法进行红黑树的转化,不进行树化 //其中树化里面会判断是否超过64,没有就扩容 /* if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); */ if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果在循环中相同就只是替换value if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //替换value afterNodeAccess(e); return oldValue; } } ++modCount; //每次加入一个都加一 if (++size \u0026gt; threshold) //判断是否需要扩容 resize(); afterNodeInsertion(evict); return null; } 结论总结 HashMap底层维护了Node类型的数组table,默认为null。\n当创建对象时,将加载因子初始化为0.75。\n当添加key-val时,通过key的哈希值得到在table的索引,然后判断索引是否有元素,如果没有元素直接加入。如果索引处有元素,则判断key值是否相同,若相同,则直接替换value;如果不相同,则会判断是树结构还是链表结构,分别进行相应的处理。如果添加发现容量不够,则会进行扩容。\n","date":"2024-10-03T16:55:42+08:00","permalink":"https://getshhi.github.io/p/hashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93/","title":"HashMap的实现原理与总结"},{"content":"题目分析 力扣题目链接\n要统计二叉树的节点个数，一般是编历一遍二叉树直接统计(可以用后序遍历或者层序遍历，这里就不说了)。\n而这个是完全二叉树,我们可以根据完全二叉树的特点进行求解。\n完全二叉树的定义如下:在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面的节点都集中在该层最左边的若干位置。若最低层为第h层，则该层包含1-2h个节点。\n则可以设完全二叉树有 h 层，则其前h-1的节点都是满的，共有节点 2^(h-1) - 1 个节点。而最后一层最少有 1 个节点，最多有 2^(h-1) 个节点。因此 h 层的完全二叉树的节点个数范围为：[2^(h-1) - 1 + 1, 2^(h-1) - 1 + 2^(h-1)] = [2^(h-1), 2^h - 1]【或 [2^(h-1), 2^h) 】\n位运算 我们把每个节点编号转成二进制，可以发现以下几个规律：\n第 h 层的节点编号的二进制刚好有 h 位； 定义左子节点为 0， 右子节点为 1 。那么每一个节点编号的二进制从高位到低位刚好表示根节点到这个节点的路径。【根节点为最高位，始终为 1】即节点编号的二进制为节点路径的编码； 则可以发现第h层的节点编号一定是有h位。我们可以根据已知的节点走一遍节点路径，来查找这个节点是否存在。\n代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int countNodes(TreeNode root) { if(root == null) //如果根结点为null，直接返回0 return 0; TreeNode node = root; int leavl = 0; while(node != null){ //统计完全二叉树的层数 leavl++; node = node.left; } int min = 1 \u0026lt;\u0026lt; (leavl - 1); //最小可以有多少 int max = ( 1 \u0026lt;\u0026lt; leavl) - 1; //最大可以有多少 int ans = 0; //存储结果 while(min \u0026lt;= max){ int middle = min + ((max - min) \u0026gt;\u0026gt; 1); if(check(middle, root, leavl)){ ans = middle; min = middle + 1; //利用二分确定结果 } else{ max = middle - 1; } } return ans; } public boolean check(int middle, TreeNode root, int leavl){ int jk = 1 \u0026lt;\u0026lt; (leavl - 2); //抛去根节点(因为根节点是1) while(jk \u0026gt; 0){ if((jk \u0026amp; middle) == 0) root = root.left; //为0说明在左子树上 else root = root.right; //为1说明在右子树上 jk \u0026gt;\u0026gt;= 1; //逐层进行查找 } return root != null; //为空则说明不存在 } } 本文引自于https://leetcode.cn/problems/count-complete-tree-nodes/solutions/2456908/javapython3cer-fen-cha-zhao-wei-yun-suan-idof/\n","date":"2024-10-03T11:25:04+08:00","permalink":"https://getshhi.github.io/p/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E5%8A%9B%E6%89%A3/","title":"完全二叉树的节点个数(力扣)"},{"content":"docker的代理解决 这几天在docker的代理上搞了好几天，我看网上弄的教程不是太全，因此搞了好了几天才成功，特意写这个给那些有着相同的问题提供解决方案和总结自己犯过的错误。\nclash教程 首先打开clash,进入常规,然后打开局域网连接,我的端口为7890。 然后window键加r打开控制台输入ipconfig获取虚拟机的ip地址 v2rayN教程 首先打开v2rayN,进入设置，点参数设置，然后允许局域网连接(这个是在系统代理的前提上弄的)一般端口为10811 然后window键加r打开控制台输入ipconfig获取虚拟机的ip地址 最后一步(这一步都是一样的(对于这两个不同软件的代理)) docker命令 我们在docker的进程服务文件夹配置我们的代理设置，如果没有我们就新建这个文件夹：\n1 sudo mkdir /etc/systemd/system/docker.service.d 然后在docker.service.d文件夹里新建我们的代理文件proxy.conf\n1 sudo vim /etc/systemd/system/docker.service.d/proxy.conf 并把文件写如下面这个格式：\n1 2 3 [Service] Environment=\u0026#34;HTTP_PROXY=代理服务器ip:port\u0026#34; Environment=\u0026#34;HTTPS_PROXY=代理服务器ip:port\u0026#34; 保存并退出proxy.conf文件，和更改镜像源一样，重启docker，并重启daemon进程。\n1 2 sudo systemctl daemon-reload\t#重启daemon进程 sudo systemctl restart docker\t#重启docker 最后我们仍然是验证一下是否修改成功，运行\n1 docker info 在长串info信息中如果出现类似下文的内容：\n1 2 HTTP Proxy: 代理服务器ip:port HTTPS Proxy: 代理服务器ip:port 好了，可以拉取镜像了😁\n本文引自https://blog.csdn.net/Lichen0196/article/details/137355517,https://blog.csdn.net/weixin_46264846/article/details/142363390 ,https://www.jianshu.com/p/6c7abd4adc9b\n","date":"2024-10-02T11:46:05+08:00","permalink":"https://getshhi.github.io/p/%E5%9C%A8linux%E4%B8%8A%E9%83%A8%E7%BD%B2docker%E7%9A%84%E4%BB%A3%E7%90%86/","title":"在Linux上部署Docker的代理"},{"content":"java的网络编程 1.java网络编程的基本概念 IP 地址：用于标识网络中的计算机。\n端口号：用于标识计算机上的具体应用程序或进程。\nSocket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n协议：网络通信的规则，如 TCP（传输控制协议）和 UDP（用户数据报协议）。\n2.java网络编程的核心类 Socket：用于创建客户端套接字。\nServerSocket：用于创建服务器套接字。\nDatagramSocket：用于创建支持 UDP 协议的套接字。\nURL：用于处理统一资源定位符。\nURLConnection：用于读取和写入 URL 引用的资源。\n3.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.io.*; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TCPServer { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { while (true) { Socket socket = serverSocket.accept(); new ServerThread(socket).start(); //synchronized } } catch (IOException e) { e.printStackTrace(); } } } class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket){ this.socket = socket; } public void start(){ try(PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))){ String message = in.readLine(); //接受消息 out.println(\u0026#34;Hello Server~\u0026#34;); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (IOException e) { e.printStackTrace(); } } } import java.io.*; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TCPClient { public static void main(String[] args) { try(Socket socket = new Socket(\u0026#34;localhost\u0026#34;,8080); PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) { out.println(\u0026#34;Hello Server~\u0026#34;); String message = in.readLine(); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (Exception e) { e.printStackTrace(); } } } 4.总结 IP地址：外卖员要送餐到的大楼（例如：腾讯大楼）。\n端口号：外卖员要到大楼里的具体房间（例如：1001）。\nSocket：外卖员通过手机（Socket）与我们通信，告知外卖已到。\n协议：我们默认使用中文对话。\n","date":"2024-09-27T12:33:05+08:00","permalink":"https://getshhi.github.io/p/javaweb/","title":"JavaWeb"}]