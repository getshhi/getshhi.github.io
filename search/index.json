[{"content":"冲突的产生 内容冲突 Git内容冲突产生的原因是，针对版本库中某个文件的某项内容，不同的操作对其做了不同的修改，以致于在合并不同的操作时发生矛盾。比如下面的例子：\n我们在本地master分支，添加了文件hello，其内容如下： Learning English is easy and simple 然后，我们由master分支切换到一个新的分支develop，并修改hello文件内容如下： Learning English is easy \u0026amp; simple 随后将其提交到了本地develop分支。 我们又切换回master分支，并再次对hello内容进行了修改： Learning English is easy or simple 这样，当我们将develop分支合并到master分支的时候，就会出现冲突提示如下： Auto-merging hello CONFLICT (content): Merge conflict in hello Automatic merge failed; fix conflicts and then commit the result. 冲突出现的原因是，我们在develop分支和master分支上，都对hello文件的内容做了修改，这样当将develop合并到master时，Git就不确定究竟应该采用哪个修改。 树冲突 方法文件名修改造成的冲突，称为树冲突。比如，A用户把文件C改名为A，B用户把文件C改名为B，那么B合并这两个提交时，就会出现冲突：\nCONFLICT (rename/rename): Rename \u0026ldquo;C\u0026rdquo;-\u0026gt;\u0026ldquo;B\u0026rdquo; in branch \u0026ldquo;HEAD\u0026rdquo; rename Automatic merge failed; fix conflicts and then commit the result. 此时如果使用git status查看版本库的状态，会得到如下提示信息：\nYou have unmerged paths. (fix conflicts and run \u0026ldquo;git commit\u0026rdquo;) (use \u0026ldquo;git merge \u0026ndash;abort\u0026rdquo; to abort the merge) Unmerged paths: (use \u0026ldquo;git add/rm \u0026hellip;\u0026rdquo; as appropriate to mark resolution) added by them: A added by us: B both deleted: C no changes added to commit (use \u0026ldquo;git add\u0026rdquo; and/or \u0026ldquo;git commit -a\u0026rdquo;) 树冲突产生的原因是，我们将同一文件名，在不同操作中，修改为不同的名字。\n解决冲突 内容冲突 当产生内容冲突时，如果你打开冲突发生的文件，你会在冲突区域发现类似于下面的内容：\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD Learning English is easy or simple Learning English is easy \u0026amp; simple\ndevelop 这个就是我们上面所举的内容冲突的例子，冲突文件的内容。从中可以看到\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD与=======包括的是我们当前分支的内容，而=======和\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; develop之间的则是需要合并过来的内容，为了解决冲突我们可以手动解决这些冲突，也可以使用图形化工具帮助解决。如果以手动方式解决，我们可以编辑冲突区域内容为我们想要的内容，比如将其修改成如下内容：\nLearning English is easy and simple 然后再执行git add和git commit操作提交，这样就能将冲突解决了。 即解决冲突的一般过程为：\n手动编辑冲突区域； 执行git add，将编辑提交到暂存区； 执行git commit，将编辑提交到本地仓库以解决冲突。 树冲突 解决树冲突时，对于上面示例中的树冲突，如果最终决定采用文件B，我们可以采用如下方式解决：\ngit rm A git rm C git add B git commit 即从本地仓库中删除A和C文件，然后再添加B文件并最终提交。\n强制操作的分类 使用最频繁的强制操作，主要在以下几个方面：\n强制推送 如果远程的某个分支的内容需要被覆盖，这个时候就需要你进行强制推送，使用本地内容去覆盖该分支。 强制合并 如果本地分支的内容需要被远程内容覆盖，这个时候就需要强制合并远程分支内容到本地。 强制删除 如果你需要强制删除版本库、暂存区或者工作区的内容时，就需要强制删除。比如我们之前介绍的checkout，就可以使用-f参数，强制丢弃本地修改。 强制操作方法 强制推送 强制推送和普通推送的区别，就在于在末尾加上了-f参数，即： git push 远程主机名 本地分支名：远程分支名 -f 具体使用方法如下： #将本地分支强制推送到远程主机origin的master分支 git push origin master:master -f 强制合并 强制合并和普通合并的区别，也是其在末尾加上了-f参数，即： git pull 远程主机名 远程分支名：本地分支名 -f 具体使用方法示例如下： #将远程master分支强制合并到本地master分支 git pull origin master:master -f\n如何忽略文件 在Git工作区的根目录下，创建一个特殊的.gitignore文件，把要忽略的文件名或者文件名的通配符填进去，然后将.gitignore提交到本地仓库，这样Git就会在你添加或者提交时，自动忽略这些文件。\n自定义忽略文件 如果我们需要自己定义忽略哪些文件，就需要将其添加到.gitignore文件中去。你可以使用文件的全称，或者使用正则匹配的通配符。如下所示：\n忽略指定文件 HelloWrold.class\n忽略指定文件夹 bin/ bin/gen/\n忽略.class的所有文件 *.class\n忽略名称中末尾为ignore的文件夹 *ignore/\n忽略名称中间包含ignore的文件夹 ignore/\n合并远程分支的一般步骤是：\n第一步，分别获取远程分支内容到本地； 第二步，在本地将两个分支合并； 第三步，将合并后的本地分支推送到远程分支，完成合并。 具体的，以将远程develop分支合并到远程master分支为例，操作过程如下：\n获取远程develop分支到本地分支（如develop分支）。如果本地已经有分支对应远程develop分支，则可以直接在该分支上执行pull操作或者fetch/merge操作，以获取远程最新内容。否则，可以新建分支跟踪远程develop分支，并获取最新内容到本地；\n切换到master分支，并获取远程master分支的最新内容到本地；\n将本地develop分支合并到本地master分支；\n将本地master分支推送到远程master分支。\n以合并远程develop分支到远程master分支为例，其具体操作步骤如下：\n#切换到develop分支 git checkout develop #获取远程develop分支的内容到本地 git pull origin develop:develop #切换到master分支 git checkout master #拉取远程master分支内容到本地 git pull origin master #合并本地develop分支到master分支 git merge develop #将合并后的分支推送到远程master分支 git push origin master:master\nmerge和rebase的不同 merge的工作流程如下图：\n如上图所示，我们从远程仓库origin的C2版本，创建一个新的分支develop进行开发，并进行了C5、C6两次提交。之后团队中其他成员又向origin推送了两次提交C3、C4。为了合并远程分支上的新内容到本地，我们进行merge操作，将内容合并到develop之后，生成了一次新的提交C7。此时，develop分支还是一个独立的分支。\n而rebase的工作流程如下图：\nrebase又可称为‘变基’，结合上图的话，这个词就很容易理解了。即：\nC5、C6本来是在C2这次提交的基础上进行修改的；\n现在我们将这个‘基础’改为C4，即将C5、C6的提交作用到C4上去；\n在这个过程中，可能会有冲突产生，解决冲突之后就完成了rebase。\n由图可以看到，rebase完成后，源分支上的提交都不见了。\nrebase基础操作 rebase的基本操作是将某个分支的修改到指定分支，其命令格式为：\ngit rebase 基分支 源分支 其中‘基分支’是我们的新的‘基’，而‘源分支’就是需要进行变基操作的分支。这样就能实现将源分支变基到基分支。具体使用示例如下：\ngit rebase master develop 以上语句就能实现将develop变基到master分支。 如果是将当前分支变基到指定分支，则可以直接使用：\ngit rebase 基分支 这一命令默认将当前分支变基到‘基分支’。如果当前处于develop分支，则其使用示例如下：\ngit rebase master 这样也能实现将当前的develop分支rebase到master分支。\n由于变基是将修改作用到一个不同的版本上，因此很可能在rebase的过程中出现冲突。和merge一次性合并所有冲突不同的是，rebase的冲突是一个一个解决的。以上图中的rebase操作为例，需要分别解决和C3、C4的冲突。在解决rebase冲突的过程中，当解决完一个冲突的时候，使用如下命令后，才会出现下一个冲突：\ngit add -u git rebase \u0026ndash;continue 冲突全部解决完后，rebase操作就完成了。 如果在解决冲突的过程中，想放弃rebase操作，则可以使用如下命令撤销rebase操作：\ngit rebase \u0026ndash;abort 这样就能退出rebase，并回退到rebase前的状态。\n储藏的概念 “储藏”可以获取你工作目录的中间状态（包括修改过的被追踪的文件和已经暂存的变更），并将其保存到一个未完结变更的堆栈中，而且随时可以重新应用。当你不想提交，也不想丢弃当前工作区中的内容，而想切换到其他分支的时候，可以使用储藏命令先暂存工作区中的内容。然后，再回到当前分支的时候，将储藏起来的内容，恢复到工作区之后，即可恢复之前的工作。\n储藏的基本操作 储藏分为保存和应用两个部分。保存就是将当前工作区的内容保存到一个栈中，而应用就是重新应用被保存的工作。\n保存 保存用到的命令是git stash，只需在当前分支执行此命令，即可将当前工作区的内容保存起来。如你在本地版本库创建了helloGit文件，此时查看工作区状态可以得到如下所示提示：\nOn branch master Unt\\fracked files: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to include in what will be committed) helloGit nothing added to commit but unt\\fracked files present (use \u0026ldquo;git add\u0026rdquo; to t\\frack) 当你执行git stash命令，将工作区保存起来之后，再次查看可以得到如下提示：\nOn branch master nothing to commit, working tree clean 此时已经将工作区内容保存了起来，所以才会提示工作区是干净（clean）的。\n重新应用 当你需要再次应用被保存的内容的时候，只需执行git stash apply即可。 因为可能执行了多次保存，所以你需要查看已经保存起来的内容有哪些。查看已经保存的工作的命令如下：\n$ git stash list 会得到类似于如下输出：\nstash@{0}: WIP on master: bguebge add helloGit1 stash@{1}: WIP on master: 7gder34 add helloGit2 stash@{2}: WIP on master: 3frfg4g add helloGit3 如上所示，可以得知一共有三个保存。\n如果要应用指定的储藏，则可以使用命令：\ngit stash apply 储藏标识 这里的储藏标识就是git stash list中显示的类似于stash@{0}的字符串。如：\ngit stash apply stash@{2} 这样就重新应用了第二次储藏。如果不加储藏标识，就默认应用最近的储藏：\ngit stash apply 上述命令就重新应用了最近的一次储藏。\n储藏的概念 “储藏”可以获取你工作目录的中间状态（包括修改过的被追踪的文件和已经暂存的变更），并将其保存到一个未完结变更的堆栈中，而且随时可以重新应用。当你不想提交，也不想丢弃当前工作区中的内容，而想切换到其他分支的时候，可以使用储藏命令，先暂存工作区中的内容。然后，再回到当前分支的时候，将储藏起来的内容，恢复到工作区之后，即可恢复之前的工作。 #####储藏的基本操作\n储藏分为保存和应用两个部分。保存就是将当前工作区的内容保存到一个栈中，而应用就是重新应用被保存的工作。\n保存 保存用到的命令是git stash，只需在当前分支执行此命令，即可将当前工作区的内容保存起来。如你在本地版本库创建了helloGit文件，此时查看工作区状态，可以得到如下所示提示：\nOn branch master Unt\\fracked files: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to include in what will be committed) helloGit nothing added to commit but unt\\fracked files present (use \u0026ldquo;git add\u0026rdquo; to t\\frack) 当你执行git stash命令，将工作区保存起来之后，再次查看可以得到如下提示：\nOn branch master nothing to commit, working tree clean 此时已经将工作区内容保存了起来，所以才会提示工作区是干净（clean）的。\n重新应用 当你需要再次应用被保存的内容的时候，只需执行git stash apply即可。 因为可能执行了多次保存，因此你需要查看已经保存起来的内容有哪些，查看已经保存的工作的命令如下：\n$ git stash list 会到的类似于如下的输出：\nstash@{0}: WIP on master: bguebge add helloGit1 stash@{1}: WIP on master: 7gder34 add helloGit2 stash@{2}: WIP on master: 3frfg4g add helloGit3 如上所示，可以得知一共有三个保存。\n如果要应用指定的储藏吗，则可以使用命令：\ngit stash apply 储藏标识 这里的储藏标识就是git stash list中显示的类似于stash@{0}的字符串。如：\ngit stash apply stash@{2} 这样就重新应用了第二次储藏。如果不加储藏标识，就默认应用最近的储藏：\ngit stash apply 上述命令就重新应用了最近的一次储藏。\n","date":"2024-12-10T11:48:04+08:00","image":"https://getshhi.github.io/fg3.png","permalink":"https://getshhi.github.io/p/git5/","title":"Git5"},{"content":"创建标签 在开发过程中，commit ID是一串无序的字符，它虽然能唯一标记一次代码提交，即一个版本。但是，它很难记忆和辨识。所以，为了给不同的版本起一个容易辨识的名字，我们可以给这次提交打上一个标签，用不同的标签来对应不同的版本。这样，就相当于给这次提交生成了一个快照。实际上，在为某次提交创建标签的时候，Git会为标签生成一个指针，以指向其对应的提交。然后，我们就可以通过标签找到对应的提交，这样对我们版本发布和代码审查都很有帮助。\n如上图所示，我们为master分支上的三次提交，分别打上0.1、0.2、0.3三个标签。这样，当我们说0.1版本的时候，就对应了第一次提交的代码。这种方式大大降低了代码审查、团队交流及版本发布的复杂性。\n查看标签 查看标签需要用到git tag命令，其具体使用示例如下:\ngit tag\n这样就能列出所有的标签，显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。\n如果标签过多，而你指向显示指定的某些标签，则可以使用正则表达式：\n1 git tag -l \u0026#39;v5.1.2.*\u0026#39; 如上，使用-l参数，并使用v5.1.2.*这一正则表达式，就过滤除了符合要求的标签，其中v5.1.2.*为正则表达式，它能够匹配所有前缀为v5.1.2的标签。实际执行过程中会得到类似于下方的输出：\n1 2 3 4 v5.1.2.1 v5.1.2.2 v5.1.2.3 v5.1.2.4 上方输出信息，为我们列出了目前版本库中已有的四个标签。\n创建标签 不含附注的标签 创建标签的命令格式为：\n1 git tag 标签名 commitID 参数commitID标识了该标签对应的代码版本，如果不提供commitID，就默认为最近一次提交后的代码打标签。例如：\n1 2 git tag v1.0 git tag v1.0 7f8buir2 语句1表示，为最新一次提交后的代码打上v1.0的标签；语句2则表示，为指定的版本7f8buir2打上标签v1.0。\n包含附注的标签 如果需要像提交代码时增加提交日志那样，为每个标签添加说明信息，则需要使用：\n1 git tag -a 标签名 -m \u0026#34;说明信息\u0026#34; 如：\n1 git tag -a v1.0 -m \u0026#39;version 1.0\u0026#39; 表示为此次打的标签，增加一个version 1.0的说明信息。\n在查看标签时，可以使用git show命令，查看某个标签的附注信息。例如：\n1 git show v1.0 表示要查看标签v1.0对应的附注信息。\n推送指定标签 推送指定标签到远程仓库的Git命令如下：\n1 git push 远程主机名 tag名 其中，远程主机名为远程Git版本库对应的主机名，tag名为准备推送的标签名。\n该命令使用示例如下：\n1 git push origin v1.0 该语句表示将v1.0标签，推送到主机名为origin对应的远程仓库。\n推送全部标签 推送指定标签需要用到：\ngit push 远程主机名 \u0026ndash;tags\n其使用方法如下：\ngit push origin \u0026ndash;tags\n其中origin为远程主机名，这样就能将全部标签推送至远程仓库。\n推送全部标签 推送指定标签 推送指定标签，需要用到的命令格式为：\n1 git push 远程主机名 tag名 其使用方法示例如下：\n1 git push origin v1.0 其中origin为远程主机名，这样就能将v1.0推送至远程仓库。\n推送全部标签 推送全部标签需要用到：\n1 git push 远程主机名 --tags 其使用方法示例如下：\n1 git push origin --tags 其中origin为远程主机名，这样就能将全部标签推送至远程仓库。\n删除标签 删除本地标签 删除本地标签，需要用到的命令格式为：\n1 git tag -d 标签名 具体使用方法示例如下：\n1 git tag -d v1.0 这样就能实现删除v1.0标签。\n删除远程标签 删除远程tag，可以使用如下命令：\n1 git push origin --delete tag 标签名 或者如下所示的命令：\n1 git push origin :refs/tags/\u0026lt;tagname\u0026gt; 即推送一个空的tag名到远程仓库，其中指某个标签的名字。\n这两种方式都能实现删除远程的指定标签。\n","date":"2024-12-09T11:48:00+08:00","image":"https://getshhi.github.io/fg2.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E6%A0%87%E7%AD%BE/","title":"Git入门之标签"},{"content":"回到前一次提交 强大的git log 在之前，我们已经介绍了git log的基本使用方法，这里我们要进一步介绍git log的使用。\n查看提交的内容差异 git log提供了-p参数，用于查看每次提交之间的内容差异，如下： git log -p 即可显示每次提交之间的变化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 commit 92f972422350ef603beb2740a78f57d0f98c1738 (HEAD -\u0026gt; master, origin/mast Author: educoder \u0026lt;user@sample.com\u0026gt; Date: Sat Jan 6 15:57:52 2018 +0800 第一次提交 diff --git a/7-1.sh b/7-1.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-1.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-2.sh b/7-2.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-2.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-3.sh b/7-3.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-3.sh @@ -0,0 +1 @@ +### \\ No newline at end of file diff --git a/7-4.sh b/7-4.sh new file mode 100644 index 0000000..fa7cc9c --- /dev/null +++ b/7-4.sh 而如果想限制显示的范围，则可以再添加参数用于限定：\ngit log -p -2\n如上，则仅显示最近的两次更新。\n如上所示，这一选项附带了每次commit的内容变化，这就为代码审查或者浏览某个搭档的修改内容，提供了很好的参考。\n其他git log选项：\n1.单词层面对比\nGit提供了\u0026ndash;word-diff选项，可以显示单词层面的差异。当需要在书籍、论文这种很大的文本文件上，进行对比的时候，这个功能就非常有用。\n2.显示简要的增改行数\nGit提供了\u0026ndash;stat选项，则可以仅显示增加或者减少了多少行。\n3.pretty选项\n使用\u0026ndash;pretty 选项选项，可以指定不同的显示属性，如oneline 将每个提交放在一行显示。 short，full 和 fuller 可以指定展示的信息的多少。\ngit revert实现版本回退 版本回退可以用git revert命令。git revert撤销提交时，会保留所撤销的提交的记录和历史，并将撤销操作做为一次新的提交。即提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。其具体的使用方法如下：\ngit revert HEAD 撤销前一次 commit git revert HEAD^ 撤销前前一次 commit git revert commit （比如：fa042ce57ebbe5b）撤销指定的版本，撤销也会作为一次提交进行保存 git reset实现版本回退 git reset也能实现版本回退，但是git revert 和 git reset也存在一定的区别 ：\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit；\n在回滚这一操作上看，效果差不多。但是，在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit，“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现。但是git reset是把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入；\ngit reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git reset用法如下：\ngit reset HEAD 回到前一次 commit。也可以用于将错误的文件添加进暂存区后，想回退取消，如： git reset HEAD 文件名\ngit reset HEAD^ 回到前前一次 commit。\ngit reset commit 比如：commit = fa042ce57ebbe5b，回到指定的版本，撤销也会作为一次提交进行保存。\n另外git reset也可以指定reset的模式：hard、soft、mixed、merged、keep。 这几种模式的差别如下：\n\u0026ndash;soft 缓存区和工作目录都不会被改变； \u0026ndash;mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响； \u0026ndash;hard – 缓存区和工作目录，都同步到你指定的提交。 几种模式的具体使用方法如下： 1 2 3 4 5 6 #直接丢弃工作区和暂存区的修改 git reset --hard HEAD #暂存区内容保留，工作区修改丢弃 git reset --mixed HEAD #暂存区和工作区内容都保留 git reset --soft HEAD 回到指定提交 git revert实现版本回退 版本回退可以用git revert命令。使用git revert撤销提交时，会保留所撤销的提交的记录和历史，并将撤销操作做为一次新的提交。即提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。其具体的使用方法如下：\ngit revert HEAD 撤销前一次 commit git revert HEAD^ 撤销前前一次 commit git revert commit （比如：fa042ce57ebbe5b）撤销指定的版本，撤销也会作为一次提交进行保存 git reset实现版本回退 git reset也能实现版本回退，但是git revert 和 git reset有一定的区别 ：\ngit revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit； 在回滚这一操作上看，效果差不多。但是，在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit，“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现。但是git reset是把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入； git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 git reset用法如下：\ngit reset HEAD 回到前一次 commit。也可以用于将错误的文件添加进暂存区后，想回退取消，如： git reset HEAD 文件名\ngit reset HEAD^ 回到前前一次 commit。\ngit reset commit 比如：commit = fa042ce57ebbe5b，回到指定的版本，撤销也会作为一次提交进行保存。\n另外git reset也可以指定reset的模式：hard、soft、mixed、merged、keep。 这几种模式的差别如下：\n\u0026ndash;soft 缓存区和工作目录都不会被改变； \u0026ndash;mixed 默认选项。缓存区和你指定的提交同步，但工作目录不受影响； \u0026ndash;hard 缓存区和工作目录都同步到你指定的提交。 几种模式的具体使用方法如下： 1 2 3 4 5 6 #直接丢弃工作区和暂存区的修改 git reset --hard HEAD #暂存区内容保留，工作区修改丢弃 git reset --mixed HEAD #暂存区和工作区内容都保留 git reset --soft HEAD 撤销修改 git reset实现版本回退 当将有错误的文件add进暂存区后，可以使用git reset丢弃修改。即： git reset HEAD 文件名 但此时修改仍旧保留在工作区。\n如果尚未add进暂存区，则可以使用：\ngit reset \u0026ndash;hard HEAD\n这样就能彻底丢弃修改，即将修改从暂存区及工作区彻底删除。\ngit checkout丢弃修改 当将错误的文件add进暂存区后，使用git checkout无法将修改从暂存区中撤销，必须要先使用git reset将修改从暂存区中撤销。\n如果只是工作区有了修改，则可以直接使用git checkout进行撤销，具体操作如下：\ngit chekcout \u0026ndash; hello\n通过这种方式，就可将hello文件自上个commit之后，尚未add进暂存区的修改丢弃。\n删除文件 删除文件需要用到的命令是git rm，且git rm有参数\u0026ndash;cached。 当我们需要删除暂存区或分支上的文件，同时工作区也不再需要这个文件了，可以使用：\ngit rm 文件路径\n当我们需要删除暂存区或分支上的文件，但本地又需要使用， 只是不希望这个文件被提交到版本库，可以使用：\ngit rm \u0026ndash;cached 文件路径\n文件已添加至暂存区 如果文件被添加到了暂存区，这种情况下直接使用git rm file_path会报错：\n1 2 3 4 $ git rm hello.txt error: the following file has changes staged in the index: hello.txt (use --cached to keep the file, or -f to force removal) 根据提示我们可以得知，这个时候，如果不想保留hello.txt，则可以使用：\ngit rm hello.txt -f\n如果想保留hello.txt到工作区则可以使用：\ngit rm \u0026ndash;cached hello.txt\n","date":"2024-12-08T11:47:55+08:00","image":"https://getshhi.github.io/fg1.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E6%97%A5%E5%BF%97%E5%92%8C%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/","title":"Git入门之日志和版本回退"},{"content":"入门之分支管理 创建本地分支 当初始化一个版本库并进行第一次提交的时候，如果没有创建指定分支，并切换到该分支，commit操作默认会在本地创建master分支，并将内容提交到master分支。一般我们会在版本库中维护一个master分支，如下图所示：\n我们在master分支上，进行了C1、C2、C3三次提交，且当前指针指向C3提交。一般情况下，我们只会将已经成熟的代码存放到master分支，而将正在开发的代码或者测试版的代码放到其他分支。这时，我们就需要新建分支，以在该分支进行开发。如下图：\n当我们在主分支进行了C2提交后，新建了develop分支，并在其上进行了两次提交。此时，工作区指针HEAD指向develop分支。 创建本地分支用到的命令是git branch，而分支切换用到的命令是git checkout。git checkout是有很多用途的命令，在这里我们只讲它在分支操作中的使用。下面我们详细介绍这两个命令的使用。\n分支切换 可以使用git checkout 命令切换到其他分支。如你本地有master分支和develop分支，目前你正处于develop分支进行开发，现在你想切换到master去，则可以执行操作： git checkout master 这样就能切换到master分支继续进行开发。\n创建新的分支 当你需要创建一个新的分支的时候，可以使用git branch命令，其具体使用格式为： git branch 新的分支名字 使用示例如下：\n1 2 #创建名为new_branch的新分支 git branch new_branch 创建新分支的同时切换 切换到一个新的分支，有一个更为简洁的命令：git checkout -b，它的使用格式为： git checkout -b 新的分支 名字 其具体使用方法如下：\ngit checkout -b new_branch\n这样就可以创建，并切换到了new_branch分支。\n删除本地分支 现在我们来看一个实际的例子。请看下图：\n首先，我们在master工作到 C1，然后开始一个新分支develop分支，做为测试版的代码分支。提交到C5的时候，又需要临时解决一个问题，于是从C5的地方又分出一个分支issue。提交到C7的时候，该issue被解决。issue分支已经失去其意义，则需要将其删除，以保持本地版本库分支树的干净。我们将issue分支上的代码，合并到develop上之后，就可将issue分支删除。删除issue分支后的分支树如下：\n其中，C8为合并issue分支所进行的提交。\n删除本地分支，需要用到git branch命令，且需要-D参数，具体命令格式为： git branch -D 需要删除的分支的名字\n具体使用示例如下：\n1 2 #删除develop分支 git branch -D develop 示例中的命令，能够将本地分支develop删除。\n删除远程分支 删除分支用到的git命令是git push，在具体的使用过程中有不同的用法。\n通过推送空分支到远程分支，实现删除。 一个删除远程分支的方法是，推送一个空分支到远程指定分支，以实现删除。推送本地分支到远程分支的方法是： git push 远程主机名 本地分支:远程分支 与之类似，推送空分支实现删除的方法是： git push 远程主机名 :远程分支 即：前没有指定本地分支名。具体的使用示例如下：\n1 2 #删除远程develop分支，其中origin为远程仓库名 git push origin :develop 通过delete参数删除远程分支： 除了推送空分支到远程分支外，也可以通过delete参数实现删除。具体的命令格式为： git push 远程主机名 \u0026ndash;delete 远程分支名 具体使用示例如下： 1 2 #删除远程develop分支,其中origin为远程主机名 git push origin --delete develop 本地分支合并 分支合并需要用到git merge命令，具体的命令格式为：\ngit merge 需要合并的分支\n在具体使用中，如当前处于master分支，需要将develop分支合并到master分支，则具体的使用方式如下：\ngit merge develop\n同时，分支合并也分为正常合并和快进式合并，通过为git merge添加参数，即可实现不同操作。\n快进式合并 默认情况下，Git执行\u0026quot;快进式合并\u0026quot;，即fast-farward merge，会直接将被合并的分支指向需要合并的分支。如下图： 当需要将右侧分支（develop）合并到左侧分支（master）时，master分支会生成一个指针，直接指向develop。快进式合并为默认合并方式，不需要添加任何其他参数，使用git merge 需要合并的分支即可完成。\n正常合并 正常合并的方式如下图： 如图所示，Master分支上产生了一次新的提交，也就是说生成一个新节点完成了合并，这样的话，版本演进更清晰。\n下面我们以一个具体的例子，来演示一下这两种合并方式的区别：\n1.创建master分支，并在其上提交hello文件；\n2.从master分支切换到新分支develop，并进行两次提交，分别将hello1、hello2两个文件提交到develop分支；\n3.切换回master分支，执行git merge develop进行快进式合并，然后查看master分支的日志，得到如下提示信息：\n如上图可知，master分支多了develop分支上的两次提交信息。\n4.将master分支回退到合并前状态，再次执行git merge \u0026ndash;no-ff develop，进行非快进式合并，然后再次查看日志：\n可见，master分支发生了分叉，且master多了一次提交。\n通过以上分析，两种合并方式的区别就很明显了。\n","date":"2024-12-07T11:47:50+08:00","image":"https://getshhi.github.io/nn1.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E4%B9%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","title":"Git入门之分支管理"},{"content":"入门版本库 本地版本库创建 Linux基础操作 在现今的软件开发中，Linux系统及其命令行的使用，已经是一项必不可少的技能。虽然有其他基于Git的图形化软件，但是Git只能通过命令行进行操作。因此，掌握一些基础的Linux操作命令很有必要。\n创建某个目录 有时我们需要创建目录，这时就需要使用命令mkdir。通过mkdir，可以在指定的目录下创建文件夹，其用法如下：\n在当前目录下，创建目录helloGit: mkdir helloGit\n在/home目录下，创建目录helloGit：mkdir home/helloGit\nmkdir的其他高级用法请参考其他Linux资料。\n创建文件 创建文件可以使用命令touch，其用法如下:\n在当前目录下，创建文件helloGit.txt：touch helloGit.txt 在/home目录下，创建文件helloGit.txt：touch /home/helloGit.txt 进入目录 进入某个目录，需要用到命令cd，其用法如下：\n进入helloGit目录：cd helloGit 这样的用法默认了helloGit目录，存在于当前目录下。也可以在cd命令中，直接指定进入当前目录：cd ./helloGit\n进入/home/helloGit目录：cd /home/helloGit\n返回到上一级目录：\n在Linux系统下，上一级目录可以用‘..’代替，如：\n1 2 3 4 5 6 #进入上一级目录 cd .. #进入上一级目录的再上一级目录 cd ../../ #进入上一级目录下的helloGit cd ../helloGit 使用Git前的准备 安装 Git可以使用源码安装，具体的安装过程请参考Git官网教程或者Github上Git仓库的用户指南。\n但对于初学用户，还是建议大家直接安装。\nLinux下安装： 1 2 3 4 #Fedora下安装 yum install git-core #Ubuntu等Debian类体系结构系统下 apt-get install git Mac上安装： 在 Mac 上安装 Git 有两种方式。可以使用图形化的 Git 安装工具，网址为图形化Git工具安装地址；另一种是通过MacPorts 安装。如果已经装好了 MacPorts，请用下面的命令安装 Git：\nsudo port install git-core +svn +doc +bash_completion +gitweb\nWindows下安装：\n在 Windows 上安装 Git，可以到 Git官网 的页面上，下载 exe 安装文件并运行：\nGit官网下载\n完成安装之后，就可以使用命令行的 git 工具了。建议大家最好使用Unix风格的shell来运行Git。另外，Linux也有其他图形化的Git工具，如Tortoisegit。不过，还是建议大家直接使用shell来运行Git。\nGit配置 由于Git是一个分布式的版本控制系统，所以当利用它进行分工协作时，必须区分不同的机器。这一点可以通过配置机器的名字和邮箱完成。Git初始使用时，也会提示进行配置。配置命令如下：\n1 2 $ git config --global user.name \u0026#34;Your Name\u0026#34; $ git config --global user.email \u0026#34;email@example.com\u0026#34; 在实际的使用过程中，可以将“Your Name”、“email@example”替换为自己实际的名字和邮箱。\n如何创建一个本地版本库 首先，我们需要创建一个目录，做为我们的本地版本库，然后使用git init命令，将其初始化为一个本地版本库，如下：\n1 2 3 4 5 6 #在/home目录下，创建repo目录 mkdir /home/repo #进入repo目录 cd /home/repo #将repo初始化为一个本地版本库 git init 通过上述命令，即可在/home目录下，创建repo目录，并将其初始化为一个版本库。\n添加修改到暂存区域 如何将修改保存到暂存区 本地版本库就相当于一个存放在本地的仓库，里面记录了我们本地文件的各种版本及不同版本之间的差异。当我们添加、删除或者修改了文件之后，我们必须将修改添加至工作区以暂时保存（Git的工作原理请认真阅读背景知识部分）。\n添加修改，并保存至工作区，需要用到git add命令，git add命令的使用方式如下所示：\n1 2 3 4 #添加所有修改 git add . #添加hello.txt文件 git add hello.txt 如上所示，当需要添加所有文件至工作区时，使用git add .，如果想添加指定文件，只需要像示例中添加hello.txt一样，将文件名做为参数名，传给git add即可。\n查看工作区状态 当你创建完helloGit.txt，而且没有将其添加到暂存区域时，如果使用git status命令，你会得到类似于下面的输出（中文）：\n1 2 3 4 5 6 7 8 9 # 位于分支 master # # 初始提交 # # 未跟踪的文件: # （使用 \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; 以包含要提交的内容） # # helloGit.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 或者这种（英文）：\n1 2 3 4 5 6 7 8 9 On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: src/gitTraining no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 这是什么？这是提示你工作区有被修改的文件，未提交至暂存区。 当你执行完git add之后，会得到类似于下面的输出：\n1 2 3 4 5 6 7 8 9 # 位于分支 master # # 初始提交 # # 要提交的变更： # （使用 \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; 撤出暂存区） # # 新文件： helloGit.txt # 或者这种：\n1 2 3 4 5 6 On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: src/gitTraining.java 这是在提醒你，暂存区有哪些内容需要提交到本地仓库。\n其实git status命令用来查看当前工作区的状态，即有哪些已经修改，还尚未提交到暂存区的文件。在实际的开发过程中，面对复杂的程序文件，你经常需要查看一下，自己对哪些文件做了修改，此时git status命令就很有用了。\n撤销修改 checkout命令用法如下：\n1 git checkout helloGit.txt 这样就能把已经添加到本地的helloGit.txt从暂存区中移除。\n提交修改到本地仓库 如何将修改提交到本地仓库 将修改添加到暂存区，只是将你的工作暂时保存，并没有添加到本地的仓库中。这个过程可以类比写文件，将修改添加至暂存区，就相当于把内容先放入缓存区。因此，我们必须将工作区的内容提交到本地版本库去，才算是真正地保存了修改。\n提交修改到本地仓库，使用命令git commit，其使用方式如下所示：\n1 git commit -m \u0026#34;示例提交\u0026#34; -m参数后面跟的是本次提交的具体内容，用来说明你这次的提交，主要是做了哪些修改，这个说明内容是必须的。\n解析commit的输出结果 在执行完git commit命令之后，会得到类似于下面的返回结果：\n1 2 3 [master（根提交） 37302ce] 添加helloGit.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 helloGit.txt 其中：\n“添加helloGit.txt”为“-m”的参数，即执行的命令为git commit -m \u0026ldquo;添加helloGit.txt\u0026rdquo;； “1 file changed, 0 insertions(+), 0 deletions(-)” 提示改动信息； “37302ce”这个字符串则是本次提交的Id，commit Id唯一对应一次提交。 令人惊喜的git log和git status 当执行完git commit后，如果你试着执行以下git log你可能会得到如下的输出：\n1 2 3 4 5 commit 37302ce99137cf30fabc14784d23ea63cadb928b Author: hdu \u0026lt;hdu@163.com\u0026gt; Date: Sun Dec 24 23:35:48 2017 +0800 添加helloGit.txt 其中：\n“commit 37302ce99137cf30fabc14784d23ea63cadb928b”中的后面这一串字符就是完整的commit id； “Author”就是这次提交的作者，它就是我们在git config中配置的user.name； 最后输出的“添加helloGit.txt”，是我们在提交时添加的信息。 如果有多次提交即commit，在执行git log时，会输出每一次的提交的具体信息。这样的话，什么时候（Date）由什么人（Author）提交了什么内容（“添加helloGit.txt”）就一目了然了。\n入门远程版本库 克隆操作 克隆，顾名思义，就是要获取远程版本库的完整拷贝。通过克隆操作，你可以将整个远程版本库的各种细节复制到本地，并且会建立起本地版本库和远程版本库的对应关系。\n克隆操作需要用到的命令是git clone，它的具体用法如下所示：\n1 git clone https://sample.git 通过这样的操作，就能将远程版本库复制到本地了，而且会默认克隆到sample文件夹下（对应于远程版本库地址中指定的sample）。同时，你也可以根据需要，指定克隆到其他目录下，其命令格式为：\n1 git clone xxx.git \u0026#34;指定目录\u0026#34; 这样就能将代码都复制到指定目录下。\nGit服务器 在团队开发中，我们必须选用一台主机做为Git服务器来存放远程版本库。这样团队中的每个开发者，就可以基于一个共同的远程版本库进行开发。目前提供代码托管（即可以将远程版本库存放于其上的）的平台有Github、码云等，同时我们也可以搭建一台私有的运行Git的服务器，来做为远程Git服务器。Github等平台的使用，及本地Git服务器的搭建，会在后续的实训中具体介绍。本地Git服务器，可以配置不同的连接方式，如shell、git或bash。为了给挑战者提供一个便利的实训环境，我们为每个人配置了一台本地Git服务器，并允许以bash方式进行操作，即可以通过类似于/home/sample.git这种形式的地址，做为远程仓库地址进行操作，而不是像https://sample.git这种形式。\n添加远程版本库 添加远程版本库需要用到的命令是git remote add，其命令格式为：\n1 git remote add “远程仓库名” “远程仓库地址” 使用示例如下：\n1 git remote add origin https://sample.git 这样就将https://sample.git添加为远程仓库，并将其命名为origin。\n推送本地内容到远程仓库 推送本地内容时，会将所有未推送至远程仓库的内容，都提到远程仓库。它用到的命令是git push，使用方法如下：\n1 git push 远程仓库名 本地分支名 远程分支名 具体的使用方法如下：\n1 git push origin master master 这样就将本地分支的内容，推送到远程仓库origin的master分支了。 git push的另外一种用法如下：\n1 git push -u 远程仓库名 本地分支名 远程分支名 -u参数的作用是，建立起本地master分支和远程master分支之间的对应关系，下一次如果再推送master分支，就可以忽略远程分支名了，如下所示：\n1 2 3 4 #初次推送 git push -u origin master master #再次推送 git push origin master 拉取远程分支到本地 拉取远程仓库的内容到本地，需要使用git pull命令，其命令格式为：\n1 git pull 远程主机名 远程分支名 本地分支名 其使用示例如下：\n1 2 #将远程仓库origin的master分支的内容拉取到本地master分支 git pull origin master:master 但是，在使用过程中，也可能会出现一种情况：远程分支和本地分支对同一内容做了修改，这就会导致将远程分支的修改，合并到本地分支的时候发生冲突。这个时候，可以选择解决冲突，然后合并（解决冲突会在后续的实训中介绍）。也可以选择直接强制拉取，使用远程分支的修改，覆盖本地分支的修改。强制拉取需要用到-f参数，语法格式如下：\n1 git pull 远程主机名 远程分支名 本地分支名 -f 具体的使用示例如下：\n1 2 #将远程仓库origin的master分支的内容拉取到本地master分支 git pull origin master:master -f ","date":"2024-12-06T11:47:39+08:00","image":"https://getshhi.github.io/nn.png","permalink":"https://getshhi.github.io/p/git%E5%85%A5%E9%97%A8%E7%89%88%E6%9C%AC%E5%BA%93%E5%92%8C%E5%85%A5%E9%97%A8%E8%BF%9C%E7%A8%8B%E7%89%88%E6%9C%AC%E5%BA%93/","title":"Git入门版本库和入门远程版本库"},{"content":"","date":"2024-12-05T13:11:20+08:00","image":"https://getshhi.github.io/bk.png","permalink":"https://getshhi.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySql索引"},{"content":"MySql内部结构 执行一条select语句，期间发生了啥？ 先说结论\n首先客户端会与服务端的连接器进行连接，连接器会检查客户端传来的账号，密码，核对一下是否正确，如果正确，就会开始读取所属的用户和用户权限，并把这个信息保存在连接器中，如果不正确，会返回错误。 然后开始查询缓存(针对已经查过的数据，会以key-value的形式存储在缓存中)，如果key中有对应的值，则直接返回其value值。(MySQL 8.0已经删除这个模块) 其次会解析SQL，解析器会先进行词法分析，然后进行语法分析，构造语法树，如果语法错误，会返回错误。 最后执行SQL，首先在预处理器中会判断是否缺少字段，然后在优化器中选择合适的SQL查询方案，尽可能地提高性能，最后在执行器中按照执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端。 逐步分析 连接器 与客户端进行 TCP 三次握手建立连接； 校验客户端的用户名和密码，如果用户名或密码不对，则会报错； 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限； 查询缓存 如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。 如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。 其实这个很无用(对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。)，所以MySQL 8.0 版本直接将查询缓存删掉了。 解析SQL 第一件事，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from； 第二件事语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。 执行SQL 预处理器 检查 SQL 查询语句中的表或者字段是否存在； 将 select Fields 中的内容扩展为该有的列； 优化器 主要负责将SQL查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。 执行器 主键索引查询 全表扫描 索引下推 最终的效果图 MySql的数据存放在哪个文件？ 对于MySql5.7来说 db.opt，用来存储当前数据库的默认字符集和字符校验规则。 student.frm，student的表结构会保存在这个文件中。 student.ibd，student的表数据会保存在这个文件中。 对于MySql8.0来说 这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。 表空间文件的结构是啥？ 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的。 InnoDB 行格式有哪些？ InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。\nRedundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。 Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。 COMPACT 行格式长什么样？ 主要分为真实数据和额外的信息，图如下\n为什么「变长字段长度列表」的信息要按照逆序存放？ 逆序存放变长字段长度列表可以使得位置靠前的记录的真实数据和数据对应的字段长度信息同时在一个CPU Cache Line中。这有助于提高CPU缓存的命中率，从而加快数据访问速度。 当读取记录时，首先读取的是记录头信息，然后根据变长字段长度列表中的信息，从后往前读取各个字段的长度，进而确定每个字段的起始位置和长度。 这种设计还有助于减少磁盘I/O操作，因为相关的长度信息和数据可以一起被加载到内存中，减少了额外的读取次数。 varchar(n)最大取值为多少？ 不管是单字段还是多字段，算 varchar(n) 中 n 最大值时，都需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。\n行溢出后，MySQL是咋处理的? InnoDB存储引擎会自动将溢出的数据存放到[溢出页]中。\nCompact行溢出时，会保存该列的一部分数据，而把剩余的数据放在[溢出页]中，然后真实数据处用20字节存储指向溢出页的地址，从而可以找到剩余数据的页。 Compressed和Dynamic这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储20个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。 ","date":"2024-12-04T18:42:40+08:00","image":"https://getshhi.github.io/kj4.png","permalink":"https://getshhi.github.io/p/mysql%E5%9F%BA%E7%A1%80/","title":"MySql基础"},{"content":"HashMap和Hashtable的区别\nHashMap和HashSet的区别\nHashMap和TreeMap的区别\nHashSet如何检查重复\nHashMap的底层实现\nHashMap的长度为啥是2的幂次方\nHashMap多线程操作导致死循环问题\nHashMap为啥线程不安全\nHashMap的遍历方式有哪些？\nHashMap和Hashtable的区别 线程是否安全，HashMap的线程是不安全的，Hashtable的线程是安全的。 效率:因为线程安全的问题，HashMap要比Hashtable的效率高一点。另外，Hashtable被淘汰了。 HashMap可以有一个null键和多个null值，但HashTable不允许有null键和null值。 哈希函数的实现: HashMap对哈希值进行了高位和低位的混合扰动处理以减少冲突，而Hashtable直接使用键的hashCode()值。 HashMap和HashSet的区别 HashMap存储键值对，HashSet仅仅存储对象。 HashMap实现Map接口，HashSet实现了Set接口。 HashMap调用put()向map添加元素，HashSet调用add()方法向Set中添加元素。 HashMap和TreeMap的区别 相对于HashMap实现了AbstractMap，TreeMap还实现了NaivgableMap接口和SortedMap接口。 实现的Naivgable让TreeMap有了对集合内元素的搜索的能力。 实现SortedMap接口让TreeMap有了对集合中的元素根据键排序的能力。 HashSet如何检查重复 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。\nHashMap的底层实现 HashMap的底层代码分析与实现\nHashMap的长度为啥是2的幂次方 位运算效率更高: 位运算(\u0026amp;)比取余运算(%)更高效。当长度为2的幂次方相较于%length，\u0026amp;(length - 1)等价。 可以更好地保证哈希值的均匀分布:扩容之后，在旧数组元素hash值比较均匀的情况下，新数组元素也会被分配的比较均匀。 对于每次的扩容，不需要其他的操作，仅仅需要根据高危的变化进行重新分配(如果高位是1，则原位置 + 扩容的容量，高位是0，则位置不变)。 HashMap多线程操作导致死循环问题 JDK1.7及之前的版本导致的死循环问题的原因是当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。 而对于HashMap会出现数据覆盖的结果，所以在多线程也不推荐HashMap。 HashMap为啥线程不安全 两个线程同时put操作导致size的值不正确，进而导致数据覆盖的问题。 在 HashMap 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。 HashMap的遍历方式有哪些？ 迭代器EntrySet方式：通过获取HashMap的entrySet集合，然后使用迭代器进行遍历。这种方式可以同时访问键和值。\n迭代器KeySet方式：通过获取HashMap的keySet集合，然后使用迭代器进行遍历。这种方式只能访问键，需要通过键来获取对应的值。\nForEach EntrySet方式：使用增强型for循环直接遍历HashMap的entrySet集合。这种方式同样可以同时访问键和值。\nForEach KeySet方式：使用增强型for循环直接遍历HashMap的keySet集合。这种方式只能访问键，需要通过键来获取对应的值。\nLambda表达式方式：通过使用Lambda表达式对HashMap中的每个元素进行处理。这种方式代码简洁，易于理解。\nStreams API单线程方式：使用Streams API的stream()方法将HashMap转换为流，然后使用forEach方法进行遍历。这种方式适用于单线程环境。\nStreams API多线程方式：使用Streams API的parallelStream()方法将HashMap转换为并行流，然后使用forEach方法进行遍历。这种方式适用于多线程环境，可以提高遍历效率。\n","date":"2024-12-03T17:32:54+08:00","image":"https://getshhi.github.io/kj2.png","permalink":"https://getshhi.github.io/p/java%E9%9B%86%E5%90%882/","title":"Java集合(2)"},{"content":"1.DDL语句 DDL用于定义和修改数据库结构，包括创建、修改和删除表、索引等。\nCREATE: 创建数据库、表或视图。 1 2 CREATE DATABASE my_database; CREATE TABLE my_table (id INT PRIMARY KEY, name VARCHAR(255)); ALTER: 修改现有的数据库结构。 1 ALTER TABLE my_table ADD COLUMN age INT; DROP: 删除数据库、表或视图。 1 2 DROP DATABASE my_database; DROP TABLE my_table; TRUNCATE: 清空表中的所有数据，但保留表结构。 1 TRUNCATE TABLE my_table; DML (Data Manipulation Language) DML用于插入、更新和删除表中的数据。 INSERT: 向表中插入新数据。 1 INSERT INTO my_table (id, name) VALUES (1, \u0026#39;John Doe\u0026#39;); UPDATE: 更新表中的现有数据。 1 UPDATE my_table SET name = \u0026#39;Jane Doe\u0026#39; WHERE id = 1; DELETE: 从表中删除数据。 1 DELETE FROM my_table WHERE id = 1; DCL (Data Control Language) DCL用于控制对数据库的访问权限。 GRANT: 授予用户权限。 1 GRANT ALL PRIVILEGES ON my_database.* TO \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39;; REVOKE: 撤销用户权限。 1 REVOKE ALL PRIVILEGES ON my_database.* FROM \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39;; TCL (Transaction Control Language) TCL用于管理事务，确保数据的一致性和完整性。 COMMIT: 提交当前事务。 1 COMMIT; ROLLBACK: 回滚当前事务。 1 ROLLBACK; SAVEPOINT: 设置保存点（在事务中）。 1 SAVEPOINT savepoint_name; RELEASE SAVEPOINT: 释放保存点。 1 RELEASE SAVEPOINT savepoint_name; DQL (Data Query Language) DQL用于查询数据库中的数据。 SELECT: 从表中检索数据。 1 2 SELECT * FROM my_table; SELECT name FROM my_table WHERE id = 1; JOIN: 连接多个表。 1 SELECT a.id, b.name FROM table_a a JOIN table_b b ON a.id = b.id; 6.Other Common SQL Clauses and Functions 其他常见的SQL子句和函数：\nWHERE: 过滤条件。 1 SELECT * FROM my_table WHERE id \u0026gt; 10; ORDER BY: 排序结果。 1 SELECT * FROM my_table ORDER BY name ASC; GROUP BY: 分组数据。 1 SELECT name, COUNT(*) as count FROM my_table GROUP BY name; HAVING: 过滤分组后的数据。 1 SELECT name, COUNT(*) as count FROM my_table GROUP BY name HAVING count \u0026gt; 1; 1 SELECT * FROM my_table LIMIT 10; UNION: 合并多个查询的结果。 1 SELECT id FROM table1 UNION SELECT id FROM table2; 7.注意事项 在编写MySQL查询时，SQL语句的子句和函数的顺序通常遵循一定的规则。\nSELECT: 指定要选择的列。 FROM: 指定数据来源的表。 JOIN: 如果有多个表进行连接，使用 JOIN 子句。 WHERE: 过滤记录的条件。 GROUP BY: 对结果集进行分组。 HAVING: 对分组后的结果进行过滤。 ORDER BY: 对结果集进行排序。 LIMIT: 限制返回的记录数。 OFFSET: 跳过指定数量的记录（通常与 LIMIT 一起使用）。 1 2 3 4 5 6 7 8 SELECT column1, column2, aggregate_function(column3) FROM table1 JOIN table2 ON table1.common_column = table2.common_column WHERE condition GROUP BY column1, column2 HAVING aggregate_condition ORDER BY column1 ASC, column2 DESC LIMIT 10 OFFSET 5; ","date":"2024-11-30T16:37:58+08:00","image":"https://getshhi.github.io/jk1.png","permalink":"https://getshhi.github.io/p/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","title":"MySql的基本用法"},{"content":"Java集合概览\n说说List，Map，Set，Queue的区别\n集合框架底层数据结构总结\n如何选用集合？\n为啥要使用集合？\nArrayList和Array(数组)的区别\nArrayList和Vector的区别\nVector和Stack的区别\nArrayList可以添加null值吗\nArrayList插入和删除元素的时间复杂度\nLinkedList插入和删除元素的时间复杂度是多少\nLinkedList为啥不能实现RandomAccess接口\nArrayList与LinkedList区别\nArrayList的扩容机制\nComparable和Comparator的区别\n无序性和不可重复性的含义是啥\n比较HashSet，LikedHashSet和TreeSet三者的异同\nQueue与Deque的区别\nArrayDeque与LikedList的区别\n说一说PriorityQueue\n啥是BlockingQueue\nBlockingQueue的实现类有哪些\nArrayBlockingQueue和LinkedBlockingQueue有啥区别？\nJava集合概览 Java集合分为Collection和Map，其中Collection接口分为Set，List，Queue，用来存储单一元素，而Map接口用来存储键值对。 说说List，Map，Set，Queue的区别 List(对付顺序的好帮手):存储有序的，可重复的元素。\nMap存储键值对，通常用这个查询键值对组合。value是无序的，可重复的，Key是无序的，不可重复的。\nSet(注重独一无二的性质):存储不重复的元素。\nQueue(实现排队功能的叫号机):按特定的排队规则来确定先后顺序，存储的元素是有序的，可重复的。\n集合框架底层数据结构总结 List\nArrayList: Object[]数组。 Vector: Object[]数组。 LinkedList: 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) Set\nHashSet(无序，唯一):基于HashMap实现的，底层采用HashMap来保存元素。 LinkedHashSet:LinkedHashSet是HashSet的子类，并且内部是通过LinkedHashMap来实现的。 TreeSet(有序，唯一):红黑树(自平衡的排序二叉树)。 Queue\nPriorityQueue:Object[]数组来实现小顶堆。 DelayQueue:PriorQueue。 ArrayDeque:可扩容动态双向数组 Map\nHashMap:JDK1.8以前HashMap是由数组+链表组成的，数组是HashMap的主体，链表是为了解决哈希冲突而存在的。JDK1.8以后数组+链表+红黑树。 LinkedHashMap:LinkedHashMap继承自HashMap，所以它的底层是数组+链表+红黑树，并且加了一条双向链表。 Hashtable:数组+链表组成的，数组是Hashtable的主体，链表则主要是为了解决哈希冲突而存在的。 TreeMap:红黑树(自平衡的排序二叉树)。 如何选用集合？ 根据键值获取元素值时就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap。 我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后根据实现这些接口的集合的特点来选用。 为啥要使用集合？ 根据我们开发时存储的形式是各种各样的，传统的数组已经不能满足这个需求，我们需要一个容器能过够存储各种各样的，这就是集合。\nArrayList和Array(数组)的区别 ArrayList会根据实际存储元素动态地扩容或者缩容，而Array被创建之后就不能改变它的长度。 ArrayList让你使用泛型来确保类型安全，Array则不可以。 ArrayList提供了丰富的API操作方法，比如add()，remove()等。Array只是一个固定长度的数组，只能按照下标访问其中的元素或者增强循环访问其中的元素，不具有动态添加，删除元素的能力 ArrayList创建时不需要指定大小，而Array创建时必须指定大小。 ArrayList只能存储对象，而Array都可以存(基本数据类型和对象) ArrayList和Vector的区别 ArrayList是List接口的主要实现类，线程不安全，用于单线程且查询频繁的场景(线程不安全)。 Vector用于多线程，它是线程安全的。 Vector和Stack的区别 Vector和Stack两者都是线程安全的，都是使用synchronized关键字进行同步处理。 Stack继承自Vector，是一个后进后出的栈，而Vector是一个列表。 随着 Java 并发编程的发展，Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap、CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持。\nArrayList可以添加null值吗 ArrayList可以存储任何类型的对象，包括null值。不过，不建议向ArrayList中添加null值，null值毫无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。\nArrayList插入和删除元素的时间复杂度 对于插入\n头部插入:对于在头部插入的，要往后移动n个元素，所以时间复杂度为O(n) 尾部插入: 对于在尾部插入的，如果不扩容的话，时间复杂度位O(1)，如果扩容的话，时间复杂度为O(n) 指定位置插入:需要将目标位置之后的所有元素都往后移动一个位置，然后再把新元素放入指定位置，这个元素需要移动平均n/2个元素，因此时间复杂度为O(n) 对于删除:\n头部删除:O(n) 尾部删除:O(1) 指定位置删除:O(n) 总结:这种的话可以直接从数组的角度来分析时间复杂度\nLinkedList插入和删除元素的时间复杂度是多少 头部插入/删除:O(1) 尾部插入/删除:O(1) 指定位置插入/删除:O(n) 总结:这种的话可以根据双向链表来分析时间复杂度。\nLinkedList为啥不能实现RandomAccess接口 RandomAccess(是一个标记接口)就是用来表明实现该接口的类支持随机访问(即索引访问)，而LinkedList底层是链表，内存不一定连续，是不支持随机访问(即索引访问)的，所以不能实现RandomAccess这个接口。\nArrayList与LinkedList区别 是否线程安全，两者都是不安全的，在多线程的情况下都不是安全的。 时间复杂度: ArrayList的底层是动态数组，LinkedList的底层是链表，可以从这个底层来进行分析。 内存占用:有于LinkedList得存下一个节点的地址，所以LinkedList所占的内存偏大。 是否支持随机访问，ArrayList支持随机访问，LinkedList不支持随机访问。 使用场景，ArrayList用于大多数场景。因此建议能用ArrayList就用ArrayList。 ArrayList的扩容机制 当 ArrayList 中的元素数量超过其当前容量时，会触发扩容机制。默认情况下，ArrayList 的初始容量为 10。\n当发生扩容时，ArrayList 会创建一个新的数组，其容量为原数组的 1.5 倍（即 oldCapacity + (oldCapacity \u0026raquo; 1)），然后将原数组中的元素复制到新数组中。\n复制过程是通过 Arrays.copyOf() 方法实现的。\n源码分析(add方法):\n1.首先会进入add方法，在add方法中首先判断(size + 1)是否需要扩容，如果需要则扩容，然后赋值。 2.判断扩容在ensureCapacityInternal这个函数，这个函数内部会调用ensureExplicitCapacity，如果(minCapacity - elementData.length \u0026gt; 0)即容量不够了，则会调用grow方法。 3.grow即是核心方法，grow方法中首先将旧的容量扩容成1.5倍，与minCapacity进行比较，如果小于，则新的容量为minCapacity,然后进行(newCapacity - MAX_ARRAY_SIZE \u0026gt; 0)，然后进行 return (minCapacity \u0026gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :MAX_ARRAY_SIZE;。 4.最终通过 Arrays.copyOf(elementData, newCapacity); 复制老数组的数据到新数组，完成扩容。 Comparable和Comparator的区别 Comparable接口出自java.lang包，它有一个compareTo(Object obj)方法用来排序。 Comparator接口出自java.util包，它有一个compare(Object obj1, Object obj2)方法用来排序。 无序性和不可重复性的含义是啥 无序性指的数组的元素的添加不是按照数组索引的顺序来进行添加的，而是按照根据数值的哈希值来进行加的。 不可重复性指的是equals()判断时，返回false，必须重写equals()和hashcode()方法。 比较HashSet，LikedHashSet和TreeSet三者的异同 相同点:这三者都只能存储不重复的元素，这三者都是线程不安全的。 不同点:内部数据结构不同，HashSet的底层是基于HashMap实现的，底层的数据结构跟HashMap的一样，数组+链表+红黑树，而LinkedHashSet的底层是LinkedHashMap，底层是数组+链表(双向链表)+红黑树，TreeSet的底层是TreeMap的，底层的数据结构为红黑树(一种自平衡的树)。 应用场景不同，HashSet常常用于不需要保证元素插入和取出顺序的场景，LinkedHashSet用于保证元素的插入和取出顺序满足FIFO的场景，TreeSet用于支持对元素自定义排序规则的场景。 Queue与Deque的区别 Queue的底层是单向队列，支持FIFO，从一端进从一端出。 Deque的底层是双向队列，支持两端添加和删除，这个可以模拟栈。 ArrayDeque与LikedList的区别 ArrayDeque的底层是变长的数组加双指针，LinkedListd的底层是双链表。 ArrayDeque不支持存储NULL数据，但LinkedList支持。 ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。 说一说PriorityQueue PriorityQueue按照某种优先级进行取出和插入。 PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据。 啥是BlockingQueue 就是阻塞队列，符合生产者-消费者模式，当队列没有时进入阻塞状态，当队列已经满时，一直等到队列可以放入新元素时再放入 BlockingQueue的实现类有哪些 ArrayBlockingQueue和LinkedBlockingQueue。 ArrayBlockingQueue和LinkedBlockingQueue有啥区别？ 底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。 是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。 ","date":"2024-11-26T23:34:44+08:00","image":"https://getshhi.github.io/jk2.png","permalink":"https://getshhi.github.io/p/java%E9%9B%86%E5%90%881/","title":"Java集合(1)"},{"content":"Java异常类层次结构图\nException和Error有啥区别\nChecked Exception和Unchecked Exception有啥区别\nThrowable类常用方法有哪些\ntry-catch-finally如何使用\n咋用try-with-resources代替try-catch-finally\n异常使用有哪些需要注意的地方\n啥是泛型？有啥作用\n泛型的使用方式有哪几种\n何为反射\n反射的优缺点\n反射的应用场景\n啥是注解\n注解的解析方法有哪几种\n啥是SPI\nSPI和API有啥区别\nSPI的优缺点\n啥是序列化？啥是反序列化?\n如果有些字段不想进行序列化咋办\n常见的序列化协议有哪些\n为啥不推荐使用JDK自带的序列化\nJava异常类层次结构图 Exception和Error有啥区别 Exception:程序本身可以处理的异常，可以通过catch来进行捕获。 Error:Error属于程序无法处理的错误，如果出现异常线程就直接结束。 Checked Exception和Unchecked Exception有啥区别 Checked Exception就是编译异常(常见的有SQL异常，超时异常，找不到方法异常) Unchecked Exception就是运行异常(常见的有算术异常，数组下标越界异常，空指针异常) Throwable类常用方法有哪些 String getMessage():返回异常发生时的详细信息。 String toString():返回异常发生的简要描述。 String getLocalizedMessage():返回异常对象的本地化信息。 void printStackTrace():在控制台上打印Trowable对象封装的异常信息。 try-catch-finally如何使用 将可能出现异常的放在try代码块中，对异常的处理放在 catch代码块中，finally放最后肯定执行的(除了cpu关闭，所在线程提前死亡或者JVM提前死亡)。\n咋用try-with-resources代替try-catch-finally 适用范围（资源的定义）： 任何实现 java.lang.Closeable或者 java.io.Closeable 的对象 关闭资源和 finally 块的执行顺序：在 -try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行。 异常使用有哪些需要注意的地方 1.尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常。 2.只在需要try-catch的地方try-catch，try-catch的范围能小则小 3.不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。 4.不要延迟处理异常 啥是泛型？有啥作用 Java泛型是JDK5中引入的一个新特性 作用很直接，就是能把运行时异常转为编译时异常\n泛型的使用方式有哪几种 泛型一般有三种使用方式\n泛型类 泛型接口 泛型方法 何为反射 Java的反射机制就是指在运行获取类的结构信息(如方法，字段，构造函数)并操作对象的一种机制。\n反射的优缺点 优点\n反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。 缺点\n不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。 另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。 相关阅读Java Reflection: Why is it so slow?\n反射的应用场景 主要运用在框架的开发和动态代理的实现\n啥是注解 1.注解其实就是一个标记，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。 2.有了标记之后，就可以在解析的时候获取标记，然后做特别处理。 3.注解的使用可以通过编译时、类加载时或者运行时的反射机制来实现特殊的处理逻辑。 注解的解析方法有哪几种 编译期直接扫描: 比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。\n运行期通过反射通过反射处理: 像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。\n啥是SPI SPI就是我调用你实现的接口(其他的不用管)，简单来说就是用就完了。\nSPI和API有啥区别 调用方直接调用实现方接口实现服务就是API\n实现方实现实现方提供的接口从而提供服务就是SPI\nSPI的优缺点 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。 当多个 ServiceLoader 同时 load 时，会有并发问题。 啥是序列化？啥是反序列化? 序列化就是将对象转化为能在网络中传输的，通常是二进制字节流，也可以是JSON，XML等文本格式。 反序列化就是将在网络中传输的转化为对象的过程。 如果有些字段不想进行序列化咋办 可以用transient关键字修饰\ntransient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化； 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 常见的序列化协议有哪些 JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。 像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。 为啥不推荐使用JDK自带的序列化 不能兼容其他的语言 性能差 存在安全问题 Java IO流了解吗 Java IO流简单来说就是输入和输出，输入到计算机内存中进行处理，而输出就是输出到外部存储器进行存储(比如磁盘等之类的外部存储器) Java IO流主要有四个抽象类，分别是InputStream/Reader:所有的输入流的基类，前者是字节输入流，后者是字符输入流， OutputStream/Writer:所有输出流的基类，前者是字节输出流，后者是字符输出流。 I/O流为啥要分为字节流和字符流呢 部分场景需要对字符进行操作，用字符流更加高效 如果我们不知道编码类型的话使用字节流的过程中很容易出现乱码问题。 啥是语法糖 编程语言为了方便程序员开发程序而设计的一种特殊语法。\nJava有哪些常见的语法糖 lambda表达式，泛型，自动拆装箱，内部类，增强for循环等等。\n","date":"2024-11-25T19:25:16+08:00","image":"https://getshhi.github.io/jk3.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%803/","title":"Java基础(3)"},{"content":"面向对象和面向过程的区别\n创建一个对象用啥运算符？对象实体与对象引用有何不同\n对象的相等和引用相等的区别\n如果一个类没有声明构造方法，该程序能正确执行吗\n构造方法有啥特点？是否可被override\n面向对象三大特怔\n接口和抽象类有啥共同点和区别\n深度拷贝和浅拷贝了解吗？啥是引用拷贝？\nObject类的常见方法有哪些\n== 和 equals()的区别\nhashCode()有啥用\n为啥要有hashCode\n为啥重写equals()时必须重写hashCode()方法\nString， StringBuffer， StringBuilder的区别\nString为啥是不可变的\n字符串拼接用 \u0026ldquo;+\u0026rdquo; 还是StringBuilder\nString#equals()和Object#equals()有啥区别\n字符串的常量池了解过吗\n创建String对象的两种方式以及不同\nString s1 = new String(\u0026ldquo;abc\u0026rdquo;)创建了几个对象\nString#intern方法有啥作用\nString 类型的变量和常量做“+”运算时发生了什么\n面向对象和面向过程的区别 面向对象会先抽象出对象，然后用对象执行方法的方式来解决问题 面向过程会把解决问题的过程拆成一个个方法，通过一个个方法来执行解决问题\n面向过程具有良好的性能，但扩展性较差，面向对象具有较好的扩展性，但性能较差。\n创建一个对象用啥运算符？对象实体与对象引用有何不同 创建一个对象用new运算符\n对象实体与对象引用的区别\n对象实体存储在堆中。 对象实体指向对象实体。 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）。 一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 对象的相等和引用相等的区别 对象相等是指内存中的内容是否相等\n引用相等时指指针内存地址是否相等\n如果一个类没有声明构造方法，该程序能正确执行吗 可以的\n系统会生成一个默认的无参构造器 当我们如果实现有参构造器，最好手动加一个无参构造器，这个可以帮助我们少踩坑。\n构造方法有啥特点？是否可被override 名字与类名相同。 没有返回值。 自动执行，在生成类的对象时，构造方法会自动执行，无需显式调用。 构造方法不能被重写，只能被重载。 面向对象三大特怔 封装\n简单来说就是将一个对象的属性封装在一起，对外仅仅暴露方法调用。(比如你用空调遥控器时，空调遥控器内部的细节不知道，但你可以通过它提供的按钮来使用) 继承\n子类拥有父类的属性和方法(私有方法和私有属性有但不能继承)。提高代码的复用性，程序的可维护性。 多态\n一个对象可以有多种状态，即父类引用指向子类的多种实例。 接口和抽象类有啥共同点和区别 接口和抽象类的共同点\n实例化: 接口和抽象类都不能直接实例化，只能被实现(接口)或继承(抽象类)后才能创建具体的对象 抽象方法: 接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。 接口和抽象类的区别 接口和抽象类在设计动机上有所不同。\n接口的设计是自上而下的。我们知晓某一行为，于是基于这些行为约束定义了接口，一些类需要有这些行为，因此实现对应的接口。\n抽象类的设计是自下而上的。我们写了很多类，发现它们之间有共性，有很多代码可以复用，因此将公共逻辑封装成一个抽象类，减少代码冗余。\n简单来说就是接口是先规范然后去实现，抽象是先实现然后再抽象出来一个类。\n深度拷贝和浅拷贝了解吗？啥是引用拷贝？ 浅拷贝：浅拷贝后的对象和原对象共享引用对象的实例。\n深拷贝：会重现创建一个实例，使得深拷贝后的对象与原对象完全独立。修改一个对象不会影响另一个对象。\n引用拷贝就是两个不同的引用指向同一个对象 Object类的常见方法有哪些 == 和 equals()的区别 == 对于基本数据类型就是比较值，而对于引用类型就是比较对象的内存地址 equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。 hashCode()有啥用 hashCode用于返回对象的哈希码，确定该对象在哈希表中的索引位置。\n为啥要有hashCode 大大提高索引速度，从而提高执行速度。\n为啥重写equals()时必须重写hashCode()方法 因为根据业务来说我们想的时equals()判断的相等就一定相等，而不重写的hashCode返回的是对象的哈希码，这与我们最初的想法相违背，所以必须重写hashCode()。\nString， StringBuffer， StringBuilder的区别 可变性: String不可变，StringBuilder可变，StringBuffer可变。 线程安全性: String中的对象是不可变的，可以理解为常量，线程安全。StringBuffer安全，加了同步锁。StringBuilder并没有对方法进行加同步锁，所以不安全。 性能： String性能最低，因为每次改变时生成的是一个新的String对象。StringBuffer，StringBuilder性能较高。 总结:\n操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer String为啥是不可变的 1.String的类是用final修饰的，不可以被其他类继承，因此方法不能被重写，里面的数据都不能被改变。\n2.String的char数组是私有的而且用final修饰，因此不能改变其字符数组的引用变量，因此改变不了String。\n字符串拼接用 \u0026ldquo;+\u0026rdquo; 还是StringBuilder 字符串拼接用StringBuffer，因为用\u0026quot;+\u0026ldquo;拼接的话底层会创建一个新的StringBuilder对象(对于大多数场景比如说循环)比较耗时间，效率比较低。\nString#equals()和Object#equals()有啥区别 String的equals()会比较字符串是否相等而Object的equals会比较内存的地址是否相等。\n字符串的常量池了解过吗 字符串的常量池是JVM为了提升性能和减少内存消耗针对字符串(String类)专门开辟的一块区域，主要是为了避免字符串的重复创建。 创建String对象的两种方式以及不同 String s1 = new String(\u0026ldquo;abc\u0026rdquo;)创建了几个对象 这得分情况讨论\n1.如果是常量池中已经存在\u0026quot;abc\u0026quot;则创建一个对象。(即s1直接指向常量池中的\u0026quot;abc\u0026rdquo;) 2.如果是常量池中不存在\u0026quot;abc\u0026quot;则创建二个对象。(即首先在常量池中创建\u0026quot;abc\u0026quot;，然后s1指向常量池中的\u0026quot;abc\u0026quot;) String#intern方法有啥作用 intern方法是一个本地方法，目的返回字符串在常量池中的引用\nString 类型的变量和常量做“+”运算时发生了什么 对于编译期可以确定值的字符串，也就是常量字符串 ， jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池， 这个得益于编译器的优化。 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。(可以加final进行优化) ","date":"2024-11-23T19:48:17+08:00","image":"https://getshhi.github.io/jk4.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%802/","title":"Java基础(2)"},{"content":"java语言有啥特点？\nJavaSE是啥？JavaEE是啥？\nJVM是啥？JDK是啥？JRE是啥？\nAOT有啥优点？为啥不全用AOT呢？\n啥是字节码？采用字节码的好处是啥？\n为啥说Java语言 \u0026ldquo;编译与解释共存\u0026rdquo;?\nOracleJDK 和 OpenJDK 有啥区别？\nJava与C++的区别？\nJava注释有几种？\n标识符 和 关键字 的区别是啥？\n自增，自减符号\n移位运算符\nJava的几种基本数据类型\n基本类型和包装类型的区别？\n包装类型的缓存机制了解吗？\n自动装箱与拆箱了解吗？ 原理是啥？\n为啥浮点数运算的时候会有精度丢失的风险？\n如何解决浮点数运算的精度丢失问题\n超过long整形的数据应该如何表示\n成员变量与局部变量的区别\n静态变量有啥用？\n字符型常量和字符串常量的区别\n啥是方法的返回值？方法有哪几种类型？\n静态方法为啥不能调用非静态方法\n静态方法和实例方法有啥不同？\n重载和重写有啥区别？\n啥是可变长参数？\njava语言有啥特点？ 1.面向对象，java语言是面向对象的(封装，继承，多态)\n2.具有丰富的生态和类库。\n3.具有跨平台特点，一次编译，随处运行。\n4.简单易学。\n5.支持网络编程。\n6.本身提供多线程处理的解决办法。\n7.编译和解释并存。\nJavaSE是啥？JavaEE是啥？ JavaSE-Java平台的平台标准版，用于构建桌面应用程序或简单的服务器应用程序。\nJavaEE-Java平台的企业标准版，用于构建分布式，健壮的服务端Java应用程序。\nJVM是啥？JDK是啥？JRE是啥？ JDK = JRE + 开发工具(JDK是Java完整的工具包)\nJRE = JVM + 核心类库(JRE是可以直接运行.class文件的运行环境，JVM就是虚拟机)\nAOT有啥优点？为啥不全用AOT呢？ AOT模式与JIT模式比较\nAOT就是静态编译，优点是启动时间少，内存占用少，打包体积小。\nJIT是即时编译，优点是有高的处理延迟能力，可以降低请求的最大延迟。\nAOT不支持Java的反射，动态代理，动态加载，而很多框架都是用这个特性，AOT更适合当下的云原生场景，对微服务架构的支持更友好。\n啥是字节码？采用字节码的好处是啥？ 字节码就是JVM可以直接识别的代码(即扩展名为.class文件的文件)，由于可直接在JVM上运行，所以可以无需编译直接在不同平台上运行(即跨平台性)。 为啥说Java语言 \u0026ldquo;编译与解释共存\u0026rdquo;? 编译是因为Java先经过编译阶段，即将Java代码编译成.class文件。\n解释是因为Java运行时是Java解释器一行一行解释并执行代码的。\n所以编译与解释共存。\nOracleJDK 和 OpenJDK 有啥区别？ 简单来说就是前期这两个没有啥大的区别，后面OracleJDK为了恰钱产生这两个，前者是要付钱的，后者是开源版本。 Java与C++的区别 Java内存更安全，Java不支持单指针直接操作内存。\nJava是编译与解释共存，而C++是编译性语言。\nJava支持单继承，C++支持多继承。\nC ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载。\nJava 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。\nJava注释有几种 三种\n单行注释 -用于注释单行代码的作用\n多行注释 -用于注释多行代码的作用\n文档注释 -用于生成 Java 开发文档\n标识符 和 关键字 的区别是啥？ 标识符就是一个名字\n关键字是被赋予特殊含义的标识符\n自增，自减符号 ++a，- -a (前缀形式，计算时先减1或加1，再用a的变量)\na++， a- - (后缀形式，计算时用a的值，再将a的值减1或加1)\n移位运算符 三种运算符\n\u0026lt;\u0026lt; :左移运算符，向左移若干位，高位丢弃，低位补零。x \u0026lt;\u0026lt; n，相当于 x 乘以 2 的 n 次方(不溢出的情况下)。 \u0026gt;\u0026gt; :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0，负数高位补 1。x \u0026gt;\u0026gt; n，相当于 x 除以 2 的 n 次方。 \u0026gt;\u0026gt;\u0026gt; :无符号右移，忽略符号位，空位都以 0 补齐。 Java的几种基本数据类型 四种八类\n布尔型 boolean占一个字节 false或者true\n字符型 char占两个字节\n数值型 byte占一个字节 short占两个字节 int 占4个字节 long(后面加L)占8个字节\n浮点型 float(后面加f或者F)占4个字节 double占8个字节\n基本类型和包装类型的区别 存储方式 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。 包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。 用途 除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。 占用空间 相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。 包装类型的默认值为null， 基本类型的默认值不是null == 可以比较基本类型的值，而包装类型的值得用equals比较 包装类型的缓存机制了解吗？ Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。\nInteger，Byte，Long，Short默认创建了数值[-128， 127]的相应类型的缓存数据 Character创建了[0，127]范围的缓存数据， Boolean直接返回True or False 自动装箱与拆箱了解吗？ 原理是啥？ 装箱就是将基本数据类型转变为包装类型\n拆箱就是将包装类型转变为基本数据类型\n如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作\n为啥浮点数运算的时候会有精度丢失的风险？ 二进制表示的限制：十进制系统中的某些小数（如0.1、0.2等）在二进制系统中只能通过无限循环小数来近似表示。 舍入误差：由于计算机只能存储有限的位数，因此在进行浮点数运算时，不可避免地会产生舍入误差。 浮点数存储结构：浮点数在计算机中的存储遵循IEEE 754标准，该标准将浮点数拆分为符号位、指数位和尾数位 如何解决浮点数运算的精度丢失问题 BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 超过long整形的数据应该如何表示？ 可以用BigInteger处理\nBigInteger内部用int[]数组来存储任意大小的整形数据 相对于常规整数类型的运算来说，BigInteger运算的效率会相对较低 成员变量与局部变量的区别 语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public，private，static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。 静态变量有啥用？ 静态变量可以节省内存\n静态变量随着类的加载而创建，所以它可以被类的所有实例共享，所以可以节省内存 字符型常量和字符串常量的区别 形式: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符 含义: 字符常量相当于一个整形值(ASCII值)，可以参加表达式运算;字符串常量代表一个地址值(该字符串在内存中存放位置)。 占内存大小： 字符常量只占2个字节;字符串常量占若干个字节。\n啥是方法的返回值？方法有哪几种类型？ 返回值就是方法体返回的数值。 方法有4种 无参数，无返回的 有参数，无返回的 无参数，有返回的 有参数，有返回的 静态方法为啥不能调用非静态方法？ 静态方法随着类的加载而加载，而非静态方法只有类被实例化时才能加载，所以可以得到静态方法存在时而非静态方法不存在的情况，由此得到静态方法不能调用非静态方法。\n静态方法和实例方法有啥不同？ 调用方式不同， 调用静态方法可以无需创建对象，用类名.方法名的方式来调用静态方法。 访问类成员是否存在限制， 静态方法在访问本类的成员时，仅仅让访问静态成员，而实例方法不存在这个限制。 重载和重写有啥区别？ 重载就是在同样的一个方法能够根据输入数据的不同，做出不同的处理。 重写就是子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应，你就要覆盖父类的方法\n区别点 重载方法 重写方法 发生范围 本类中 子类中 参数列表 必须修改 不能修改 返回类型 可修改 子类的返回类型与父类返回的类型相同或者时父类返回类型的子类 异常 可修改 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； 访问修饰符 可修改 一定不能做更严格的限制（可以降低限制） 发生阶段 编译期 运行期 啥是可变长参数？ 从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。\n","date":"2024-11-22T11:05:52+08:00","image":"https://getshhi.github.io/jk5.png","permalink":"https://getshhi.github.io/p/java%E5%9F%BA%E7%A1%801/","title":"Java基础(1)"},{"content":"下面是我弄的思维导图 大致图片 json 这个可以在菜鸟工具上看到 在线思维导图(创建json文件,然后再复制下面的,在该网站导入json文件即可)\n1 {\u0026#34;root\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jmvl5bc00\u0026#34;,\u0026#34;created\u0026#34;:1729824575835,\u0026#34;text\u0026#34;:\u0026#34;计算机网络\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jz9mhdzc0\u0026#34;,\u0026#34;created\u0026#34;:1729825546760,\u0026#34;text\u0026#34;:\u0026#34;计算机网络概论\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k4ihvpgg0\u0026#34;,\u0026#34;created\u0026#34;:1729825957894,\u0026#34;text\u0026#34;:\u0026#34;计算机网络概述\u0026#34;,\u0026#34;layout_filetree-down_offset\u0026#34;:{\u0026#34;x\u0026#34;:-60.99999818205839,\u0026#34;y\u0026#34;:49.99999850988394},\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k5vgz9yo0\u0026#34;,\u0026#34;created\u0026#34;:1729826064502,\u0026#34;text\u0026#34;:\u0026#34;计算机网络是一个功能完善的软件实现资源共享和信息传递的系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k5z8z79c0\u0026#34;,\u0026#34;created\u0026#34;:1729826072725,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的组成\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k91ea69c0\u0026#34;,\u0026#34;created\u0026#34;:1729826312492,\u0026#34;text\u0026#34;:\u0026#34;从组成部分看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kah8m64o0\u0026#34;,\u0026#34;created\u0026#34;:1729826425343,\u0026#34;text\u0026#34;:\u0026#34;硬件，软件，协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k924cofk0\u0026#34;,\u0026#34;created\u0026#34;:1729826314068,\u0026#34;text\u0026#34;:\u0026#34;从工作方式看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kav8xrhk0\u0026#34;,\u0026#34;created\u0026#34;:1729826455836,\u0026#34;text\u0026#34;:\u0026#34;边缘部分和核心部分\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k9qnqss80\u0026#34;,\u0026#34;created\u0026#34;:1729826367484,\u0026#34;text\u0026#34;:\u0026#34;从功能组成看\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kaw2yz340\u0026#34;,\u0026#34;created\u0026#34;:1729826457652,\u0026#34;text\u0026#34;:\u0026#34;通信子网和资源子网\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcd31www0\u0026#34;,\u0026#34;created\u0026#34;:1729826573027,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcno842w0\u0026#34;,\u0026#34;created\u0026#34;:1729826596075,\u0026#34;text\u0026#34;:\u0026#34;数据通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcr3o3mo0\u0026#34;,\u0026#34;created\u0026#34;:1729826603539,\u0026#34;text\u0026#34;:\u0026#34;资源共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcs6lcts0\u0026#34;,\u0026#34;created\u0026#34;:1729826605893,\u0026#34;text\u0026#34;:\u0026#34;分布式处理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kctcd8i80\u0026#34;,\u0026#34;created\u0026#34;:1729826608419,\u0026#34;text\u0026#34;:\u0026#34;提高可靠性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kcu9h7340\u0026#34;,\u0026#34;created\u0026#34;:1729826610421,\u0026#34;text\u0026#34;:\u0026#34;负载均衡\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kee93af40\u0026#34;,\u0026#34;created\u0026#34;:1729826732297,\u0026#34;text\u0026#34;:\u0026#34;电路交换，报文交换，分组交换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kg3tx1ns0\u0026#34;,\u0026#34;created\u0026#34;:1729826866340,\u0026#34;text\u0026#34;:\u0026#34;计算机网络的分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgczz9lc0\u0026#34;,\u0026#34;created\u0026#34;:1729826886298,\u0026#34;text\u0026#34;:\u0026#34;按分布范围分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj5uurp40\u0026#34;,\u0026#34;created\u0026#34;:1729827105843,\u0026#34;text\u0026#34;:\u0026#34;广域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj6ztzq00\u0026#34;,\u0026#34;created\u0026#34;:1729827108321,\u0026#34;text\u0026#34;:\u0026#34;城域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj82vbz40\u0026#34;,\u0026#34;created\u0026#34;:1729827110681,\u0026#34;text\u0026#34;:\u0026#34;局域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kj9evejk0\u0026#34;,\u0026#34;created\u0026#34;:1729827113584,\u0026#34;text\u0026#34;:\u0026#34;个人区域网\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgdzlk940\u0026#34;,\u0026#34;created\u0026#34;:1729826888451,\u0026#34;text\u0026#34;:\u0026#34;按传输技术分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kk2a5u5k0\u0026#34;,\u0026#34;created\u0026#34;:1729827176425,\u0026#34;text\u0026#34;:\u0026#34;广播式网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kk36tiw80\u0026#34;,\u0026#34;created\u0026#34;:1729827178400,\u0026#34;text\u0026#34;:\u0026#34;点对点网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kgj77s1s0\u0026#34;,\u0026#34;created\u0026#34;:1729826899796,\u0026#34;text\u0026#34;:\u0026#34;按拓扑结构分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kks5bmag0\u0026#34;,\u0026#34;created\u0026#34;:1729827232729,\u0026#34;text\u0026#34;:\u0026#34;总线形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kktf3fvk0\u0026#34;,\u0026#34;created\u0026#34;:1729827235497,\u0026#34;text\u0026#34;:\u0026#34;星形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kkv1l1e80\u0026#34;,\u0026#34;created\u0026#34;:1729827239033,\u0026#34;text\u0026#34;:\u0026#34;环形网络\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kkwqg0yg0\u0026#34;,\u0026#34;created\u0026#34;:1729827242713,\u0026#34;text\u0026#34;:\u0026#34;网状网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kh7m33kw0\u0026#34;,\u0026#34;created\u0026#34;:1729826952938,\u0026#34;text\u0026#34;:\u0026#34;按使用者分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54klqe076o0\u0026#34;,\u0026#34;created\u0026#34;:1729827307265,\u0026#34;text\u0026#34;:\u0026#34;公用网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54klu78ks00\u0026#34;,\u0026#34;created\u0026#34;:1729827315563,\u0026#34;text\u0026#34;:\u0026#34;专用网\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kh8nl4fs0\u0026#34;,\u0026#34;created\u0026#34;:1729826955205,\u0026#34;text\u0026#34;:\u0026#34;按传输介质分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54km5x9ck00\u0026#34;,\u0026#34;created\u0026#34;:1729827341081,\u0026#34;text\u0026#34;:\u0026#34;有线\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54km6zckm00\u0026#34;,\u0026#34;created\u0026#34;:1729827343384,\u0026#34;text\u0026#34;:\u0026#34;无线\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54korvds7k0\u0026#34;,\u0026#34;created\u0026#34;:1729827545585,\u0026#34;text\u0026#34;:\u0026#34;计算机性能指标\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kozzmbc80\u0026#34;,\u0026#34;created\u0026#34;:1729827563255,\u0026#34;text\u0026#34;:\u0026#34;速率，带宽等等\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k4trsc6w0\u0026#34;,\u0026#34;created\u0026#34;:1729825982438,\u0026#34;text\u0026#34;:\u0026#34;计算机网络体系结构与参考模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kshbr58g0\u0026#34;,\u0026#34;created\u0026#34;:1729827836087,\u0026#34;text\u0026#34;:\u0026#34;体系结构是抽象的，而实现则是具体的\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ksimksbk0\u0026#34;,\u0026#34;created\u0026#34;:1729827838918,\u0026#34;text\u0026#34;:\u0026#34;计算机网络协议，接口，服务的概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kums6vy00\u0026#34;,\u0026#34;created\u0026#34;:1729828004693,\u0026#34;text\u0026#34;:\u0026#34;协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kwwrjasw0\u0026#34;,\u0026#34;created\u0026#34;:1729828183149,\u0026#34;text\u0026#34;:\u0026#34;语法\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxkaa5uw0\u0026#34;,\u0026#34;created\u0026#34;:1729828234349,\u0026#34;text\u0026#34;:\u0026#34;数据与控制信息的格式\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kwxuls7c0\u0026#34;,\u0026#34;created\u0026#34;:1729828185512,\u0026#34;text\u0026#34;:\u0026#34;语义\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxlc52sw0\u0026#34;,\u0026#34;created\u0026#34;:1729828236638,\u0026#34;text\u0026#34;:\u0026#34;需要发出何种控制信息，完成何种动作及做出何种应答\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:17.999999463558197,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kx2cieao0\u0026#34;,\u0026#34;created\u0026#34;:1729828195302,\u0026#34;text\u0026#34;:\u0026#34;同步\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:7.999999761581421,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kxmzscps0\u0026#34;,\u0026#34;created\u0026#34;:1729828240245,\u0026#34;text\u0026#34;:\u0026#34;执行各种操作的条件和时序关系\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kunkmxmg0\u0026#34;,\u0026#34;created\u0026#34;:1729828006413,\u0026#34;text\u0026#34;:\u0026#34;同一接口内相邻两层的实体交换信息的逻辑接口为服务访问点\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54kuos5yu00\u0026#34;,\u0026#34;created\u0026#34;:1729828009045,\u0026#34;text\u0026#34;:\u0026#34;服务是指下层为紧邻的上层提供的功能调用\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l1zetp5s0\u0026#34;,\u0026#34;created\u0026#34;:1729828580732,\u0026#34;text\u0026#34;:\u0026#34;模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l24w3nbk0\u0026#34;,\u0026#34;created\u0026#34;:1729828592661,\u0026#34;text\u0026#34;:\u0026#34;学术上的模型\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2l2e0xs0\u0026#34;,\u0026#34;created\u0026#34;:1729828627869,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2oblctc0\u0026#34;,\u0026#34;created\u0026#34;:1729828634956,\u0026#34;text\u0026#34;:\u0026#34;表示层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2p92lhc0\u0026#34;,\u0026#34;created\u0026#34;:1729828636980,\u0026#34;text\u0026#34;:\u0026#34;会话层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2qfsz540\u0026#34;,\u0026#34;created\u0026#34;:1729828639564,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2slci7c0\u0026#34;,\u0026#34;created\u0026#34;:1729828644253,\u0026#34;text\u0026#34;:\u0026#34;网络层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2tsgnhs0\u0026#34;,\u0026#34;created\u0026#34;:1729828646860,\u0026#34;text\u0026#34;:\u0026#34;数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2x0rzy80\u0026#34;,\u0026#34;created\u0026#34;:1729828653893,\u0026#34;text\u0026#34;:\u0026#34;物理层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l25x4oko0\u0026#34;,\u0026#34;created\u0026#34;:1729828594900,\u0026#34;text\u0026#34;:\u0026#34;实际的模型\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l2m6g9wg0\u0026#34;,\u0026#34;created\u0026#34;:1729828630292,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l433nutk0\u0026#34;,\u0026#34;created\u0026#34;:1729828745492,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l4458dx40\u0026#34;,\u0026#34;created\u0026#34;:1729828747764,\u0026#34;text\u0026#34;:\u0026#34;网际层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l458wi2o0\u0026#34;,\u0026#34;created\u0026#34;:1729828750163,\u0026#34;text\u0026#34;:\u0026#34;网络接口层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzardkig0\u0026#34;,\u0026#34;created\u0026#34;:1729825549233,\u0026#34;text\u0026#34;:\u0026#34;物理层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9gvwxyg0\u0026#34;,\u0026#34;created\u0026#34;:1729829167320,\u0026#34;text\u0026#34;:\u0026#34;通信基础\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lcg8jwqg0\u0026#34;,\u0026#34;created\u0026#34;:1729829401000,\u0026#34;text\u0026#34;:\u0026#34;奈式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lcis0d9s0\u0026#34;,\u0026#34;created\u0026#34;:1729829406530,\u0026#34;text\u0026#34;:\u0026#34;香农定理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lm5sv2k00\u0026#34;,\u0026#34;created\u0026#34;:1729830161925,\u0026#34;text\u0026#34;:\u0026#34;不归0编码，归0编码，反向非归零编码，曼彻斯特编码，差分曼彻斯特编码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9pbu59c0\u0026#34;,\u0026#34;created\u0026#34;:1729829185697,\u0026#34;text\u0026#34;:\u0026#34;传输介质\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ltgugi680\u0026#34;,\u0026#34;created\u0026#34;:1729830734515,\u0026#34;text\u0026#34;:\u0026#34;双绞线，同轴电缆，光纤\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ltiy4tuo0\u0026#34;,\u0026#34;created\u0026#34;:1729830739091,\u0026#34;text\u0026#34;:\u0026#34;物理层接口的特性\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwfjiw600\u0026#34;,\u0026#34;created\u0026#34;:1729830966770,\u0026#34;text\u0026#34;:\u0026#34;机械特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lxa6145s0\u0026#34;,\u0026#34;created\u0026#34;:1729831033434,\u0026#34;text\u0026#34;:\u0026#34;指名所用接线器的形状和尺寸\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwgipyiw0\u0026#34;,\u0026#34;created\u0026#34;:1729830968898,\u0026#34;text\u0026#34;:\u0026#34;电气特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lxuj57c80\u0026#34;,\u0026#34;created\u0026#34;:1729831077763,\u0026#34;text\u0026#34;:\u0026#34;电压范围\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwhips2o0\u0026#34;,\u0026#34;created\u0026#34;:1729830971074,\u0026#34;text\u0026#34;:\u0026#34;功能特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ly1ua9r40\u0026#34;,\u0026#34;created\u0026#34;:1729831093674,\u0026#34;text\u0026#34;:\u0026#34;指名功能\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lwka2jl40\u0026#34;,\u0026#34;created\u0026#34;:1729830977082,\u0026#34;text\u0026#34;:\u0026#34;过程特性\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ly9v8g8w0\u0026#34;,\u0026#34;created\u0026#34;:1729831111145,\u0026#34;text\u0026#34;:\u0026#34;指明各种可能事件的出现词序\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54l9r9ajyo0\u0026#34;,\u0026#34;created\u0026#34;:1729829189897,\u0026#34;text\u0026#34;:\u0026#34;物理层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lzycu8vk0\u0026#34;,\u0026#34;created\u0026#34;:1729831242817,\u0026#34;text\u0026#34;:\u0026#34;中继器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m0g5h17k0\u0026#34;,\u0026#34;created\u0026#34;:1729831281553,\u0026#34;text\u0026#34;:\u0026#34;信号再生\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54lzza7mj40\u0026#34;,\u0026#34;created\u0026#34;:1729831244835,\u0026#34;text\u0026#34;:\u0026#34;集线器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m0h6jitk0\u0026#34;,\u0026#34;created\u0026#34;:1729831283795,\u0026#34;text\u0026#34;:\u0026#34;中继器的集合\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:7.999999761581421,\u0026#34;y\u0026#34;:3.9999998807907104}},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzeebe5k0\u0026#34;,\u0026#34;created\u0026#34;:1729825557151,\u0026#34;text\u0026#34;:\u0026#34; 数据链路层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m190l6v40\u0026#34;,\u0026#34;created\u0026#34;:1729831344385,\u0026#34;text\u0026#34;:\u0026#34;数据链路层的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6ec6vug0\u0026#34;,\u0026#34;created\u0026#34;:1729831747791,\u0026#34;text\u0026#34;:\u0026#34;为网络层提供服务\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6f94r7c0\u0026#34;,\u0026#34;created\u0026#34;:1729831749783,\u0026#34;text\u0026#34;:\u0026#34;链路管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6wcvvvs0\u0026#34;,\u0026#34;created\u0026#34;:1729831787015,\u0026#34;text\u0026#34;:\u0026#34;封装成帧与透明传输\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m6xjmh7s0\u0026#34;,\u0026#34;created\u0026#34;:1729831789599,\u0026#34;text\u0026#34;:\u0026#34;流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mc33f1yg0\u0026#34;,\u0026#34;created\u0026#34;:1729832193501,\u0026#34;text\u0026#34;:\u0026#34;差错检测\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m1a1i88w0\u0026#34;,\u0026#34;created\u0026#34;:1729831346617,\u0026#34;text\u0026#34;:\u0026#34;组帧\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdh435zc0\u0026#34;,\u0026#34;created\u0026#34;:1729832302381,\u0026#34;text\u0026#34;:\u0026#34;字符计数法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdi8povk0\u0026#34;,\u0026#34;created\u0026#34;:1729832304837,\u0026#34;text\u0026#34;:\u0026#34;字节填充法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdjivt1k0\u0026#34;,\u0026#34;created\u0026#34;:1729832307629,\u0026#34;text\u0026#34;:\u0026#34;零比特填充法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mdkqa79c0\u0026#34;,\u0026#34;created\u0026#34;:1729832310253,\u0026#34;text\u0026#34;:\u0026#34;违规编码法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m1b18ipk0\u0026#34;,\u0026#34;created\u0026#34;:1729831348777,\u0026#34;text\u0026#34;:\u0026#34;差错控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mm8cy0hk0\u0026#34;,\u0026#34;created\u0026#34;:1729832988603,\u0026#34;text\u0026#34;:\u0026#34;奇偶检验码\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mm9h0rlc0\u0026#34;,\u0026#34;created\u0026#34;:1729832991026,\u0026#34;text\u0026#34;:\u0026#34;循环冗余码\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mofn051c0\u0026#34;,\u0026#34;created\u0026#34;:1729833161177,\u0026#34;text\u0026#34;:\u0026#34;纠错编码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m2r0swk80\u0026#34;,\u0026#34;created\u0026#34;:1729831461944,\u0026#34;text\u0026#34;:\u0026#34;流量控制与可靠传输机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mpn3xi0o0\u0026#34;,\u0026#34;created\u0026#34;:1729833255802,\u0026#34;text\u0026#34;:\u0026#34;流量控制与滑动窗口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mrszhttc0\u0026#34;,\u0026#34;created\u0026#34;:1729833425323,\u0026#34;text\u0026#34;:\u0026#34;停止-等待流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mru0y8200\u0026#34;,\u0026#34;created\u0026#34;:1729833427587,\u0026#34;text\u0026#34;:\u0026#34;滑动窗口流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mpo89oio0\u0026#34;,\u0026#34;created\u0026#34;:1729833258241,\u0026#34;text\u0026#34;:\u0026#34;可靠传输机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mtixgbew0\u0026#34;,\u0026#34;created\u0026#34;:1729833560160,\u0026#34;text\u0026#34;:\u0026#34;ARQ\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mu8b5l600\u0026#34;,\u0026#34;created\u0026#34;:1729833615408,\u0026#34;text\u0026#34;:\u0026#34;停止-等待协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54mu9c2q2g0\u0026#34;,\u0026#34;created\u0026#34;:1729833617640,\u0026#34;text\u0026#34;:\u0026#34;后退N帧协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54muai56880\u0026#34;,\u0026#34;created\u0026#34;:1729833620184,\u0026#34;text\u0026#34;:\u0026#34;选择重传协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m332mkg00\u0026#34;,\u0026#34;created\u0026#34;:1729831488176,\u0026#34;text\u0026#34;:\u0026#34;介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n13vr4yo0\u0026#34;,\u0026#34;created\u0026#34;:1729834154318,\u0026#34;text\u0026#34;:\u0026#34;信道划分介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n20zjv2g0\u0026#34;,\u0026#34;created\u0026#34;:1729834226382,\u0026#34;text\u0026#34;:\u0026#34;频分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n226f1gw0\u0026#34;,\u0026#34;created\u0026#34;:1729834228974,\u0026#34;text\u0026#34;:\u0026#34;时分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n239bc1k0\u0026#34;,\u0026#34;created\u0026#34;:1729834231326,\u0026#34;text\u0026#34;:\u0026#34;波分复用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n248sdq80\u0026#34;,\u0026#34;created\u0026#34;:1729834233471,\u0026#34;text\u0026#34;:\u0026#34;码分复用\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n15hji0g0\u0026#34;,\u0026#34;created\u0026#34;:1729834157813,\u0026#34;text\u0026#34;:\u0026#34;随机访问介质访问控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3do245s0\u0026#34;,\u0026#34;created\u0026#34;:1729834332349,\u0026#34;text\u0026#34;:\u0026#34;ALOHA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3f26es00\u0026#34;,\u0026#34;created\u0026#34;:1729834335380,\u0026#34;text\u0026#34;:\u0026#34;时隙ALOHA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3nbhjk00\u0026#34;,\u0026#34;created\u0026#34;:1729834353357,\u0026#34;text\u0026#34;:\u0026#34;CSMA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3r5csco0\u0026#34;,\u0026#34;created\u0026#34;:1729834361693,\u0026#34;text\u0026#34;:\u0026#34;CSMA/CD协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n3s3w1q00\u0026#34;,\u0026#34;created\u0026#34;:1729834363781,\u0026#34;text\u0026#34;:\u0026#34;CSMA/CA协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54n8rzjgzc0\u0026#34;,\u0026#34;created\u0026#34;:1729834755339,\u0026#34;text\u0026#34;:\u0026#34;轮询访问:令牌传递协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3e81nz40\u0026#34;,\u0026#34;created\u0026#34;:1729831512448,\u0026#34;text\u0026#34;:\u0026#34;局域网\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd3bsx1c0\u0026#34;,\u0026#34;created\u0026#34;:1729835093482,\u0026#34;text\u0026#34;:\u0026#34;数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54neoev6a80\u0026#34;,\u0026#34;created\u0026#34;:1729835217744,\u0026#34;text\u0026#34;:\u0026#34;介质访问控制子层\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nepe2jaw0\u0026#34;,\u0026#34;created\u0026#34;:1729835219872,\u0026#34;text\u0026#34;:\u0026#34;逻辑链路控制子层\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd6gsmeo0\u0026#34;,\u0026#34;created\u0026#34;:1729835100314,\u0026#34;text\u0026#34;:\u0026#34;以太网与IEE802.3\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd7ueksw0\u0026#34;,\u0026#34;created\u0026#34;:1729835103314,\u0026#34;text\u0026#34;:\u0026#34;IEEE 802.11无线局域网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nd8zjka80\u0026#34;,\u0026#34;created\u0026#34;:1729835105801,\u0026#34;text\u0026#34;:\u0026#34;VLAN基本概念与基本原理\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3i0q0sg0\u0026#34;,\u0026#34;created\u0026#34;:1729831520712,\u0026#34;text\u0026#34;:\u0026#34;广域网\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54njg5rm4o0\u0026#34;,\u0026#34;created\u0026#34;:1729835591600,\u0026#34;text\u0026#34;:\u0026#34;PPP协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54njhvy3zc0\u0026#34;,\u0026#34;created\u0026#34;:1729835595360,\u0026#34;text\u0026#34;:\u0026#34;广域网通俗来讲就是覆盖很大的网络\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54m3lntx2g0\u0026#34;,\u0026#34;created\u0026#34;:1729831528640,\u0026#34;text\u0026#34;:\u0026#34;数据链路层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nl546dn40\u0026#34;,\u0026#34;created\u0026#34;:1729835724288,\u0026#34;text\u0026#34;:\u0026#34;网桥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nlai9v6w0\u0026#34;,\u0026#34;created\u0026#34;:1729835736024,\u0026#34;text\u0026#34;:\u0026#34;以太网交换器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nmcj851k0\u0026#34;,\u0026#34;created\u0026#34;:1729835818799,\u0026#34;text\u0026#34;:\u0026#34;自学习\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nmdkuc940\u0026#34;,\u0026#34;created\u0026#34;:1729835821074,\u0026#34;text\u0026#34;:\u0026#34;工作在数据链路层\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzf530i80\u0026#34;,\u0026#34;created\u0026#34;:1729825558769,\u0026#34;text\u0026#34;:\u0026#34;网络层 \u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nno151iw0\u0026#34;,\u0026#34;created\u0026#34;:1729835922191,\u0026#34;text\u0026#34;:\u0026#34;网络层的功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54npthgvvc0\u0026#34;,\u0026#34;created\u0026#34;:1729836090791,\u0026#34;text\u0026#34;:\u0026#34;异构网络互联\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nq92yjmw0\u0026#34;,\u0026#34;created\u0026#34;:1729836124742,\u0026#34;text\u0026#34;:\u0026#34;路由与转发\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nqux0dy00\u0026#34;,\u0026#34;created\u0026#34;:1729836172272,\u0026#34;text\u0026#34;:\u0026#34;网络层提供的两种服务\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nr4o4by00\u0026#34;,\u0026#34;created\u0026#34;:1729836193502,\u0026#34;text\u0026#34;:\u0026#34;虚电路\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nr5zr01k0\u0026#34;,\u0026#34;created\u0026#34;:1729836196382,\u0026#34;text\u0026#34;:\u0026#34;数据报\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nrp17a8w0\u0026#34;,\u0026#34;created\u0026#34;:1729836237829,\u0026#34;text\u0026#34;:\u0026#34;SDN\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ns906crs0\u0026#34;,\u0026#34;created\u0026#34;:1729836281302,\u0026#34;text\u0026#34;:\u0026#34;拥塞控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nsczgicg0\u0026#34;,\u0026#34;created\u0026#34;:1729836289966,\u0026#34;text\u0026#34;:\u0026#34;开环控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nse1ew7c0\u0026#34;,\u0026#34;created\u0026#34;:1729836292261,\u0026#34;text\u0026#34;:\u0026#34;闭环控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnr409p40\u0026#34;,\u0026#34;created\u0026#34;:1729835928895,\u0026#34;text\u0026#34;:\u0026#34;IPV4\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntdmsduo0\u0026#34;,\u0026#34;created\u0026#34;:1729836369741,\u0026#34;text\u0026#34;:\u0026#34;ip分组\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nywgvno80\u0026#34;,\u0026#34;created\u0026#34;:1729836802563,\u0026#34;text\u0026#34;:\u0026#34;ip数据报分片\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o09kqilk0\u0026#34;,\u0026#34;created\u0026#34;:1729836909459,\u0026#34;text\u0026#34;:\u0026#34;划分子网与路由聚合\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0t2rank0\u0026#34;,\u0026#34;created\u0026#34;:1729836951907,\u0026#34;text\u0026#34;:\u0026#34;划分子网\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0u1y7g00\u0026#34;,\u0026#34;created\u0026#34;:1729836954035,\u0026#34;text\u0026#34;:\u0026#34;子网掩码和默认网关\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o0vjt6kw0\u0026#34;,\u0026#34;created\u0026#34;:1729836957292,\u0026#34;text\u0026#34;:\u0026#34;无分类编址CIDR\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o22fxf8g0\u0026#34;,\u0026#34;created\u0026#34;:1729837050659,\u0026#34;text\u0026#34;:\u0026#34;路由聚合\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o2b22d140\u0026#34;,\u0026#34;created\u0026#34;:1729837069412,\u0026#34;text\u0026#34;:\u0026#34;子网的划分\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntrnyqyw0\u0026#34;,\u0026#34;created\u0026#34;:1729836400287,\u0026#34;text\u0026#34;:\u0026#34;ip地址与NAT\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nziz8ye00\u0026#34;,\u0026#34;created\u0026#34;:1729836851563,\u0026#34;text\u0026#34;:\u0026#34;IPv4地址与NAT(网络地址转换)\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntszfbkw0\u0026#34;,\u0026#34;created\u0026#34;:1729836403157,\u0026#34;text\u0026#34;:\u0026#34;地址解析协议\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o3cnsgps0\u0026#34;,\u0026#34;created\u0026#34;:1729837151266,\u0026#34;text\u0026#34;:\u0026#34;物理地址与ip地址的映射\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntu5i8b40\u0026#34;,\u0026#34;created\u0026#34;:1729836405701,\u0026#34;text\u0026#34;:\u0026#34;动态主机配置协议DHCP\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o4gkd49s0\u0026#34;,\u0026#34;created\u0026#34;:1729837238130,\u0026#34;text\u0026#34;:\u0026#34;动态分配ip地址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ntxhrumo0\u0026#34;,\u0026#34;created\u0026#34;:1729836412973,\u0026#34;text\u0026#34;:\u0026#34;网际控制报文协议ICMP\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nns2j6jk0\u0026#34;,\u0026#34;created\u0026#34;:1729835930983,\u0026#34;text\u0026#34;:\u0026#34;IPV6\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o5j4e2sw0\u0026#34;,\u0026#34;created\u0026#34;:1729837322059,\u0026#34;text\u0026#34;:\u0026#34;为了打破ipv4快没的问题\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nntkwwps0\u0026#34;,\u0026#34;created\u0026#34;:1729835934271,\u0026#34;text\u0026#34;:\u0026#34;路由算法与路由协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7bd6ng00\u0026#34;,\u0026#34;created\u0026#34;:1729837461905,\u0026#34;text\u0026#34;:\u0026#34;静态路由\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7cbl9iw0\u0026#34;,\u0026#34;created\u0026#34;:1729837463985,\u0026#34;text\u0026#34;:\u0026#34;动态路由\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o7pp1m5c0\u0026#34;,\u0026#34;created\u0026#34;:1729837493097,\u0026#34;text\u0026#34;:\u0026#34;距离-向量路由算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o88n6x5s0\u0026#34;,\u0026#34;created\u0026#34;:1729837534344,\u0026#34;text\u0026#34;:\u0026#34;链路状态路由算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9f2jlr40\u0026#34;,\u0026#34;created\u0026#34;:1729837626697,\u0026#34;text\u0026#34;:\u0026#34;路由选择协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9oi6gbc0\u0026#34;,\u0026#34;created\u0026#34;:1729837647233,\u0026#34;text\u0026#34;:\u0026#34;内部网关协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oajvdj2o0\u0026#34;,\u0026#34;created\u0026#34;:1729837715511,\u0026#34;text\u0026#34;:\u0026#34;RIP路由信息协议\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oawwjrow0\u0026#34;,\u0026#34;created\u0026#34;:1729837743881,\u0026#34;text\u0026#34;:\u0026#34;OSPF开放最短路径优先协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54o9pccsm80\u0026#34;,\u0026#34;created\u0026#34;:1729837649058,\u0026#34;text\u0026#34;:\u0026#34;外部网关协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54obejgvq00\u0026#34;,\u0026#34;created\u0026#34;:1729837782272,\u0026#34;text\u0026#34;:\u0026#34; 边界网关协议BGP\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnxunue80\u0026#34;,\u0026#34;created\u0026#34;:1729835943567,\u0026#34;text\u0026#34;:\u0026#34;IP多播\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54nnyv2m800\u0026#34;,\u0026#34;created\u0026#34;:1729835945769,\u0026#34;text\u0026#34;:\u0026#34;移动IP\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54no032q140\u0026#34;,\u0026#34;created\u0026#34;:1729835948430,\u0026#34;text\u0026#34;:\u0026#34;网络层设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oggo80bk0\u0026#34;,\u0026#34;created\u0026#34;:1729838178734,\u0026#34;text\u0026#34;:\u0026#34;冲突域\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oghpxvb40\u0026#34;,\u0026#34;created\u0026#34;:1729838181014,\u0026#34;text\u0026#34;:\u0026#34;广播域\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ohbmnue80\u0026#34;,\u0026#34;created\u0026#34;:1729838246119,\u0026#34;text\u0026#34;:\u0026#34;路由表由路由处理机和交换结构组成\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oiopb2jc0\u0026#34;,\u0026#34;created\u0026#34;:1729838352942,\u0026#34;text\u0026#34;:\u0026#34;路由表与分组转发\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54jzhljw4w0\u0026#34;,\u0026#34;created\u0026#34;:1729825564118,\u0026#34;text\u0026#34;:\u0026#34;传输层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ol1ap5b40\u0026#34;,\u0026#34;created\u0026#34;:1729838537085,\u0026#34;text\u0026#34;:\u0026#34;传输层提供的服务\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ome4ic9c0\u0026#34;,\u0026#34;created\u0026#34;:1729838643373,\u0026#34;text\u0026#34;:\u0026#34;应用进程之间的逻辑通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54omf28nmg0\u0026#34;,\u0026#34;created\u0026#34;:1729838645413,\u0026#34;text\u0026#34;:\u0026#34;复用与分用\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oo8f4jz40\u0026#34;,\u0026#34;created\u0026#34;:1729838787683,\u0026#34;text\u0026#34;:\u0026#34;检错检测\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oohr72t40\u0026#34;,\u0026#34;created\u0026#34;:1729838808003,\u0026#34;text\u0026#34;:\u0026#34;提供面向连接和无连接的传输协议\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ol310mf40\u0026#34;,\u0026#34;created\u0026#34;:1729838540853,\u0026#34;text\u0026#34;:\u0026#34;UDP协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54opducdgg0\u0026#34;,\u0026#34;created\u0026#34;:1729838877851,\u0026#34;text\u0026#34;:\u0026#34;udp首部为20b\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oqdozlc00\u0026#34;,\u0026#34;created\u0026#34;:1729838955891,\u0026#34;text\u0026#34;:\u0026#34;udp检验\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54olts28zs0\u0026#34;,\u0026#34;created\u0026#34;:1729838599085,\u0026#34;text\u0026#34;:\u0026#34;TCP协议\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oqn81t940\u0026#34;,\u0026#34;created\u0026#34;:1729838976635,\u0026#34;text\u0026#34;:\u0026#34;面向字节流\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54osruvn9s0\u0026#34;,\u0026#34;created\u0026#34;:1729839143451,\u0026#34;text\u0026#34;:\u0026#34;三握手\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ost0a7fs0\u0026#34;,\u0026#34;created\u0026#34;:1729839145954,\u0026#34;text\u0026#34;:\u0026#34;四挥手\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54otymmnds0\u0026#34;,\u0026#34;created\u0026#34;:1729839236554,\u0026#34;text\u0026#34;:\u0026#34;TCP流量控制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54otzlpf680\u0026#34;,\u0026#34;created\u0026#34;:1729839238674,\u0026#34;text\u0026#34;:\u0026#34;TCP拥塞控制\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54k2igfggw0\u0026#34;,\u0026#34;created\u0026#34;:1729825801078,\u0026#34;text\u0026#34;:\u0026#34;应用层\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om4n6v680\u0026#34;,\u0026#34;created\u0026#34;:1729838622735,\u0026#34;text\u0026#34;:\u0026#34;网络应用模型\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ouw5n5e00\u0026#34;,\u0026#34;created\u0026#34;:1729839309537,\u0026#34;text\u0026#34;:\u0026#34;客户/服务器模型\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ouxghae00\u0026#34;,\u0026#34;created\u0026#34;:1729839312369,\u0026#34;text\u0026#34;:\u0026#34;P2P模型\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om5p4law0\u0026#34;,\u0026#34;created\u0026#34;:1729838625029,\u0026#34;text\u0026#34;:\u0026#34;DNS(域名系统)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54owijm3q00\u0026#34;,\u0026#34;created\u0026#34;:1729839436635,\u0026#34;text\u0026#34;:\u0026#34;层次域名空间\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54ox4pim5c0\u0026#34;,\u0026#34;created\u0026#34;:1729839484881,\u0026#34;text\u0026#34;:\u0026#34;从后往前域名等级减小\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54owjp0khs0\u0026#34;,\u0026#34;created\u0026#34;:1729839439138,\u0026#34;text\u0026#34;:\u0026#34;域名服务器\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyb66cdc0\u0026#34;,\u0026#34;created\u0026#34;:1729839577313,\u0026#34;text\u0026#34;:\u0026#34;根域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyc9po4w0\u0026#34;,\u0026#34;created\u0026#34;:1729839579704,\u0026#34;text\u0026#34;:\u0026#34;顶级域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oydm51rs0\u0026#34;,\u0026#34;created\u0026#34;:1729839582632,\u0026#34;text\u0026#34;:\u0026#34;权限域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oyek10j40\u0026#34;,\u0026#34;created\u0026#34;:1729839584681,\u0026#34;text\u0026#34;:\u0026#34;本地域名服务器\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54om6p93vs0\u0026#34;,\u0026#34;created\u0026#34;:1729838627213,\u0026#34;text\u0026#34;:\u0026#34;文件传输协议(FTP)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54oma91zig0\u0026#34;,\u0026#34;created\u0026#34;:1729838634941,\u0026#34;text\u0026#34;:\u0026#34;电子邮件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d54omb7305s0\u0026#34;,\u0026#34;created\u0026#34;:1729838636998,\u0026#34;text\u0026#34;:\u0026#34;万维网\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},\u0026#34;template\u0026#34;:\u0026#34;structure\u0026#34;,\u0026#34;theme\u0026#34;:\u0026#34;fresh-blue\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.4.33\u0026#34;} ","date":"2024-10-25T15:17:45+08:00","image":"https://getshhi.github.io/kj1.png","permalink":"https://getshhi.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","title":"计算机网络思维导图"},{"content":"下面是我弄的思维导图 大致图片 json 这个可以在菜鸟工具上看到 在线思维导图(创建json文件,然后再复制下面的,在该网站导入json文件即可)\n1 {\u0026#34;root\u0026#34;:{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtfin28kg0\u0026#34;,\u0026#34;created\u0026#34;:1717055655662,\u0026#34;text\u0026#34;:\u0026#34;操作系统\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtikgl32w0\u0026#34;,\u0026#34;created\u0026#34;:1717055894717,\u0026#34;text\u0026#34;:\u0026#34;计算机系统概述\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:-50.0000234842297,\u0026#34;y\u0026#34;:27.499998621642987}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtle0xqow0\u0026#34;,\u0026#34;created\u0026#34;:1717056115802,\u0026#34;text\u0026#34;:\u0026#34;操作系统的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtmg261eg0\u0026#34;,\u0026#34;created\u0026#34;:1717056198594,\u0026#34;text\u0026#34;:\u0026#34;操作系统的特怔\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto55h7cg0\u0026#34;,\u0026#34;created\u0026#34;:1717056331578,\u0026#34;text\u0026#34;:\u0026#34;并发\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto68ribs0\u0026#34;,\u0026#34;created\u0026#34;:1717056333954,\u0026#34;text\u0026#34;:\u0026#34;共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto7aqv000\u0026#34;,\u0026#34;created\u0026#34;:1717056336250,\u0026#34;text\u0026#34;:\u0026#34;虚拟\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mto875mpk0\u0026#34;,\u0026#34;created\u0026#34;:1717056338210,\u0026#34;text\u0026#34;:\u0026#34;异步\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtmgze06o0\u0026#34;,\u0026#34;created\u0026#34;:1717056200603,\u0026#34;text\u0026#34;:\u0026#34;操作系统的目标和功能\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtr270l400\u0026#34;,\u0026#34;created\u0026#34;:1717056560233,\u0026#34;text\u0026#34;:\u0026#34;计算机资源的管理者\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrktsxbk0\u0026#34;,\u0026#34;created\u0026#34;:1717056600793,\u0026#34;text\u0026#34;:\u0026#34;处理机\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrpewyfk0\u0026#34;,\u0026#34;created\u0026#34;:1717056610777,\u0026#34;text\u0026#34;:\u0026#34;存储器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mts8lpj740\u0026#34;,\u0026#34;created\u0026#34;:1717056652547,\u0026#34;text\u0026#34;:\u0026#34;文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtsd33b8g0\u0026#34;,\u0026#34;created\u0026#34;:1717056662305,\u0026#34;text\u0026#34;:\u0026#34;设备\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtrbo3bs00\u0026#34;,\u0026#34;created\u0026#34;:1717056580857,\u0026#34;text\u0026#34;:\u0026#34;用户与计算机的接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtuavjtds0\u0026#34;,\u0026#34;created\u0026#34;:1717056814224,\u0026#34;text\u0026#34;:\u0026#34;命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtve7wp280\u0026#34;,\u0026#34;created\u0026#34;:1717056899865,\u0026#34;text\u0026#34;:\u0026#34;联机命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtw6ps09k0\u0026#34;,\u0026#34;created\u0026#34;:1717056961896,\u0026#34;text\u0026#34;:\u0026#34;一条命令一条作业\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtvpkbtgw0\u0026#34;,\u0026#34;created\u0026#34;:1717056924561,\u0026#34;text\u0026#34;:\u0026#34;脱机命令接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtwpj2ahs0\u0026#34;,\u0026#34;created\u0026#34;:1717057002849,\u0026#34;text\u0026#34;:\u0026#34;多条命令多条作业\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtushp87s0\u0026#34;,\u0026#34;created\u0026#34;:1717056852568,\u0026#34;text\u0026#34;:\u0026#34;程序接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtx0dh1u80\u0026#34;,\u0026#34;created\u0026#34;:1717057026455,\u0026#34;text\u0026#34;:\u0026#34;gui接口\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtxrpya200\u0026#34;,\u0026#34;created\u0026#34;:1717057085983,\u0026#34;text\u0026#34;:\u0026#34;操作系统发展历程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty5enjjc0\u0026#34;,\u0026#34;created\u0026#34;:1717057115775,\u0026#34;text\u0026#34;:\u0026#34;手工操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty68tgtc0\u0026#34;,\u0026#34;created\u0026#34;:1717057117599,\u0026#34;text\u0026#34;:\u0026#34;批处理系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu0awpr2o0\u0026#34;,\u0026#34;created\u0026#34;:1717057284479,\u0026#34;text\u0026#34;:\u0026#34;单道批处理系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu0btwuhc0\u0026#34;,\u0026#34;created\u0026#34;:1717057286486,\u0026#34;text\u0026#34;:\u0026#34;多道批处理系统\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty70ly3k0\u0026#34;,\u0026#34;created\u0026#34;:1717057119279,\u0026#34;text\u0026#34;:\u0026#34;分时操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty7yc8zk0\u0026#34;,\u0026#34;created\u0026#34;:1717057121319,\u0026#34;text\u0026#34;:\u0026#34;实时操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mty8r1xfc0\u0026#34;,\u0026#34;created\u0026#34;:1717057123055,\u0026#34;text\u0026#34;:\u0026#34;网络操作系统和分步式计算机系统\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu3wtfbsg0\u0026#34;,\u0026#34;created\u0026#34;:1717057567262,\u0026#34;text\u0026#34;:\u0026#34;个人操作系统\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu81h0m0o0\u0026#34;,\u0026#34;created\u0026#34;:1717057890852,\u0026#34;text\u0026#34;:\u0026#34;操作系统的运行环境\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu8hukjew0\u0026#34;,\u0026#34;created\u0026#34;:1717057926500,\u0026#34;text\u0026#34;:\u0026#34;内核态\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua5d0f5s0\u0026#34;,\u0026#34;created\u0026#34;:1717058056045,\u0026#34;text\u0026#34;:\u0026#34;时钟管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua67ojgg0\u0026#34;,\u0026#34;created\u0026#34;:1717058057900,\u0026#34;text\u0026#34;:\u0026#34;中断机制\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mua73z3wo0\u0026#34;,\u0026#34;created\u0026#34;:1717058059852,\u0026#34;text\u0026#34;:\u0026#34;原语\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muatq16k00\u0026#34;,\u0026#34;created\u0026#34;:1717058109075,\u0026#34;text\u0026#34;:\u0026#34;系统控制的数据结构与处理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muc2wlbl40\u0026#34;,\u0026#34;created\u0026#34;:1717058207427,\u0026#34;text\u0026#34;:\u0026#34;进程管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mucdbszfs0\u0026#34;,\u0026#34;created\u0026#34;:1717058230115,\u0026#34;text\u0026#34;:\u0026#34;存储器管理\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mucn1rbts0\u0026#34;,\u0026#34;created\u0026#34;:1717058251275,\u0026#34;text\u0026#34;:\u0026#34;设备管理\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mu9lyf76o0\u0026#34;,\u0026#34;created\u0026#34;:1717058013804,\u0026#34;text\u0026#34;:\u0026#34;非内核态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mudmh184w0\u0026#34;,\u0026#34;created\u0026#34;:1717058328386,\u0026#34;text\u0026#34;:\u0026#34;中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muduyiupc0\u0026#34;,\u0026#34;created\u0026#34;:1717058346858,\u0026#34;text\u0026#34;:\u0026#34;外部中断(硬件)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsazmwxag0\u0026#34;,\u0026#34;created\u0026#34;:1717154039684,\u0026#34;text\u0026#34;:\u0026#34;可屏蔽中断INTR\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsb0ji1oo0\u0026#34;,\u0026#34;created\u0026#34;:1717154041655,\u0026#34;text\u0026#34;:\u0026#34;不可屏蔽中断NMI\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mudwaev8o0\u0026#34;,\u0026#34;created\u0026#34;:1717058349754,\u0026#34;text\u0026#34;:\u0026#34;内部异常\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mueg4mezs0\u0026#34;,\u0026#34;created\u0026#34;:1717058392939,\u0026#34;text\u0026#34;:\u0026#34;软件中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mufr3qty80\u0026#34;,\u0026#34;created\u0026#34;:1717058495195,\u0026#34;text\u0026#34;:\u0026#34;故障\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muh1murs00\u0026#34;,\u0026#34;created\u0026#34;:1717058596482,\u0026#34;text\u0026#34;:\u0026#34;自己写的指令\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mufs7jsdc0\u0026#34;,\u0026#34;created\u0026#34;:1717058497602,\u0026#34;text\u0026#34;:\u0026#34;自陷\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muh79scg00\u0026#34;,\u0026#34;created\u0026#34;:1717058608753,\u0026#34;text\u0026#34;:\u0026#34;系统调用\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muexa77480\u0026#34;,\u0026#34;created\u0026#34;:1717058430282,\u0026#34;text\u0026#34;:\u0026#34;硬件中断\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mug7ruvz40\u0026#34;,\u0026#34;created\u0026#34;:1717058531482,\u0026#34;text\u0026#34;:\u0026#34;终止\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muj4z7h340\u0026#34;,\u0026#34;created\u0026#34;:1717058760488,\u0026#34;text\u0026#34;:\u0026#34;操作系统结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mujdppck80\u0026#34;,\u0026#34;created\u0026#34;:1717058779504,\u0026#34;text\u0026#34;:\u0026#34;分层法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mujxwy1dc0\u0026#34;,\u0026#34;created\u0026#34;:1717058823478,\u0026#34;text\u0026#34;:\u0026#34;模块化\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muk8o7e740\u0026#34;,\u0026#34;created\u0026#34;:1717058846894,\u0026#34;text\u0026#34;:\u0026#34;宏内核和微内核\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muq9mgihs0\u0026#34;,\u0026#34;created\u0026#34;:1717059319150,\u0026#34;text\u0026#34;:\u0026#34;虚拟机\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muqvy826o0\u0026#34;,\u0026#34;created\u0026#34;:1717059367751,\u0026#34;text\u0026#34;:\u0026#34;第一类虚拟机管理程序\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muqwwmkw00\u0026#34;,\u0026#34;created\u0026#34;:1717059369831,\u0026#34;text\u0026#34;:\u0026#34;第二类虚拟机管理程序\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtjbmprtk0\u0026#34;,\u0026#34;created\u0026#34;:1717055953860,\u0026#34;text\u0026#34;:\u0026#34;进程与线程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu4k41qg0\u0026#34;,\u0026#34;created\u0026#34;:1717059621581,\u0026#34;text\u0026#34;:\u0026#34;进程与线程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsdrvxlbs0\u0026#34;,\u0026#34;created\u0026#34;:1717154257908,\u0026#34;text\u0026#34;:\u0026#34;进程的概念与特怔\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nseocfyj40\u0026#34;,\u0026#34;created\u0026#34;:1717154328563,\u0026#34;text\u0026#34;:\u0026#34;进程是进程实体的运行过程，是资源分配和调度的独立单位\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsgbekhvs0\u0026#34;,\u0026#34;created\u0026#34;:1717154457122,\u0026#34;text\u0026#34;:\u0026#34;动态性，并发性，独立性，异步性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nshas1yfc0\u0026#34;,\u0026#34;created\u0026#34;:1717154534125,\u0026#34;text\u0026#34;:\u0026#34;进程由进程控制块，程序段，数据段组成\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nsibvkm800\u0026#34;,\u0026#34;created\u0026#34;:1717154614878,\u0026#34;text\u0026#34;:\u0026#34;进程有五个状态运行态，阻塞态，就绪态，创建态，终止态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nspjy6w680\u0026#34;,\u0026#34;created\u0026#34;:1717155181000,\u0026#34;text\u0026#34;:\u0026#34;进程的通信分为共享存储，消息传递，管道通信\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1nswdh2kps0\u0026#34;,\u0026#34;created\u0026#34;:1717155715453,\u0026#34;text\u0026#34;:\u0026#34;线程\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu6xc0o00\u0026#34;,\u0026#34;created\u0026#34;:1717059626734,\u0026#34;text\u0026#34;:\u0026#34;cpu调度\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ntccptjts0\u0026#34;,\u0026#34;created\u0026#34;:1717156967632,\u0026#34;text\u0026#34;:\u0026#34;调度的层次分为高级调度(作业调度)，中级调度(内存调度)，低级调度(进程调度)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ok77pee740\u0026#34;,\u0026#34;created\u0026#34;:1717232734870,\u0026#34;text\u0026#34;:\u0026#34;调度器分为排队器，分派器，上下文切换器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ok99b2low0\u0026#34;,\u0026#34;created\u0026#34;:1717232895085,\u0026#34;text\u0026#34;:\u0026#34;进程调度的方式分为非抢占调度方式和抢占调度方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1oke5mnivk0\u0026#34;,\u0026#34;created\u0026#34;:1717233278899,\u0026#34;text\u0026#34;:\u0026#34;调度算法评价的标准主要有cpu利用率，系统吞吐量，周转时间，等待时间，响应时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1okmld8vew0\u0026#34;,\u0026#34;created\u0026#34;:1717233940072,\u0026#34;text\u0026#34;:\u0026#34;调度算法分为先来先服务算法(FCFS)调度算法，短作业优先调度算法(SJF)和短进程优先(SPF)可以是抢占式的，高响比优先调度算法，优先调度算法，时间片轮转算法，多级队列调度算法，多级反馈队列调度算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu7z5w5k0\u0026#34;,\u0026#34;created\u0026#34;:1717059629022,\u0026#34;text\u0026#34;:\u0026#34;同步与互斥\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph4o728io0\u0026#34;,\u0026#34;created\u0026#34;:1717325632301,\u0026#34;text\u0026#34;:\u0026#34;同步与互斥的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pguwpw2140\u0026#34;,\u0026#34;created\u0026#34;:1717324867212,\u0026#34;text\u0026#34;:\u0026#34;一次仅让一个进程使用的资源叫临界资源\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pgvu4687s0\u0026#34;,\u0026#34;created\u0026#34;:1717324939909,\u0026#34;text\u0026#34;:\u0026#34;同步也叫直接制约关系，源于进程之间的合作\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pgvvx6qps0\u0026#34;,\u0026#34;created\u0026#34;:1717324943840,\u0026#34;text\u0026#34;:\u0026#34;互斥也叫间接制约关系，源于对临界资源的访问\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph10ww5x40\u0026#34;,\u0026#34;created\u0026#34;:1717325346527,\u0026#34;text\u0026#34;:\u0026#34;实现临界区要遵循的原则-空闲让进，忙则等待，有限等待，让权等待\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph32kq97s0\u0026#34;,\u0026#34;created\u0026#34;:1717325506874,\u0026#34;text\u0026#34;:\u0026#34;实现临界区互斥的方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph6kyvso00\u0026#34;,\u0026#34;created\u0026#34;:1717325782004,\u0026#34;text\u0026#34;:\u0026#34;软件方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph74c33mo0\u0026#34;,\u0026#34;created\u0026#34;:1717325824161,\u0026#34;text\u0026#34;:\u0026#34;单标志法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph9focoww0\u0026#34;,\u0026#34;created\u0026#34;:1717326005576,\u0026#34;text\u0026#34;:\u0026#34;若p1进程一直不进去，则p0进程想进去也进不去，违反空闲让进原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph7f6kxqo0\u0026#34;,\u0026#34;created\u0026#34;:1717325847773,\u0026#34;text\u0026#34;:\u0026#34;双标志位先检查法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phc8g0jaw0\u0026#34;,\u0026#34;created\u0026#34;:1717326224927,\u0026#34;text\u0026#34;:\u0026#34;违反忙则等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phdvgmtfs0\u0026#34;,\u0026#34;created\u0026#34;:1717326353394,\u0026#34;text\u0026#34;:\u0026#34;双标志位后检查法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phf5bsjbs0\u0026#34;,\u0026#34;created\u0026#34;:1717326453234,\u0026#34;text\u0026#34;:\u0026#34;违反空闲让进和有限等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phle64ryg0\u0026#34;,\u0026#34;created\u0026#34;:1717326942667,\u0026#34;text\u0026#34;:\u0026#34;Peterson算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phlqlsfoo0\u0026#34;,\u0026#34;created\u0026#34;:1717326969736,\u0026#34;text\u0026#34;:\u0026#34;违反让权等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph6m1iovc0\u0026#34;,\u0026#34;created\u0026#34;:1717325784340,\u0026#34;text\u0026#34;:\u0026#34;硬件方法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phpokah4g0\u0026#34;,\u0026#34;created\u0026#34;:1717327278748,\u0026#34;text\u0026#34;:\u0026#34;中断屏蔽方法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phr0iobhk0\u0026#34;,\u0026#34;created\u0026#34;:1717327383136,\u0026#34;text\u0026#34;:\u0026#34;TestAndset指令\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phrenu5000\u0026#34;,\u0026#34;created\u0026#34;:1717327413923,\u0026#34;text\u0026#34;:\u0026#34;Swap指令\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ph63wsygw0\u0026#34;,\u0026#34;created\u0026#34;:1717325744873,\u0026#34;text\u0026#34;:\u0026#34;互斥锁\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phuvxzctk0\u0026#34;,\u0026#34;created\u0026#34;:1717327686634,\u0026#34;text\u0026#34;:\u0026#34;自旋锁\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phvy1fob40\u0026#34;,\u0026#34;created\u0026#34;:1717327769561,\u0026#34;text\u0026#34;:\u0026#34;信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phwzdg89k0\u0026#34;,\u0026#34;created\u0026#34;:1717327850828,\u0026#34;text\u0026#34;:\u0026#34;整型信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1piu1sxxb40\u0026#34;,\u0026#34;created\u0026#34;:1717330442136,\u0026#34;text\u0026#34;:\u0026#34;未遵循让权等待原则\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1phx0fodr40\u0026#34;,\u0026#34;created\u0026#34;:1717327853141,\u0026#34;text\u0026#34;:\u0026#34;记录型信号量\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pixuaq9mw0\u0026#34;,\u0026#34;created\u0026#34;:1717330739254,\u0026#34;text\u0026#34;:\u0026#34;实现进程互斥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pizy9l2a00\u0026#34;,\u0026#34;created\u0026#34;:1717330904620,\u0026#34;text\u0026#34;:\u0026#34;信号量实现同步前v后p\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj16e94d40\u0026#34;,\u0026#34;created\u0026#34;:1717331000681,\u0026#34;text\u0026#34;:\u0026#34;信号量实现前前驱关系\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj2o424ig0\u0026#34;,\u0026#34;created\u0026#34;:1717331117611,\u0026#34;text\u0026#34;:\u0026#34;经典同步问题\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj35z3d3c0\u0026#34;,\u0026#34;created\u0026#34;:1717331156492,\u0026#34;text\u0026#34;:\u0026#34;生产者消费者问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj370krhc0\u0026#34;,\u0026#34;created\u0026#34;:1717331158759,\u0026#34;text\u0026#34;:\u0026#34;读者-写者问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj382g5ds0\u0026#34;,\u0026#34;created\u0026#34;:1717331161049,\u0026#34;text\u0026#34;:\u0026#34;哲学家进餐问题\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pj54lkogg0\u0026#34;,\u0026#34;created\u0026#34;:1717331310226,\u0026#34;text\u0026#34;:\u0026#34;吸烟者问题\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pk1bwx1ag0\u0026#34;,\u0026#34;created\u0026#34;:1717333833803,\u0026#34;text\u0026#34;:\u0026#34;管程\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1pk4tx4qfs0\u0026#34;,\u0026#34;created\u0026#34;:1717334108091,\u0026#34;text\u0026#34;:\u0026#34;管程的名称，局限于管程内部共享局部说明，对该数据结构进行操作的一组过程，对局部于管程内部的共享数据设置初始值的语句\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muu98jufs0\u0026#34;,\u0026#34;created\u0026#34;:1717059631766,\u0026#34;text\u0026#34;:\u0026#34;死锁\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbrczzq740\u0026#34;,\u0026#34;created\u0026#34;:1717412043602,\u0026#34;text\u0026#34;:\u0026#34;死锁的概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc3yvmbu00\u0026#34;,\u0026#34;created\u0026#34;:1717413031596,\u0026#34;text\u0026#34;:\u0026#34;所谓死锁，是指多个进程因竟争资源而造成的一种僵局\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcaiiez4w0\u0026#34;,\u0026#34;created\u0026#34;:1717413544519,\u0026#34;text\u0026#34;:\u0026#34;发生死锁的进程必定大于或等于2个\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcby4cdsg0\u0026#34;,\u0026#34;created\u0026#34;:1717413656860,\u0026#34;text\u0026#34;:\u0026#34;发生饥饿的进程可能处于就绪态，也可能处于阻塞态，死锁一定处于阻塞态\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcfyojso80\u0026#34;,\u0026#34;created\u0026#34;:1717413971539,\u0026#34;text\u0026#34;:\u0026#34;产生死锁的必要条件互斥条件，不可剥夺条件，请求并保持条件，循环等待条件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qchstnnag0\u0026#34;,\u0026#34;created\u0026#34;:1717414115515,\u0026#34;text\u0026#34;:\u0026#34;死锁的处理办法死锁预防，避免死锁，死锁的检测与解除\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbre6slbs0\u0026#34;,\u0026#34;created\u0026#34;:1717412046190,\u0026#34;text\u0026#34;:\u0026#34;死锁的预防\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc6u72pmo0\u0026#34;,\u0026#34;created\u0026#34;:1717413256498,\u0026#34;text\u0026#34;:\u0026#34;破坏死锁产生的几个必要条件之一即可\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmt1bd3k0\u0026#34;,\u0026#34;created\u0026#34;:1717414507799,\u0026#34;text\u0026#34;:\u0026#34;循环等待\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmu3vtrk0\u0026#34;,\u0026#34;created\u0026#34;:1717414510131,\u0026#34;text\u0026#34;:\u0026#34;互斥\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmv3z3zs0\u0026#34;,\u0026#34;created\u0026#34;:1717414512314,\u0026#34;text\u0026#34;:\u0026#34;请求并保持\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcmwa2ns00\u0026#34;,\u0026#34;created\u0026#34;:1717414514859,\u0026#34;text\u0026#34;:\u0026#34;不可剥夺\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qbrf8jl7k0\u0026#34;,\u0026#34;created\u0026#34;:1717412048472,\u0026#34;text\u0026#34;:\u0026#34;死锁的检测和解除\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qc6v2yqs00\u0026#34;,\u0026#34;created\u0026#34;:1717413258426,\u0026#34;text\u0026#34;:\u0026#34;死锁的检测\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd5sddsmo0\u0026#34;,\u0026#34;created\u0026#34;:1717415995271,\u0026#34;text\u0026#34;:\u0026#34;用资源分配图来检测系统所处的状态是否为死锁状态\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd4hhw46g0\u0026#34;,\u0026#34;created\u0026#34;:1717415893235,\u0026#34;text\u0026#34;:\u0026#34;死锁的解除\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8eaibdc0\u0026#34;,\u0026#34;created\u0026#34;:1717416199715,\u0026#34;text\u0026#34;:\u0026#34;资源剥夺法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8jvso740\u0026#34;,\u0026#34;created\u0026#34;:1717416211886,\u0026#34;text\u0026#34;:\u0026#34;撤销进程法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd8kyy7z40\u0026#34;,\u0026#34;created\u0026#34;:1717416214254,\u0026#34;text\u0026#34;:\u0026#34;进程回退法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qckg0h73k0\u0026#34;,\u0026#34;created\u0026#34;:1717414322722,\u0026#34;text\u0026#34;:\u0026#34;死锁的避免\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qckx6btfs0\u0026#34;,\u0026#34;created\u0026#34;:1717414360081,\u0026#34;text\u0026#34;:\u0026#34;系统安全状态\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcxtkw77s0\u0026#34;,\u0026#34;created\u0026#34;:1717415370989,\u0026#34;text\u0026#34;:\u0026#34;所谓安全状态是指系统能按某种进程推进顺序分配所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可完成\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qcu1ss3yw0\u0026#34;,\u0026#34;created\u0026#34;:1717415075423,\u0026#34;text\u0026#34;:\u0026#34;银行家算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1qd2c0xm3s0\u0026#34;,\u0026#34;created\u0026#34;:1717415724597,\u0026#34;text\u0026#34;:\u0026#34;安全性算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtjquaiw80\u0026#34;,\u0026#34;created\u0026#34;:1717055986970,\u0026#34;text\u0026#34;:\u0026#34;内存管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muvhtnn340\u0026#34;,\u0026#34;created\u0026#34;:1717059728821,\u0026#34;text\u0026#34;:\u0026#34;内存管理概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rwz0aypb40\u0026#34;,\u0026#34;created\u0026#34;:1717573446145,\u0026#34;text\u0026#34;:\u0026#34;内存的基本原理和要求\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx0m4dlf40\u0026#34;,\u0026#34;created\u0026#34;:1717573572000,\u0026#34;text\u0026#34;:\u0026#34;程序的链接与装入\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5bwipdc0\u0026#34;,\u0026#34;created\u0026#34;:1717573941578,\u0026#34;text\u0026#34;:\u0026#34;编译\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5cwrmw00\u0026#34;,\u0026#34;created\u0026#34;:1717573943770,\u0026#34;text\u0026#34;:\u0026#34;链接\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx5dwhvqg0\u0026#34;,\u0026#34;created\u0026#34;:1717573945930,\u0026#34;text\u0026#34;:\u0026#34;装入\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx0zq8um00\u0026#34;,\u0026#34;created\u0026#34;:1717573601620,\u0026#34;text\u0026#34;:\u0026#34;逻辑地址与物理地址\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx191i24o0\u0026#34;,\u0026#34;created\u0026#34;:1717573621892,\u0026#34;text\u0026#34;:\u0026#34;进程的内存映像\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx1m09l1c0\u0026#34;,\u0026#34;created\u0026#34;:1717573650116,\u0026#34;text\u0026#34;:\u0026#34;内存保护\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx1uxctq80\u0026#34;,\u0026#34;created\u0026#34;:1717573669531,\u0026#34;text\u0026#34;:\u0026#34;内存共享\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx21umdo00\u0026#34;,\u0026#34;created\u0026#34;:1717573684603,\u0026#34;text\u0026#34;:\u0026#34;内存分配与回收\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rwz13lkjs0\u0026#34;,\u0026#34;created\u0026#34;:1717573447876,\u0026#34;text\u0026#34;:\u0026#34;基本分页存储管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxnk5onf40\u0026#34;,\u0026#34;created\u0026#34;:1717575370101,\u0026#34;text\u0026#34;:\u0026#34;分页存储的几个概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxojd0vnk0\u0026#34;,\u0026#34;created\u0026#34;:1717575446732,\u0026#34;text\u0026#34;:\u0026#34;逻辑地址分为页号和偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxok6xx5s0\u0026#34;,\u0026#34;created\u0026#34;:1717575448541,\u0026#34;text\u0026#34;:\u0026#34;页表分为页号与块号(页号是隐藏的)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxsp4c5600\u0026#34;,\u0026#34;created\u0026#34;:1717575772724,\u0026#34;text\u0026#34;:\u0026#34;基本地址变换结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxtwf0le80\u0026#34;,\u0026#34;created\u0026#34;:1717575866972,\u0026#34;text\u0026#34;:\u0026#34;具有快表的地址变换结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxvpwb2i00\u0026#34;,\u0026#34;created\u0026#34;:1717576009508,\u0026#34;text\u0026#34;:\u0026#34;两级页表的逻辑地址空间一级页号，二级页号，页内偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx2rtdhmo0\u0026#34;,\u0026#34;created\u0026#34;:1717573741124,\u0026#34;text\u0026#34;:\u0026#34;连续分配管理方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxgvu0jyw0\u0026#34;,\u0026#34;created\u0026#34;:1717574846968,\u0026#34;text\u0026#34;:\u0026#34;单一连续分配\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxgwofrww0\u0026#34;,\u0026#34;created\u0026#34;:1717574848807,\u0026#34;text\u0026#34;:\u0026#34;固定分区分配\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxhnrsavc0\u0026#34;,\u0026#34;created\u0026#34;:1717574907783,\u0026#34;text\u0026#34;:\u0026#34;动态分区分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxiiirnao0\u0026#34;,\u0026#34;created\u0026#34;:1717574974718,\u0026#34;text\u0026#34;:\u0026#34;首次适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxijhkik00\u0026#34;,\u0026#34;created\u0026#34;:1717574976822,\u0026#34;text\u0026#34;:\u0026#34;邻近适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxim41cnk0\u0026#34;,\u0026#34;created\u0026#34;:1717574982534,\u0026#34;text\u0026#34;:\u0026#34;最佳适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rximybhk80\u0026#34;,\u0026#34;created\u0026#34;:1717574984365,\u0026#34;text\u0026#34;:\u0026#34;最坏适应算法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx3lejrts0\u0026#34;,\u0026#34;created\u0026#34;:1717573805531,\u0026#34;text\u0026#34;:\u0026#34;基本分段存储管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rxyqodn600\u0026#34;,\u0026#34;created\u0026#34;:1717576246298,\u0026#34;text\u0026#34;:\u0026#34;段的逻辑地址分为段号与段内偏移量\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ry0ic1m680\u0026#34;,\u0026#34;created\u0026#34;:1717576384866,\u0026#34;text\u0026#34;:\u0026#34;段表分为段号，段长，本段在主存的始址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1rx45i4skg0\u0026#34;,\u0026#34;created\u0026#34;:1717573849283,\u0026#34;text\u0026#34;:\u0026#34;段页式存储管理\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muvtsk6xs0\u0026#34;,\u0026#34;created\u0026#34;:1717059754876,\u0026#34;text\u0026#34;:\u0026#34;虚拟内存管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt6yqllz40\u0026#34;,\u0026#34;created\u0026#34;:1717765905124,\u0026#34;text\u0026#34;:\u0026#34;局部性原理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt86tna5c0\u0026#34;,\u0026#34;created\u0026#34;:1717766001086,\u0026#34;text\u0026#34;:\u0026#34;时间局部性\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt87mmd3k0\u0026#34;,\u0026#34;created\u0026#34;:1717766002838,\u0026#34;text\u0026#34;:\u0026#34;空间局部性\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tt6zo5f1k0\u0026#34;,\u0026#34;created\u0026#34;:1717765907152,\u0026#34;text\u0026#34;:\u0026#34;概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tta7wlzhc0\u0026#34;,\u0026#34;created\u0026#34;:1717766160171,\u0026#34;text\u0026#34;:\u0026#34;之所以称为虚拟存储器，是因为这种存储器实际上并不存在\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttcfvk68w0\u0026#34;,\u0026#34;created\u0026#34;:1717766334250,\u0026#34;text\u0026#34;:\u0026#34;请求分页管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttg8qguxs0\u0026#34;,\u0026#34;created\u0026#34;:1717766632161,\u0026#34;text\u0026#34;:\u0026#34;页表机制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tth3jqsww0\u0026#34;,\u0026#34;created\u0026#34;:1717766699235,\u0026#34;text\u0026#34;:\u0026#34;页号，物理块号，状态位，访问字段，修改位，外存地址\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttgev7vkw0\u0026#34;,\u0026#34;created\u0026#34;:1717766645509,\u0026#34;text\u0026#34;:\u0026#34;缺页中断机构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tx886y2ug0\u0026#34;,\u0026#34;created\u0026#34;:1717777288507,\u0026#34;text\u0026#34;:\u0026#34;属于内部异常\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttgnz2a200\u0026#34;,\u0026#34;created\u0026#34;:1717766665333,\u0026#34;text\u0026#34;:\u0026#34;地址变换机构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttcgrj9q00\u0026#34;,\u0026#34;created\u0026#34;:1717766336183,\u0026#34;text\u0026#34;:\u0026#34;页框分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txb3omng80\u0026#34;,\u0026#34;created\u0026#34;:1717777513785,\u0026#34;text\u0026#34;:\u0026#34;给一个进程分配的页框的集合就是驻留集\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txe3otbds0\u0026#34;,\u0026#34;created\u0026#34;:1717777748888,\u0026#34;text\u0026#34;:\u0026#34;内存置换分配方案\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txf9b93sw0\u0026#34;,\u0026#34;created\u0026#34;:1717777839493,\u0026#34;text\u0026#34;:\u0026#34;固定分配局部置换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txfagxulc0\u0026#34;,\u0026#34;created\u0026#34;:1717777842014,\u0026#34;text\u0026#34;:\u0026#34;可变分配局部置换\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txfbf3nns0\u0026#34;,\u0026#34;created\u0026#34;:1717777844080,\u0026#34;text\u0026#34;:\u0026#34;可变分配全局分配\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttdja05ps0\u0026#34;,\u0026#34;created\u0026#34;:1717766420018,\u0026#34;text\u0026#34;:\u0026#34;抖动与工作集\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tyaa3ltgw0\u0026#34;,\u0026#34;created\u0026#34;:1717780270497,\u0026#34;text\u0026#34;:\u0026#34;刚刚换入的页面又要换出内存，刚刚换出的页面又要换入内存就叫抖动\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tymbtisd40\u0026#34;,\u0026#34;created\u0026#34;:1717781214611,\u0026#34;text\u0026#34;:\u0026#34;工作集指段时间间隔内，进程要访问的页面集合\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ttdzb1ca00\u0026#34;,\u0026#34;created\u0026#34;:1717766454909,\u0026#34;text\u0026#34;:\u0026#34;内存映射文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txom40elc0\u0026#34;,\u0026#34;created\u0026#34;:1717778572631,\u0026#34;text\u0026#34;:\u0026#34;页面置换算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txoucoz3k0\u0026#34;,\u0026#34;created\u0026#34;:1717778590570,\u0026#34;text\u0026#34;:\u0026#34;最佳置换算法OPT\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txtaxyxzk0\u0026#34;,\u0026#34;created\u0026#34;:1717778940142,\u0026#34;text\u0026#34;:\u0026#34;选择淘汰的是最长时间内不再访问的页面\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txtc9ddjc0\u0026#34;,\u0026#34;created\u0026#34;:1717778943008,\u0026#34;text\u0026#34;:\u0026#34;理想的算法，还未实现\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txovn4cu00\u0026#34;,\u0026#34;created\u0026#34;:1717778593378,\u0026#34;text\u0026#34;:\u0026#34;先进先出页面置换算法FIFO\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txvcsgyew0\u0026#34;,\u0026#34;created\u0026#34;:1717779100891,\u0026#34;text\u0026#34;:\u0026#34;淘汰的页面是最早进来的\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txwt6aq2o0\u0026#34;,\u0026#34;created\u0026#34;:1717779214920,\u0026#34;text\u0026#34;:\u0026#34; 会出现Belady异常（当为进程分配的物理块增加时，缺页次数不减反而增的现象）\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txowv6uv40\u0026#34;,\u0026#34;created\u0026#34;:1717778596042,\u0026#34;text\u0026#34;:\u0026#34;最近最久未使用置换算法LRU\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ty05ebe7c0\u0026#34;,\u0026#34;created\u0026#34;:1717779476619,\u0026#34;text\u0026#34;:\u0026#34;LRU选择淘汰的页面是最近最长时间没有使用的页面\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:6.999999791383743,\u0026#34;y\u0026#34;:1.999999940395469}},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ty06gv1iw0\u0026#34;,\u0026#34;created\u0026#34;:1717779478950,\u0026#34;text\u0026#34;:\u0026#34;堆栈的算法，不会出现Belady现象\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1txrb89u5c0\u0026#34;,\u0026#34;created\u0026#34;:1717778784037,\u0026#34;text\u0026#34;:\u0026#34;时钟算法CLOCK NRU算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1tygp02atc0\u0026#34;,\u0026#34;created\u0026#34;:1717780773119,\u0026#34;text\u0026#34;:\u0026#34;操作系统中的置换算法，尽可能保留访问过的页面，而淘汰未访问的页面\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtk0ufheg0\u0026#34;,\u0026#34;created\u0026#34;:1717056008746,\u0026#34;text\u0026#34;:\u0026#34;文件管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muw7q4q3k0\u0026#34;,\u0026#34;created\u0026#34;:1717059785204,\u0026#34;text\u0026#34;:\u0026#34;文件系统基础\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugi2uxq9c0\u0026#34;,\u0026#34;created\u0026#34;:1717831661627,\u0026#34;text\u0026#34;:\u0026#34;文件的基本概念\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugjbl6dcg0\u0026#34;,\u0026#34;created\u0026#34;:1717831758992,\u0026#34;text\u0026#34;:\u0026#34;文件是以硬盘为载体的存储在计算机的信息集合\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugk0zgtfs0\u0026#34;,\u0026#34;created\u0026#34;:1717831814275,\u0026#34;text\u0026#34;:\u0026#34;文件的基本结构分为数据项，记录，文件（自底向上的方定义）\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugl8zy0o80\u0026#34;,\u0026#34;created\u0026#34;:1717831910083,\u0026#34;text\u0026#34;:\u0026#34;文件的属性名称，类型，所有者，创建者，位置，大小等等\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugmm4la3k0\u0026#34;,\u0026#34;created\u0026#34;:1717832017026,\u0026#34;text\u0026#34;:\u0026#34;文件控制块与索引节点\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugnicnr1k0\u0026#34;,\u0026#34;created\u0026#34;:1717832087171,\u0026#34;text\u0026#34;:\u0026#34;FCB即是文件控制块,FCB的有序集合即为目录，一个FCB即是一个文件目录项\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugoc4b5u00\u0026#34;,\u0026#34;created\u0026#34;:1717832151970,\u0026#34;text\u0026#34;:\u0026#34;在文件目录的每个目录项由文件名和相应的索引结点构成\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uguspumjc0\u0026#34;,\u0026#34;created\u0026#34;:1717832658286,\u0026#34;text\u0026#34;:\u0026#34;文件的操作\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugvm2hq080\u0026#34;,\u0026#34;created\u0026#34;:1717832722177,\u0026#34;text\u0026#34;:\u0026#34;创建，删除，读写文件\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugw1a8u9k0\u0026#34;,\u0026#34;created\u0026#34;:1717832755297,\u0026#34;text\u0026#34;:\u0026#34;文件的打开与关闭open与close函数\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugxykko940\u0026#34;,\u0026#34;created\u0026#34;:1717832906120,\u0026#34;text\u0026#34;:\u0026#34;文件的保护\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugy6aycsw0\u0026#34;,\u0026#34;created\u0026#34;:1717832922952,\u0026#34;text\u0026#34;:\u0026#34;控制用户对文件的访问类型，口令，密码\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugyy3uyg00\u0026#34;,\u0026#34;created\u0026#34;:1717832983473,\u0026#34;text\u0026#34;:\u0026#34;文件的逻辑结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugz7yop340\u0026#34;,\u0026#34;created\u0026#34;:1717833004928,\u0026#34;text\u0026#34;:\u0026#34;无结构文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzn60tug0\u0026#34;,\u0026#34;created\u0026#34;:1717833038024,\u0026#34;text\u0026#34;:\u0026#34;流式文件，由字符流构成的文件\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzhzzug00\u0026#34;,\u0026#34;created\u0026#34;:1717833026775,\u0026#34;text\u0026#34;:\u0026#34;有结构文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ugzvw9d2g0\u0026#34;,\u0026#34;created\u0026#34;:1717833057024,\u0026#34;text\u0026#34;:\u0026#34;顺序文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh2k0ouls0\u0026#34;,\u0026#34;created\u0026#34;:1717833266263,\u0026#34;text\u0026#34;:\u0026#34;串结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh2qdgp2w0\u0026#34;,\u0026#34;created\u0026#34;:1717833280096,\u0026#34;text\u0026#34;:\u0026#34;顺序结构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh13tpgv40\u0026#34;,\u0026#34;created\u0026#34;:1717833152648,\u0026#34;text\u0026#34;:\u0026#34;索引文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh3tg8qyo0\u0026#34;,\u0026#34;created\u0026#34;:1717833365159,\u0026#34;text\u0026#34;:\u0026#34;索引表(本身也是一个定长记录的文件)和逻辑文件\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh14qe6iw0\u0026#34;,\u0026#34;created\u0026#34;:1717833154625,\u0026#34;text\u0026#34;:\u0026#34;索引顺序文件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uh5q7a4yw0\u0026#34;,\u0026#34;created\u0026#34;:1717833514815,\u0026#34;text\u0026#34;:\u0026#34;索引表（同一个组的关键字可以无序，不同组的关键字必须有序)和逻辑文件(检索时，首先查找索引表，找改记录所在的组，然后在该组中使用顺序查找）\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhbp700n40\u0026#34;,\u0026#34;created\u0026#34;:1717833982806,\u0026#34;text\u0026#34;:\u0026#34;物理结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhbsda8dc0\u0026#34;,\u0026#34;created\u0026#34;:1717833989716,\u0026#34;text\u0026#34;:\u0026#34;连续分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhh7bauds0\u0026#34;,\u0026#34;created\u0026#34;:1717834414069,\u0026#34;text\u0026#34;:\u0026#34;连续分配要求每个文件在磁盘中占有连续的块\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhj7xn5dk0\u0026#34;,\u0026#34;created\u0026#34;:1717834572148,\u0026#34;text\u0026#34;:\u0026#34;链接分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhjybm3u00\u0026#34;,\u0026#34;created\u0026#34;:1717834629589,\u0026#34;text\u0026#34;:\u0026#34;隐式链接\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhl03t6h40\u0026#34;,\u0026#34;created\u0026#34;:1717834711835,\u0026#34;text\u0026#34;:\u0026#34;目录项含有文件第一块的指针和最后一块的指针\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhke7td1c0\u0026#34;,\u0026#34;created\u0026#34;:1717834664188,\u0026#34;text\u0026#34;:\u0026#34;显式链接\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhmnflejk0\u0026#34;,\u0026#34;created\u0026#34;:1717834840978,\u0026#34;text\u0026#34;:\u0026#34;有个FAT文件分配表\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhng51gjc0\u0026#34;,\u0026#34;created\u0026#34;:1717834903467,\u0026#34;text\u0026#34;:\u0026#34;索引分配\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uhqqjms280\u0026#34;,\u0026#34;created\u0026#34;:1717835161209,\u0026#34;text\u0026#34;:\u0026#34;单级索引分配方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uicft1gv40\u0026#34;,\u0026#34;created\u0026#34;:1717836861845,\u0026#34;text\u0026#34;:\u0026#34;多级索引分配方式\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwf0rg0g0\u0026#34;,\u0026#34;created\u0026#34;:1717059801084,\u0026#34;text\u0026#34;:\u0026#34;目录\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujic276f40\u0026#34;,\u0026#34;created\u0026#34;:1717840144987,\u0026#34;text\u0026#34;:\u0026#34;目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmpupnag0\u0026#34;,\u0026#34;created\u0026#34;:1717840488466,\u0026#34;text\u0026#34;:\u0026#34;单级目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujoelze8g0\u0026#34;,\u0026#34;created\u0026#34;:1717840620721,\u0026#34;text\u0026#34;:\u0026#34;实现了按名存取，但不能让文件重名，查找速度慢\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmyipuow0\u0026#34;,\u0026#34;created\u0026#34;:1717840507331,\u0026#34;text\u0026#34;:\u0026#34;两级目录结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukik9lkbs0\u0026#34;,\u0026#34;created\u0026#34;:1717842983958,\u0026#34;text\u0026#34;:\u0026#34;主文件目录和用户文件目录，缺少灵活性，不能对文件分类\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujnac65qg0\u0026#34;,\u0026#34;created\u0026#34;:1717840533057,\u0026#34;text\u0026#34;:\u0026#34;树形目录结构\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujnh3vt340\u0026#34;,\u0026#34;created\u0026#34;:1717840547793,\u0026#34;text\u0026#34;:\u0026#34;无环图目录结构\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujictumtk0\u0026#34;,\u0026#34;created\u0026#34;:1717840146659,\u0026#34;text\u0026#34;:\u0026#34;目录操作\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukmbk1zy80\u0026#34;,\u0026#34;created\u0026#34;:1717843278456,\u0026#34;text\u0026#34;:\u0026#34;搜索，创建文件，删除文件，创建目录，删除目录\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujidl8r7c0\u0026#34;,\u0026#34;created\u0026#34;:1717840148315,\u0026#34;text\u0026#34;:\u0026#34;目录实现\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukl4z67ig0\u0026#34;,\u0026#34;created\u0026#34;:1717843185769,\u0026#34;text\u0026#34;:\u0026#34;线性列表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukl5o1sbk0\u0026#34;,\u0026#34;created\u0026#34;:1717843187273,\u0026#34;text\u0026#34;:\u0026#34;哈希表\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ujmeraafc0\u0026#34;,\u0026#34;created\u0026#34;:1717840464314,\u0026#34;text\u0026#34;:\u0026#34;文件共享\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uknehqk4w0\u0026#34;,\u0026#34;created\u0026#34;:1717843363210,\u0026#34;text\u0026#34;:\u0026#34;基于索引结点的共享方式(硬链接)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uknff2mo00\u0026#34;,\u0026#34;created\u0026#34;:1717843365226,\u0026#34;text\u0026#34;:\u0026#34;利用符号链实现文件共享（软链接)\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwiun2zs0\u0026#34;,\u0026#34;created\u0026#34;:1717059809421,\u0026#34;text\u0026#34;:\u0026#34;文件系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukzqnyjs00\u0026#34;,\u0026#34;created\u0026#34;:1717844330078,\u0026#34;text\u0026#34;:\u0026#34;文件系统结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul28r06ew0\u0026#34;,\u0026#34;created\u0026#34;:1717844526173,\u0026#34;text\u0026#34;:\u0026#34;应用程序\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul2kjb7fk0\u0026#34;,\u0026#34;created\u0026#34;:1717844551829,\u0026#34;text\u0026#34;:\u0026#34;逻辑文件系统\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul2r6se0w0\u0026#34;,\u0026#34;created\u0026#34;:1717844566309,\u0026#34;text\u0026#34;:\u0026#34;文件组织模块\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul30ud3yg0\u0026#34;,\u0026#34;created\u0026#34;:1717844587326,\u0026#34;text\u0026#34;:\u0026#34;基本文件系统\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul38nf9iw0\u0026#34;,\u0026#34;created\u0026#34;:1717844604320,\u0026#34;text\u0026#34;:\u0026#34;I/O控制\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;expand\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul3kyuv7c0\u0026#34;,\u0026#34;created\u0026#34;:1717844631133,\u0026#34;text\u0026#34;:\u0026#34;设备\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ukzrogwd40\u0026#34;,\u0026#34;created\u0026#34;:1717844332286,\u0026#34;text\u0026#34;:\u0026#34;文件系统布局\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul852svt40\u0026#34;,\u0026#34;created\u0026#34;:1717844988364,\u0026#34;text\u0026#34;:\u0026#34;文件系统在磁盘中的结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul99jfe9k0\u0026#34;,\u0026#34;created\u0026#34;:1717845076440,\u0026#34;text\u0026#34;:\u0026#34;主引导记录\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulbpas9gw0\u0026#34;,\u0026#34;created\u0026#34;:1717845267475,\u0026#34;text\u0026#34;:\u0026#34;位于磁盘的0号扇区，用来引导计算机\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulb3a5p5c0\u0026#34;,\u0026#34;created\u0026#34;:1717845219548,\u0026#34;text\u0026#34;:\u0026#34;引导块\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uldn0hhkg0\u0026#34;,\u0026#34;created\u0026#34;:1717845419227,\u0026#34;text\u0026#34;:\u0026#34;负责启动该分区中的操作系统，分区引导扇区\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulb43njo80\u0026#34;,\u0026#34;created\u0026#34;:1717845221331,\u0026#34;text\u0026#34;:\u0026#34;超级块\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulf2cx09k0\u0026#34;,\u0026#34;created\u0026#34;:1717845530994,\u0026#34;text\u0026#34;:\u0026#34;包含文件系统的所有信息\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulh2cnigo0\u0026#34;,\u0026#34;created\u0026#34;:1717845687707,\u0026#34;text\u0026#34;:\u0026#34;文件系统中空闲块的信息\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul85v3o9s0\u0026#34;,\u0026#34;created\u0026#34;:1717844990075,\u0026#34;text\u0026#34;:\u0026#34;文件系统在内存中的结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulhx0bxk80\u0026#34;,\u0026#34;created\u0026#34;:1717845754442,\u0026#34;text\u0026#34;:\u0026#34;内存中的安装表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uliawdwao0\u0026#34;,\u0026#34;created\u0026#34;:1717845784678,\u0026#34;text\u0026#34;:\u0026#34;内存中目录结构的缓存\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uljlgcgts0\u0026#34;,\u0026#34;created\u0026#34;:1717845886017,\u0026#34;text\u0026#34;:\u0026#34;整个系统的打开文件表\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uljwpqr5s0\u0026#34;,\u0026#34;created\u0026#34;:1717845910530,\u0026#34;text\u0026#34;:\u0026#34;每个进程的打开文件表\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ul0kgov1s0\u0026#34;,\u0026#34;created\u0026#34;:1717844394942,\u0026#34;text\u0026#34;:\u0026#34;外存空闲空间管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls2f5s280\u0026#34;,\u0026#34;created\u0026#34;:1717846549864,\u0026#34;text\u0026#34;:\u0026#34;空闲表法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls3bpgvs0\u0026#34;,\u0026#34;created\u0026#34;:1717846551832,\u0026#34;text\u0026#34;:\u0026#34;空闲链表法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulxfkoyps0\u0026#34;,\u0026#34;created\u0026#34;:1717846970318,\u0026#34;text\u0026#34;:\u0026#34;空闲盘块链\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1ulxgi1bpc0\u0026#34;,\u0026#34;created\u0026#34;:1717846972334,\u0026#34;text\u0026#34;:\u0026#34;空闲盘区链\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls4iudgo0\u0026#34;,\u0026#34;created\u0026#34;:1717846554440,\u0026#34;text\u0026#34;:\u0026#34;位示图法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1uls5vegug0\u0026#34;,\u0026#34;created\u0026#34;:1717846557376,\u0026#34;text\u0026#34;:\u0026#34;成组链接法\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1mtk24mrmo0\u0026#34;,\u0026#34;created\u0026#34;:1717056011540,\u0026#34;text\u0026#34;:\u0026#34;输入输出管理（I/O管理）\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;,\u0026#34;layout_bottom_offset\u0026#34;:{\u0026#34;x\u0026#34;:32.99999901652325,\u0026#34;y\u0026#34;:9.99999970197672}},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muwpkhz3k0\u0026#34;,\u0026#34;created\u0026#34;:1717059824045,\u0026#34;text\u0026#34;:\u0026#34;io管理概述\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5qwj7njc0\u0026#34;,\u0026#34;created\u0026#34;:1717902880882,\u0026#34;text\u0026#34;:\u0026#34;i/o设备\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5tgfero00\u0026#34;,\u0026#34;created\u0026#34;:1717903080916,\u0026#34;text\u0026#34;:\u0026#34;块设备，字符设备（按照信息交换的单位分类）低速，中速，高速（按照设备的传速速率分类）存储设备，输入/输出设备（按照设备的使用特性分类）\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5ts1cwww0\u0026#34;,\u0026#34;created\u0026#34;:1717903106188,\u0026#34;text\u0026#34;:\u0026#34;i/o接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v61r3m4880\u0026#34;,\u0026#34;created\u0026#34;:1717903731061,\u0026#34;text\u0026#34;:\u0026#34;i/o接口是cpu与设备之间的接口，以实现设备与计算机之间的信息交换\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5ravnckg0\u0026#34;,\u0026#34;created\u0026#34;:1717902912109,\u0026#34;text\u0026#34;:\u0026#34;i/o控制方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64qljlhs0\u0026#34;,\u0026#34;created\u0026#34;:1717903965061,\u0026#34;text\u0026#34;:\u0026#34;程序直接控制方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64sg15dk0\u0026#34;,\u0026#34;created\u0026#34;:1717903969081,\u0026#34;text\u0026#34;:\u0026#34;中断驱动方式\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64uivqyw0\u0026#34;,\u0026#34;created\u0026#34;:1717903973607,\u0026#34;text\u0026#34;:\u0026#34;DMA方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7iz3n1oo0\u0026#34;,\u0026#34;created\u0026#34;:1717907901778,\u0026#34;text\u0026#34;:\u0026#34;数据传输以\\\u0026#34;块\\\u0026#34;为单位，cpu介入的频率降低\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v64wtfu680\u0026#34;,\u0026#34;created\u0026#34;:1717903978599,\u0026#34;text\u0026#34;:\u0026#34;通道控制方式\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7ktd9ekg0\u0026#34;,\u0026#34;created\u0026#34;:1717908046027,\u0026#34;text\u0026#34;:\u0026#34;弱鸡版cpu\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5rkz86600\u0026#34;,\u0026#34;created\u0026#34;:1717902934093,\u0026#34;text\u0026#34;:\u0026#34;i/o软件层次结构\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65a25lq00\u0026#34;,\u0026#34;created\u0026#34;:1717904007424,\u0026#34;text\u0026#34;:\u0026#34;用户层软件\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7m8y51800\u0026#34;,\u0026#34;created\u0026#34;:1717908158305,\u0026#34;text\u0026#34;:\u0026#34;设备独立性软件\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7maal1c80\u0026#34;,\u0026#34;created\u0026#34;:1717908161235,\u0026#34;text\u0026#34;:\u0026#34;设备驱动程序\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7mc4k3k80\u0026#34;,\u0026#34;created\u0026#34;:1717908165224,\u0026#34;text\u0026#34;:\u0026#34;中断处理程序\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7mdgqt8o0\u0026#34;,\u0026#34;created\u0026#34;:1717908168137,\u0026#34;text\u0026#34;:\u0026#34;硬件\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v5skmz5ko0\u0026#34;,\u0026#34;created\u0026#34;:1717903011717,\u0026#34;text\u0026#34;:\u0026#34;应用程序i/o接口\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65hbgjnk0\u0026#34;,\u0026#34;created\u0026#34;:1717904023224,\u0026#34;text\u0026#34;:\u0026#34;i/o接口的分类\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zhgwbzk0\u0026#34;,\u0026#34;created\u0026#34;:1717909195588,\u0026#34;text\u0026#34;:\u0026#34;字符设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zilxh4g0\u0026#34;,\u0026#34;created\u0026#34;:1717909198069,\u0026#34;text\u0026#34;:\u0026#34;块设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v7zjj0ffc0\u0026#34;,\u0026#34;created\u0026#34;:1717909200069,\u0026#34;text\u0026#34;:\u0026#34;网络设备接口\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v65jelo1c0\u0026#34;,\u0026#34;created\u0026#34;:1717904027768,\u0026#34;text\u0026#34;:\u0026#34;阻塞i/o和非阻塞i/o\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muxfg1y1k0\u0026#34;,\u0026#34;created\u0026#34;:1717059880373,\u0026#34;text\u0026#34;:\u0026#34;设备独立性软件\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v89pjmrp40\u0026#34;,\u0026#34;created\u0026#34;:1717909996809,\u0026#34;text\u0026#34;:\u0026#34;磁盘高速缓存在逻辑上属于磁盘，在物理上属于内存\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v89snxy400\u0026#34;,\u0026#34;created\u0026#34;:1717910003600,\u0026#34;text\u0026#34;:\u0026#34;缓冲区\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bqry6rc0\u0026#34;,\u0026#34;created\u0026#34;:1717910156217,\u0026#34;text\u0026#34;:\u0026#34;单缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8brrntqg0\u0026#34;,\u0026#34;created\u0026#34;:1717910158377,\u0026#34;text\u0026#34;:\u0026#34;双缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bv5nsc80\u0026#34;,\u0026#34;created\u0026#34;:1717910165753,\u0026#34;text\u0026#34;:\u0026#34;循环缓冲\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8bw22ce00\u0026#34;,\u0026#34;created\u0026#34;:1717910167713,\u0026#34;text\u0026#34;:\u0026#34;缓冲池\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8d7drgy00\u0026#34;,\u0026#34;created\u0026#34;:1717910270729,\u0026#34;text\u0026#34;:\u0026#34;设备分配与回收\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m2931lk0\u0026#34;,\u0026#34;created\u0026#34;:1717910964839,\u0026#34;text\u0026#34;:\u0026#34;设备控制表DCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m36o7q00\u0026#34;,\u0026#34;created\u0026#34;:1717910966870,\u0026#34;text\u0026#34;:\u0026#34;控制器控制表COCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m42jsig0\u0026#34;,\u0026#34;created\u0026#34;:1717910968798,\u0026#34;text\u0026#34;:\u0026#34;通道控制表CHCT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8m4xeli80\u0026#34;,\u0026#34;created\u0026#34;:1717910970664,\u0026#34;text\u0026#34;:\u0026#34;系统设备表SDT\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8v97igww0\u0026#34;,\u0026#34;created\u0026#34;:1717911685259,\u0026#34;text\u0026#34;:\u0026#34;SPOOLing技术(假脱机技术)\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1v8w4zyju80\u0026#34;,\u0026#34;created\u0026#34;:1717911754460,\u0026#34;text\u0026#34;:\u0026#34;操作系统采用的一项将独占设备改造成共享设备的技术\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1muxqio8kg0\u0026#34;,\u0026#34;created\u0026#34;:1717059904476,\u0026#34;text\u0026#34;:\u0026#34;磁盘与固态硬盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaa9yfftc0\u0026#34;,\u0026#34;created\u0026#34;:1717915683459,\u0026#34;text\u0026#34;:\u0026#34;磁盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vabqqlf680\u0026#34;,\u0026#34;created\u0026#34;:1717915798355,\u0026#34;text\u0026#34;:\u0026#34;磁盘是表面涂有磁性物质的物理盘片\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaajxwac00\u0026#34;,\u0026#34;created\u0026#34;:1717915705195,\u0026#34;text\u0026#34;:\u0026#34;磁盘的管理\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaesoqsu00\u0026#34;,\u0026#34;created\u0026#34;:1717916037690,\u0026#34;text\u0026#34;:\u0026#34;磁盘初始化\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaetd5p4g0\u0026#34;,\u0026#34;created\u0026#34;:1717916039165,\u0026#34;text\u0026#34;:\u0026#34;分区\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaeua7dn40\u0026#34;,\u0026#34;created\u0026#34;:1717916041164,\u0026#34;text\u0026#34;:\u0026#34;引导块\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaev8fs9k0\u0026#34;,\u0026#34;created\u0026#34;:1717916043234,\u0026#34;text\u0026#34;:\u0026#34;坏块\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaapd1ys00\u0026#34;,\u0026#34;created\u0026#34;:1717915716995,\u0026#34;text\u0026#34;:\u0026#34;磁盘调度算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vagm9g9zc0\u0026#34;,\u0026#34;created\u0026#34;:1717916180432,\u0026#34;text\u0026#34;:\u0026#34;磁盘的存取时间\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahffuvlk0\u0026#34;,\u0026#34;created\u0026#34;:1717916243946,\u0026#34;text\u0026#34;:\u0026#34;寻道时间跨越n条隧道的时间和磁头臂启动的时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahko3lz40\u0026#34;,\u0026#34;created\u0026#34;:1717916255329,\u0026#34;text\u0026#34;:\u0026#34;旋转延迟时间，磁头定位到读/写扇区所需要的时间\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vahlnpa9c0\u0026#34;,\u0026#34;created\u0026#34;:1717916257481,\u0026#34;text\u0026#34;:\u0026#34;传输时间从磁盘读出或向磁盘写入数据所需的时间\u0026#34;},\u0026#34;children\u0026#34;:[]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vagnzi0u80\u0026#34;,\u0026#34;created\u0026#34;:1717916184184,\u0026#34;text\u0026#34;:\u0026#34;磁盘调度算法\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vanvxytc00\u0026#34;,\u0026#34;created\u0026#34;:1717916750055,\u0026#34;text\u0026#34;:\u0026#34;先来先服务算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vaph66zu00\u0026#34;,\u0026#34;created\u0026#34;:1717916874629,\u0026#34;text\u0026#34;:\u0026#34;最短寻道时间优先算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1var4hmhjk0\u0026#34;,\u0026#34;created\u0026#34;:1717917003750,\u0026#34;text\u0026#34;:\u0026#34;扫描算法(SCAN),电梯调度算法\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vasg972080\u0026#34;,\u0026#34;created\u0026#34;:1717917107726,\u0026#34;text\u0026#34;:\u0026#34;循环扫描算法(C-SCAN)\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vau0hcpig0\u0026#34;,\u0026#34;created\u0026#34;:1717917230119,\u0026#34;text\u0026#34;:\u0026#34;SCAN算法的改进教LOCK调度\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vautuz4l40\u0026#34;,\u0026#34;created\u0026#34;:1717917294069,\u0026#34;text\u0026#34;:\u0026#34;C-SCAN算法的改进叫作C-LOCK调度\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vab7xcbf40\u0026#34;,\u0026#34;created\u0026#34;:1717915757404,\u0026#34;text\u0026#34;:\u0026#34;固态硬盘\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vayl077k80\u0026#34;,\u0026#34;created\u0026#34;:1717917588251,\u0026#34;text\u0026#34;:\u0026#34;是一种基于闪存技术的存储器\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb048dilc0\u0026#34;,\u0026#34;created\u0026#34;:1717917708468,\u0026#34;text\u0026#34;:\u0026#34;磨损均衡\u0026#34;,\u0026#34;expandState\u0026#34;:\u0026#34;collapse\u0026#34;},\u0026#34;children\u0026#34;:[{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb0tnwjh40\u0026#34;,\u0026#34;created\u0026#34;:1717917763827,\u0026#34;text\u0026#34;:\u0026#34;动态磨损均衡\u0026#34;},\u0026#34;children\u0026#34;:[]},{\u0026#34;data\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;d1vb0uliqw00\u0026#34;,\u0026#34;created\u0026#34;:1717917765859,\u0026#34;text\u0026#34;:\u0026#34;静态磨损均衡\u0026#34;},\u0026#34;children\u0026#34;:[]}]}]}]}]}]},\u0026#34;template\u0026#34;:\u0026#34;structure\u0026#34;,\u0026#34;theme\u0026#34;:\u0026#34;fresh-blue\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;1.4.33\u0026#34;} ","date":"2024-10-09T12:20:39+08:00","image":"https://getshhi.github.io/jk7.png","permalink":"https://getshhi.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","title":"计算机操作系统思维导图"},{"content":"实现原理分析 HashMap的底层是红黑树,数组,链表;默认其初始容量为16;当put时首先就会进入到putVal这个函数,到这个函数中首先先判断底层的table是否为空或者长度为0,若是则会扩容到16,然后根据key值计算出table值,若table值为空,则直接加入到这个table位置上;若不是则会判断加入的key和旧的key是否是同一对象或者euqals相同,若是,则不用加了;若不是，先判断是否是为红黑树,如果是,则按照红黑树的逻辑加,若不是则会进入死循环,死循环中如果有key相同就只是替换value,如果不是则尾插到链表末尾,若单个链表超过8个,则会进行树化,在树化这个函数中先判断容量是否超过64,如果是则树化否则扩容。最后判断是否需要扩容。\n源码分析 首先会进入put函数 1 2 3 4 5 public V put(K key, V value) { //传入其哈希值和key和value //(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16) 计算key的hash值,让高位和低位进行异或 return putVal(hash(key), key, value, false, true); } 然后执行putval方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i;//辅助变量 //如果底层的table数组为null,或者length = 0,就扩容到16 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //取出hash值对应的table的索引位置的Node,如果为空,则直接创建一个新的节点,填入key和value,加入该位置 if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u0026lt;K,V\u0026gt; e; K k; // 辅助变量 //如果table的索引位置的key的hash相同和新的key的hash值相同 //并满足(table现有的结点的key和添加的key是同一对象 || equals返回真,就认为不能加这个k-v) if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) //如果当前的table的已有的Node是红黑树,就按照红黑树的方式处理 e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { //如果找到的结点，后面是链表，就循环比较 for (int binCount = 0; ; ++binCount) {//死循环 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //加入后，判断当前链表的个数，是否已经到达八个，到八个，后面就调用treeifyBin方法进行红黑树的转化,不进行树化 //其中树化里面会判断是否超过64,没有就扩容 /* if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); */ if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果在循环中相同就只是替换value if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //替换value afterNodeAccess(e); return oldValue; } } ++modCount; //每次加入一个都加一 if (++size \u0026gt; threshold) //判断是否需要扩容 resize(); afterNodeInsertion(evict); return null; } 结论总结 HashMap底层维护了Node类型的数组table,默认为null。\n当创建对象时,将加载因子初始化为0.75。\n当添加key-val时,通过key的哈希值得到在table的索引,然后判断索引是否有元素,如果没有元素直接加入。如果索引处有元素,则判断key值是否相同,若相同,则直接替换value;如果不相同,则会判断是树结构还是链表结构,分别进行相应的处理。如果添加时发现容量不够,则会进行扩容。\n第一次添加，则需要扩容table容量为16，临界值为12(16 * 0.75)\n以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推。\n在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，并且table的大小 \u0026gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化\n","date":"2024-10-03T16:55:42+08:00","image":"https://getshhi.github.io/jk6.png","permalink":"https://getshhi.github.io/p/hashmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%80%BB%E7%BB%93/","title":"HashMap的实现原理与总结"},{"content":"题目分析 力扣题目链接\n要统计二叉树的节点个数，一般是编历一遍二叉树直接统计(可以用后序遍历或者层序遍历，这里就不说了)。\n而这个是完全二叉树,我们可以根据完全二叉树的特点进行求解。\n完全二叉树的定义如下:在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面的节点都集中在该层最左边的若干位置。若最低层为第h层，则该层包含1-2h个节点。\n则可以设完全二叉树有 h 层，则其前h-1的节点都是满的，共有节点 2^(h-1) - 1 个节点。而最后一层最少有 1 个节点，最多有 2^(h-1) 个节点。因此 h 层的完全二叉树的节点个数范围为：[2^(h-1) - 1 + 1, 2^(h-1) - 1 + 2^(h-1)] = [2^(h-1), 2^h - 1]【或 [2^(h-1), 2^h) 】\n位运算 我们把每个节点编号转成二进制，可以发现以下几个规律：\n第 h 层的节点编号的二进制刚好有 h 位； 定义左子节点为 0， 右子节点为 1 。那么每一个节点编号的二进制从高位到低位刚好表示根节点到这个节点的路径。【根节点为最高位，始终为 1】即节点编号的二进制为节点路径的编码； 则可以发现第h层的节点编号一定是有h位。我们可以根据已知的节点走一遍节点路径，来查找这个节点是否存在。\n代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int countNodes(TreeNode root) { if(root == null) //如果根结点为null，直接返回0 return 0; TreeNode node = root; int leavl = 0; while(node != null){ //统计完全二叉树的层数 leavl++; node = node.left; } int min = 1 \u0026lt;\u0026lt; (leavl - 1); //最小可以有多少 int max = ( 1 \u0026lt;\u0026lt; leavl) - 1; //最大可以有多少 int ans = 0; //存储结果 while(min \u0026lt;= max){ int middle = min + ((max - min) \u0026gt;\u0026gt; 1); if(check(middle, root, leavl)){ ans = middle; min = middle + 1; //利用二分确定结果 } else{ max = middle - 1; } } return ans; } public boolean check(int middle, TreeNode root, int leavl){ int jk = 1 \u0026lt;\u0026lt; (leavl - 2); //抛去根节点(因为根节点是1) while(jk \u0026gt; 0){ if((jk \u0026amp; middle) == 0) root = root.left; //为0说明在左子树上 else root = root.right; //为1说明在右子树上 jk \u0026gt;\u0026gt;= 1; //逐层进行查找 } return root != null; //为空则说明不存在 } } 本文引自于https://leetcode.cn/problems/count-complete-tree-nodes/solutions/2456908/javapython3cer-fen-cha-zhao-wei-yun-suan-idof/\n","date":"2024-10-03T11:25:04+08:00","image":"https://getshhi.github.io/jk8.png","permalink":"https://getshhi.github.io/p/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E5%8A%9B%E6%89%A3/","title":"完全二叉树的节点个数(力扣)"},{"content":"Java的网络编程 1.Java网络编程的基本概念 IP 地址：用于标识网络中的计算机。\n端口号：用于标识计算机上的具体应用程序或进程。\nSocket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n协议：网络通信的规则，如 TCP（传输控制协议）和 UDP（用户数据报协议）。\n2.网络编程的核心类 Socket：用于创建客户端套接字。\nServerSocket：用于创建服务器套接字。\nDatagramSocket：用于创建支持 UDP 协议的套接字。\nURL：用于处理统一资源定位符。\nURLConnection：用于读取和写入 URL 引用的资源。\n3.代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.io.*; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TCPServer { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8080)) { while (true) { Socket socket = serverSocket.accept(); new ServerThread(socket).start(); //synchronized } } catch (IOException e) { e.printStackTrace(); } } } class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket){ this.socket = socket; } public void start(){ try(PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))){ String message = in.readLine(); //接受消息 out.println(\u0026#34;Hello Server~\u0026#34;); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (IOException e) { e.printStackTrace(); } } } import java.io.*; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TCPClient { public static void main(String[] args) { try(Socket socket = new Socket(\u0026#34;localhost\u0026#34;,8080); PrintWriter out = new PrintWriter(socket.getOutputStream(),true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) { out.println(\u0026#34;Hello Server~\u0026#34;); String message = in.readLine(); System.out.println(\u0026#34;message = \u0026#34; + message); } catch (Exception e) { e.printStackTrace(); } } } 4.总结 IP地址：外卖员要送餐到的大楼（例如：腾讯大楼）。\n端口号：外卖员要到大楼里的具体房间（例如：1001）。\nSocket：外卖员通过手机（Socket）与我们通信，告知外卖已到。\n协议：我们默认使用中文对话。\n","date":"2024-09-27T12:33:05+08:00","image":"https://getshhi.github.io/kj3.png","permalink":"https://getshhi.github.io/p/javaweb/","title":"JavaWeb"}]