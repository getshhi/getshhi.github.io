<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据库 on JZH-letere</title>
        <link>https://getshhi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
        <description>Recent content in 数据库 on JZH-letere</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>JZH-letere</copyright>
        <lastBuildDate>Mon, 23 Dec 2024 22:31:04 +0800</lastBuildDate><atom:link href="https://getshhi.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Redis常见数据类型和应用场景</title>
        <link>https://getshhi.github.io/p/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
        <pubDate>Mon, 23 Dec 2024 22:31:04 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
        <description>&lt;img src="https://getshhi.github.io/lm.png" alt="Featured image of post Redis常见数据类型和应用场景" /&gt;&lt;h2 id=&#34;string&#34;&gt;String
&lt;/h2&gt;&lt;h3 id=&#34;介绍&#34;&gt;介绍
&lt;/h3&gt;&lt;p&gt;String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。&lt;/p&gt;
&lt;h4 id=&#34;内部实现&#34;&gt;内部实现
&lt;/h4&gt;&lt;p&gt;String类型的底层的数据结构实现主要是int和SDS(简单动态字符串)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDS不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。&lt;/li&gt;
&lt;li&gt;SDS获取字符串的时间复杂度为O(1)。因为SDS靠len属性直接获取字符串长度。&lt;/li&gt;
&lt;li&gt;Redis的SDS API是安全的，拼接字符串不会造成缓冲区溢出。y因为在拼接前会检查SDS空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串对象的内部编码（encoding）有 3 种 ：int、raw和 embstr。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/string%E7%BB%93%E6%9E%84.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;embstr和raw编码的相同之处和不同之处&#34;&gt;embstr和raw编码的相同之处和不同之处
&lt;/h4&gt;&lt;p&gt;embstr和raw编码都会使用SDS来保存值，但不同之处在于embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，而raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS。&lt;/p&gt;
&lt;p&gt;Redis这样做会有很多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;embstr编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次；&lt;/li&gt;
&lt;li&gt;释放 embstr编码的字符串对象同样只需要调用一次内存释放函数；&lt;/li&gt;
&lt;li&gt;因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是 embstr 也有缺点的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以&lt;strong&gt;embstr编码的字符串对象实际上是只读的&lt;/strong&gt;，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/embstr.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/raw.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景
&lt;/h3&gt;&lt;h4 id=&#34;缓存对象&#34;&gt;缓存对象
&lt;/h4&gt;&lt;p&gt;有两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接缓存整个对象的 JSON，命令例子： SET user:1 &amp;lsquo;{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;wanli&amp;rdquo;, &amp;ldquo;age&amp;rdquo;:18}&amp;rsquo;&lt;/li&gt;
&lt;li&gt;采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常规计数&#34;&gt;常规计数
&lt;/h4&gt;&lt;p&gt;因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。&lt;/p&gt;
&lt;h4 id=&#34;分布式锁&#34;&gt;分布式锁
&lt;/h4&gt;&lt;p&gt;SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 key 不存在，则显示插入成功，可以用来表示加锁成功；&lt;/li&gt;
&lt;li&gt;如果 key 存在，则会显示插入失败，可以用来表示加锁失败。
一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SET lock_key unique_value NX PX 10000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;lock_key 就是 key 键；&lt;/li&gt;
&lt;li&gt;unique_value 是客户端生成的唯一的标识；&lt;/li&gt;
&lt;li&gt;NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；&lt;/li&gt;
&lt;li&gt;PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而解锁的操作必须由操作的客户端进行，所以解锁的时候，我们要先判断锁的unique_value是否为加锁客户端，是的话，才将lock_key键删除。&lt;/p&gt;
&lt;p&gt;可以看到，是先判断锁，然后再进行解锁之类的操作，这时就需要Lua脚本来保证解锁的原子性，因为Redis在执行Lua脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if redis.call(&amp;#34;get&amp;#34;,KEYS[1]) == ARGV[1] then
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return redis.call(&amp;#34;del&amp;#34;,KEYS[1])
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;共享session信息&#34;&gt;共享Session信息
&lt;/h4&gt;&lt;p&gt;分布式系统单独存储Session流程图
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;List
&lt;/h2&gt;&lt;h4 id=&#34;介绍-1&#34;&gt;介绍
&lt;/h4&gt;&lt;p&gt;List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。&lt;/p&gt;
&lt;p&gt;列表的最大长度为 2^32 - 1，也即每个列表支持超过 40 亿个元素。&lt;/p&gt;
&lt;h4 id=&#34;内部实现-1&#34;&gt;内部实现
&lt;/h4&gt;&lt;p&gt;List 类型的底层数据结构是由双向链表或压缩列表实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用压缩列表作为 List 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果列表的元素不满足上面的条件，Redis 会使用&lt;strong&gt;双向链表&lt;/strong&gt;作为 List 类型的底层数据结构；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是&lt;strong&gt;在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;应用场景-1&#34;&gt;应用场景
&lt;/h3&gt;&lt;h4 id=&#34;消息队列&#34;&gt;消息队列
&lt;/h4&gt;&lt;p&gt;消息队列在存取消息时，必须要满足三个需求，分别是&lt;strong&gt;消息保序，处理重复的消息和保证消息可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;如何满足消息保序需求&#34;&gt;如何满足消息保序需求
&lt;/h5&gt;&lt;p&gt;List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者使用 LPUSH key value[value&amp;hellip;] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。&lt;/li&gt;
&lt;li&gt;消费者使用 RPOP key 依次读取队列的消息，先进先出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;如何处理重复的消息&#34;&gt;如何处理重复的消息
&lt;/h5&gt;&lt;p&gt;消费者要实现重复消息的判断，需要2个方面的要求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个消息都有一个全局的 ID。&lt;/li&gt;
&lt;li&gt;消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是 List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。&lt;/p&gt;
&lt;p&gt;例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 100 的消息插入了消息队列：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt; LPUSH mq &amp;#34;111000102:stock:100&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(integer) 1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;如何保证消息可靠性&#34;&gt;如何保证消息可靠性
&lt;/h5&gt;&lt;p&gt;当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。&lt;/p&gt;
&lt;p&gt;为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让&lt;strong&gt;消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。&lt;/p&gt;
&lt;p&gt;好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息保序：使用 LPUSH + RPOP；&lt;/li&gt;
&lt;li&gt;阻塞读取：使用 BRPOP；&lt;/li&gt;
&lt;li&gt;重复消息处理：生产者自行实现全局唯一 ID；&lt;/li&gt;
&lt;li&gt;消息的可靠性：使用 BRPOPLPUSH&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;list-作为消息队列有什么缺陷&#34;&gt;List 作为消息队列有什么缺陷？
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;List 只支持一个消费者消费同一条消息&lt;/strong&gt;，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。&lt;/li&gt;
&lt;li&gt;要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个&lt;strong&gt;消费组&lt;/strong&gt;，使得多个消费者可以消费同一条消息，但是 List 类型并不支持消费组的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hash&#34;&gt;Hash
&lt;/h2&gt;&lt;h3 id=&#34;介绍-2&#34;&gt;介绍
&lt;/h3&gt;&lt;p&gt;Hash 是一个键值对（key - value）集合，其中 value 的形式如： value=[{field1，value1}，&amp;hellip;{fieldN，valueN}]。Hash 特别适合用于存储对象。
Hash 与 String 对象的区别如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;内部实现-2&#34;&gt;内部实现
&lt;/h3&gt;&lt;p&gt;Hash类型的底层数据结构是由&lt;strong&gt;压缩列表或哈希表&lt;/strong&gt;实现的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。&lt;/p&gt;
&lt;h3 id=&#34;应用场景-2&#34;&gt;应用场景
&lt;/h3&gt;&lt;h4 id=&#34;缓存对象-1&#34;&gt;缓存对象
&lt;/h4&gt;&lt;p&gt;Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
Redis Hash 存储其结构如下图：
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/hash%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
在介绍 String 类型的应用场景时有所介绍，String + Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？&lt;/p&gt;
&lt;p&gt;一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。&lt;/p&gt;
&lt;h2 id=&#34;set&#34;&gt;set
&lt;/h2&gt;&lt;h3 id=&#34;介绍-3&#34;&gt;介绍
&lt;/h3&gt;&lt;p&gt;Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。&lt;/p&gt;
&lt;p&gt;一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。
&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/set.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;set-类型和-list-类型的区别如下&#34;&gt;Set 类型和 List 类型的区别如下：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;List 可以存储重复元素，Set 只能存储非重复元素；&lt;/li&gt;
&lt;li&gt;List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内部实现-3&#34;&gt;内部实现
&lt;/h3&gt;&lt;p&gt;Set 类型的底层数据结构是由&lt;strong&gt;哈希表或整数集合&lt;/strong&gt;实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用&lt;strong&gt;整数集合&lt;/strong&gt;作为 Set 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用场景-3&#34;&gt;应用场景
&lt;/h3&gt;&lt;p&gt;集合的主要几个特性，无序、不可重复、支持并交差等操作。&lt;/p&gt;
&lt;p&gt;因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。&lt;/p&gt;
&lt;p&gt;但是这里有一个潜在的风险。&lt;strong&gt;Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。&lt;/p&gt;
&lt;p&gt;可以用做点赞，抽奖活动，共同关注等应用场景。&lt;/p&gt;
&lt;h3 id=&#34;zset&#34;&gt;Zset
&lt;/h3&gt;&lt;h4 id=&#34;介绍-4&#34;&gt;介绍
&lt;/h4&gt;&lt;p&gt;Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。&lt;/p&gt;
&lt;p&gt;有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。&lt;/p&gt;
&lt;h3 id=&#34;内部实现-4&#34;&gt;内部实现
&lt;/h3&gt;&lt;p&gt;Zset 类型的底层数据结构是由压缩列表或跳表实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了&lt;/p&gt;
&lt;h3 id=&#34;应用场景-4&#34;&gt;应用场景
&lt;/h3&gt;&lt;p&gt;Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。&lt;/p&gt;
&lt;p&gt;在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。&lt;/p&gt;
&lt;h4 id=&#34;排行榜&#34;&gt;排行榜
&lt;/h4&gt;&lt;p&gt;有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。&lt;/p&gt;
&lt;h4 id=&#34;电话-姓名排序&#34;&gt;电话 姓名排序
&lt;/h4&gt;&lt;p&gt;使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。&lt;/p&gt;
&lt;h2 id=&#34;bitmap&#34;&gt;BitMap
&lt;/h2&gt;&lt;h3 id=&#34;介绍-5&#34;&gt;介绍
&lt;/h3&gt;&lt;p&gt;Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。&lt;/p&gt;
&lt;p&gt;由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis的简单介绍</title>
        <link>https://getshhi.github.io/p/redis%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link>
        <pubDate>Mon, 23 Dec 2024 21:41:16 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/redis%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid>
        <description>&lt;img src="https://getshhi.github.io/nj.png" alt="Featured image of post Redis的简单介绍" /&gt;&lt;h3 id=&#34;redis简介&#34;&gt;Redis简介
&lt;/h3&gt;&lt;p&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。&lt;/p&gt;
&lt;p&gt;Redis 与其他 key - value 缓存产品有以下三个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis-优势&#34;&gt;Redis 优势
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。&lt;/li&gt;
&lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis与其他key-value存储有什么不同&#34;&gt;Redis与其他key-value存储有什么不同？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。在内存数据库方面的另一个优点是， 相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。 同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySql优化</title>
        <link>https://getshhi.github.io/p/mysql%E4%BC%98%E5%8C%96/</link>
        <pubDate>Sun, 22 Dec 2024 18:26:46 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;img src="https://getshhi.github.io/nv4.png" alt="Featured image of post MySql优化" /&gt;&lt;h3 id=&#34;插入数据优化&#34;&gt;插入数据优化
&lt;/h3&gt;&lt;h4 id=&#34;对于insert这个命令来说有三种优化方式&#34;&gt;对于insert这个命令来说有三种优化方式
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;优化方案一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以批量插入数据&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Insert into tb_test values(1,&amp;#39;Tom&amp;#39;),(2,&amp;#39;Cat&amp;#39;),(3,&amp;#39;Jerry&amp;#39;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优化方案二&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;手动控制事务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;start transaction;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;insert into tb_test values(1,&amp;#39;Tom&amp;#39;),(2,&amp;#39;Cat&amp;#39;),(3,&amp;#39;Jerry&amp;#39;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;insert into tb_test values(4,&amp;#39;Tom&amp;#39;),(5,&amp;#39;Cat&amp;#39;),(6,&amp;#39;Jerry&amp;#39;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;insert into tb_test values(7,&amp;#39;Tom&amp;#39;),(8,&amp;#39;Cat&amp;#39;),(9,&amp;#39;Jerry&amp;#39;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;commit;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优化方案三
主键顺序插入，性能要高于乱序插入&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对于大批量插入数据&#34;&gt;对于大批量插入数据
&lt;/h4&gt;&lt;p&gt;如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。&lt;/p&gt;
&lt;p&gt;并且我们建议要顺序插入(主键顺序插入性能高于乱序插入)&lt;/p&gt;
&lt;h3 id=&#34;主键优化&#34;&gt;主键优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;满足业务需求的情况下，尽量降低主键的长度。&lt;/li&gt;
&lt;li&gt;插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键&lt;/li&gt;
&lt;li&gt;尽量不要使用UUID做主键或者是其他自然主键，如身份证号&lt;/li&gt;
&lt;li&gt;业务操作时，避免对主键的修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;order-by-优化&#34;&gt;order by 优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则&lt;/li&gt;
&lt;li&gt;尽量使用覆盖索引&lt;/li&gt;
&lt;li&gt;多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）&lt;/li&gt;
&lt;li&gt;如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小
sort_buffer_size(默认256k)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;group-by优化&#34;&gt;group by优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在分组操作时，可以通过索引来提高效率。&lt;/li&gt;
&lt;li&gt;分组操作时，索引的使用也是满足最左前缀法则的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;limit优化&#34;&gt;limit优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查
询形式进行优化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;count优化&#34;&gt;count优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个
数，效率很高； 但是如果是带条件的count，MyISAM也慢。&lt;/li&gt;
&lt;li&gt;InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出
来，然后累积计数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数
据库进行,但是如果是带条件的count又比较麻烦了)。&lt;/p&gt;
&lt;p&gt;按照效率排序的话，count(字段) &amp;lt; count(主键 id) &amp;lt; count(1) ≈ count(&lt;em&gt;)，所以尽
量使用 count(&lt;/em&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://getshhi.github.io/v1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;update优化&#34;&gt;update优化
&lt;/h3&gt;&lt;p&gt;要加索引，不加的话会加一个间隙锁，会导致整张表被锁住。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySql内存</title>
        <link>https://getshhi.github.io/p/mysql%E5%86%85%E5%AD%98/</link>
        <pubDate>Wed, 18 Dec 2024 16:07:41 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E5%86%85%E5%AD%98/</guid>
        <description>&lt;img src="https://getshhi.github.io/ok.png" alt="Featured image of post MySql内存" /&gt;&lt;p&gt;Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来提高数据库的读写性能。&lt;/p&gt;
&lt;p&gt;Buffer Pool 以页为单位缓冲数据，可以通过 innodb_buffer_pool_size 参数调整缓冲池的大小，默认是 128 M。&lt;/p&gt;
&lt;p&gt;Innodb 通过三种链表来管理缓页：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Free List （空闲页链表），管理空闲页；&lt;/li&gt;
&lt;li&gt;Flush List （脏页链表），管理脏页；&lt;/li&gt;
&lt;li&gt;LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 LRU 链表 分为young 和 old 两个区域，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。&lt;/li&gt;
&lt;li&gt;当 **「页被访问」且「 old 区域停留时间超过 innodb_old_blocks_time 阈值（默认为1秒）」**时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。
可以通过调整 innodb_old_blocks_pct 参数，设置 young 区域和 old 区域比例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySql日志</title>
        <link>https://getshhi.github.io/p/mysql%E6%97%A5%E5%BF%97/</link>
        <pubDate>Mon, 16 Dec 2024 16:07:41 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E6%97%A5%E5%BF%97/</guid>
        <description>&lt;img src="https://getshhi.github.io/gg.png" alt="Featured image of post MySql日志" /&gt;&lt;h2 id=&#34;三个日志&#34;&gt;三个日志
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的&lt;strong&gt;原子性&lt;/strong&gt;，主要用于&lt;strong&gt;事务回滚&lt;/strong&gt;和&lt;strong&gt;MVCC&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的&lt;strong&gt;持久性&lt;/strong&gt;，主要用于&lt;strong&gt;掉电&lt;/strong&gt;等&lt;strong&gt;故障恢复&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;binlog （归档日志）：是 Server 层生成的日志，主要用于&lt;strong&gt;数据备份&lt;/strong&gt;和&lt;strong&gt;主从复制&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为啥需要-undo-log&#34;&gt;为啥需要 undo log？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;实现&lt;strong&gt;事务回滚&lt;/strong&gt;，保障事务的&lt;strong&gt;原子性&lt;/strong&gt;。在事务处理过程中，如果出现了错误或者用执行了ROLLBACK语句，MySql可以利用undo log中的历史数据恢复到事务开始之前的状态。&lt;/li&gt;
&lt;li&gt;实现&lt;strong&gt;MVCC&lt;/strong&gt;(&lt;strong&gt;多版本并发控制&lt;/strong&gt;)关键因素之一。MVCC是通过ReadView + undo log实现的。undo log 为每条记录保存多份历史数据，MySQL在执行快照读(普通select语句)的时候，会根据事务的Read View里的信息，顺着undo log 的版本链找到满足其可见性的记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为啥需要buffer-pool&#34;&gt;为啥需要Buffer Pool？
&lt;/h3&gt;&lt;p&gt;总体原因:&lt;/p&gt;
&lt;p&gt;相较于内存的缓存来说，磁盘的速度太慢，这时如果有相应的缓存池，就可以大幅度地提高性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当读取数据时，如果数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;buffer-pool缓存啥&#34;&gt;Buffer Pool缓存啥？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Buffer Pool的内存空间是一片连续的内存空间，以页的形式进行数据交换，组成部分是一个个页，这种页叫做缓存页。&lt;/li&gt;
&lt;li&gt;由数据页，索引页，插入缓存页，undo页，自适应哈希索引，锁信息。&lt;/li&gt;
&lt;li&gt;undo页是记录相应的undo log。&lt;/li&gt;
&lt;li&gt;当查询一条记录时，InnoDB不是只需要缓存一条记录，当我们查询一条记录时，InnoDB是会把整个页的数据加载到Buffer Pool中，将页加载到Buffer Pool中，再通过页里的页目录去定义到某条具体的记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为啥需要redo-log&#34;&gt;为啥需要redo log？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基于内存的Buffer Pool，如果内存出现错误，那么其中还没来得及落盘的脏页数据就会丢失。为了防止这种情况再次发生引出了rdao log。&lt;/li&gt;
&lt;li&gt;可能会出现啥服务端宕机的情况，所以可以通过redo log来进行预防故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;被修改-undo-页面需要记录对应-redo-log-吗&#34;&gt;被修改 Undo 页面，需要记录对应 redo log 吗？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;需要的。在内存修改该Undo页面后，也是需要记录对应的redo log, 因为undo log也要实现持久性的保护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redo-log-和-undo-log区别在哪&#34;&gt;redo log 和 undo log区别在哪？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;redo log 记录了此次事务&lt;strong&gt;修改后&lt;/strong&gt;的数据状态，记录的是&lt;strong&gt;更新后&lt;/strong&gt;的值，功能是&lt;strong&gt;事务崩溃恢复&lt;/strong&gt;，保证&lt;strong&gt;事务的持久性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;undo log 记录了此次事务&lt;strong&gt;修改前&lt;/strong&gt;的数据状态，记录的是&lt;strong&gt;更新之前&lt;/strong&gt;的值，保证事务的&lt;strong&gt;原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redo-log-要写到磁盘数据也要写磁盘为啥要多次一举&#34;&gt;redo log 要写到磁盘，数据也要写磁盘，为啥要多次一举？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一点redo log的写入方式使用了追加操作，所以磁盘操作是顺序写，而对于直接写入数据的写入方式是随机写。所以redo log 的写入更加高效，这是第一点。&lt;/li&gt;
&lt;li&gt;第二点的话就是实现事务的持久性，让MySql有crash-safe的能力，能够保证MySql在任何时间段突然崩溃，重启之前已提交的记录都不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;产生的redo-log是直接写入磁盘的吗&#34;&gt;产生的redo log是直接写入磁盘的吗？
&lt;/h3&gt;&lt;p&gt;不是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它也有自己的缓存redo log buffer，每当产生一条redo log时，会先写入到redo log buffer，后续在持久化到磁盘中。(redo log buffer默认大小为16MB，可以通过innodb_log_Buffer_size参数动态的调整大小)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redo-log啥时候刷盘&#34;&gt;redo log啥时候刷盘？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MySQL正常关闭时。&lt;/li&gt;
&lt;li&gt;当redo log buffer中记录的写入量大于redo log buffer 内存空间的一半时，会触发落盘。&lt;/li&gt;
&lt;li&gt;InnoDB的后台线程每隔1秒，将redo log buffer持久化到磁盘中&lt;/li&gt;
&lt;li&gt;每次事务提交时都将缓存在redo log buffer里的redo log直接持久化到磁盘(这个策略可由innodb_flush_log_at_trx_commit 参数控制)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;innodb_flush_log_at_trx_commit参数控制的是啥&#34;&gt;innodb_flush_log_at_trx_commit参数控制的是啥？
&lt;/h3&gt;&lt;p&gt;控制的是&lt;strong&gt;当事务提交的时候，redo log写入的策略&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当设置该&lt;strong&gt;参数为0的时候&lt;/strong&gt;，表示每次事务提交的时候，还是将redo log &lt;strong&gt;留在redo log buffer中&lt;/strong&gt;，该模式下在事务提交时不主动触发写入主动触发写入磁盘的操作。&lt;/li&gt;
&lt;li&gt;当设置该&lt;strong&gt;参数为1的时候&lt;/strong&gt;，表示每次事务提交的时候，都将缓存在redo log buffer里的redo log&lt;strong&gt;直接持久化到磁盘中&lt;/strong&gt;，这样可以保证MySql异常重启之后数据都不会丢失。&lt;/li&gt;
&lt;li&gt;当设置该&lt;strong&gt;参数为2时候&lt;/strong&gt;，表示每次事务提交的时候，都只是&lt;strong&gt;缓存在redo log buffer 里的redo log 写到redo log 文件&lt;/strong&gt;，其实是写入到操作系统的Page Cache。
如下图
&lt;img src=&#34;https://getshhi.github.io/MySql11.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;MySql&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;那innodb_flush_log_at_trx_commit为0和2的时候啥时候才将redo-log-写入磁盘&#34;&gt;那innodb_flush_log_at_trx_commit为0和2的时候，啥时候才将redo log 写入磁盘？
&lt;/h3&gt;&lt;p&gt;当然是交给InnoDB的后台线程了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于innodb_flush_log_at_trx_commit参数为0的情况，会把缓存在redo log buffer 中的redo log，通过调用&lt;strong&gt;write()&lt;strong&gt;写到操作系统的Page Cache，然后调用&lt;/strong&gt;fsync()&lt;strong&gt;持久化到磁盘。所以参数为0的策略，MySql进程的崩溃的会导致上一秒的所有的&lt;/strong&gt;事务数据的丢失&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;对于innodb_flush_log_at_trx_commit参数为2的情况，会直接调用fsync()持久化到磁盘。所以参数为2的策略，较取值为0情况下更安全，因为MySQL进程的崩溃并不会丢失数据，只有在&lt;strong&gt;操作系统崩溃或者没电的&lt;/strong&gt;情况下，上一秒钟所有事务数据才可能丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对于这三种参数我们该如何使用&#34;&gt;对于这三种参数我们该如何使用？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对于数据安全性的话，参数1的安全性最高，其次是参数2，最后是参数0&lt;/li&gt;
&lt;li&gt;对入写入性能的话，参数0的写入性能最好，其次是参数2，最后是参数1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的场景我们使用不同的处理方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一些数据安全性要求比较高的场景中，显然参数需要设置为1。&lt;/li&gt;
&lt;li&gt;在一些可以容忍数据库崩溃时丢失1s的数据的数据，而且同时对性能有要求的话，我们可以将参数设置为0，这样的话可以明显地提高性能。&lt;/li&gt;
&lt;li&gt;如果想要折中的方案的话，可以将参数设置为2，这样既有安全性又有性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redo-log-文件写满了咋办&#34;&gt;redo log 文件写满了咋办？
&lt;/h3&gt;&lt;p&gt;MySql有两个日志文件组(redo log Group)，这个日志文件组是以&lt;strong&gt;循环写&lt;/strong&gt;的方式工作的，如果 &lt;strong&gt;write pos&lt;/strong&gt; 追上了&lt;strong&gt;checkpoint&lt;/strong&gt;，就意味着&lt;strong&gt;redo log 文件满了&lt;/strong&gt;，这时&lt;strong&gt;MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞&lt;/strong&gt;（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时&lt;strong&gt;会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）&lt;/strong&gt;，然后 MySQL 恢复正常运行，继续执行新的更新操作。&lt;/p&gt;
&lt;p&gt;这样的话就可一次将脏页刷新到磁盘中变成干净页，然后标记redo log哪些记录可以被覆盖的过程。&lt;/p&gt;
&lt;h3 id=&#34;为啥需要binlog&#34;&gt;为啥需要binlog？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;这个跟MySql的时间线有关，最开始MySql里面没有InnoDB引擎，MySQL自带的引擎是MyISAM，但是MYISAM没有crash-cafe的能力，binlog日志只能用于归档。&lt;/li&gt;
&lt;li&gt;而InnnoDB是另一个公司以插件形式引入MySQL的，既然只靠binlog是没有crash-sefe能力的，所以InnoDB使用redo log 来实现crash-safe能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redo-log-和-binlog有啥区别&#34;&gt;redo log 和 binlog有啥区别？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.写入方式不同
&lt;ul&gt;
&lt;li&gt;binlog是&lt;strong&gt;追加写&lt;/strong&gt;，写满一个文件，就创建一个新的文件继续写，保存的是全量的日志。&lt;/li&gt;
&lt;li&gt;redo log是&lt;strong&gt;循环写&lt;/strong&gt;，日志空间大小是固定，如果写满的话，就从头开始，保存未被刷入磁盘的脏页日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.用途不同
&lt;ul&gt;
&lt;li&gt;binlog用于&lt;strong&gt;备份恢复&lt;/strong&gt;，&lt;strong&gt;主从复制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;redo log 用于&lt;strong&gt;掉电等故障恢复&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.用的对象不同
&lt;ul&gt;
&lt;li&gt;binlog是&lt;strong&gt;Server层&lt;/strong&gt;实现的日志，所有的&lt;strong&gt;存储引擎&lt;/strong&gt;都可以使用。&lt;/li&gt;
&lt;li&gt;redo log仅仅适用于&lt;strong&gt;Innodb存储引擎&lt;/strong&gt;实现的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4.文件格式不同
&lt;ul&gt;
&lt;li&gt;Binlog（二进制日志）主要有以下三种格式：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;STATEMENT格式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：也称为基于SQL语句的复制（SBR，Statement - Based Replication）。在这种格式下，binlog会记录每一条修改数据的SQL语句。例如，当执行&lt;code&gt;INSERT INTO users (name, age) VALUES (&#39;John&#39;, 25)&lt;/code&gt;这条SQL语句时，binlog会将这条完整的&lt;code&gt;INSERT&lt;/code&gt;语句记录下来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
- 日志内容相对紧凑，因为它记录的是SQL语句，占用的空间比记录每一行数据变化的格式要小。例如，一条&lt;code&gt;UPDATE&lt;/code&gt;语句可能会修改多条记录，但在STATEMENT格式下，只需要记录这一条&lt;code&gt;UPDATE&lt;/code&gt;语句。
- 比较直观，易于理解。可以直接看到执行的SQL操作，方便数据库管理员（DBA）进行故障排查和审计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
- 存在一定的安全风险。如果SQL语句中包含了一些具有不确定性的函数，如&lt;code&gt;UUID()&lt;/code&gt;、&lt;code&gt;NOW()&lt;/code&gt;等，可能会导致主从数据库的数据不一致。因为这些函数在主库和从库执行时，结果可能会不同。
- 对于一些复杂的存储过程和函数，在从库上重新执行时可能会出现问题。因为主库上存储过程内部的操作细节可能依赖于主库的环境，在从库上执行相同的存储过程可能无法得到预期的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ROW格式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：基于行的复制（RBR，Row - Based Replication）。它会记录每一行数据的修改情况。比如，对一个表进行&lt;code&gt;UPDATE&lt;/code&gt;操作，它会记录更新前后每一行的具体内容。如果更新了3行数据，binlog中会详细记录这3行数据从旧值到新值的变化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
- 能够更准确地进行数据复制。因为它记录的是行级别的数据变化，所以不会受到SQL语句中不确定性因素的影响，保证了主从数据库的数据一致性。
- 对于一些包含复杂逻辑的更新操作，能够更精确地在从库上重现数据的修改过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;会产生大量的日志。因为它记录了每一行数据的变化，所以相比STATEMENT格式，日志文件可能会大很多。特别是对于一些批量操作，如批量插入或更新大量数据时，日志文件的增长速度会比较快。&lt;/li&gt;
&lt;li&gt;日志内容相对来说不那么直观，不容易直接看出执行的SQL操作，需要通过工具或者一定的解析才能了解数据变化对应的SQL操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MIXED格式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：混合了STATEMENT和ROW两种格式。MySQL会根据具体的SQL操作自动选择合适的日志记录方式。例如，对于一些简单的、确定性的SQL语句，如&lt;code&gt;UPDATE tab SET col1 = &#39;value&#39; WHERE col2 = &#39;condition&#39;&lt;/code&gt;（其中不包含不确定函数），会以STATEMENT格式记录；而对于一些复杂的操作，如包含&lt;code&gt;UUID()&lt;/code&gt;函数的&lt;code&gt;INSERT&lt;/code&gt;语句或者&lt;code&gt;UPDATE&lt;/code&gt;语句影响了大量行数据，就会以ROW格式记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;结合了STATEMENT和ROW格式的优点。在一定程度上减少了日志文件的大小，同时也保证了数据复制的准确性。&lt;/li&gt;
&lt;li&gt;可以根据实际的业务场景自动调整日志记录方式，具有较好的灵活性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;由于采用了混合的记录方式，日志的解析和管理可能会相对复杂一些。需要考虑两种记录格式的特点，对于故障排查和数据恢复操作，要求DBA对两种格式都比较熟悉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;redo log是物理日志，记录的是在某个数据页 做了啥修改，比如对xxx表空间中的yyy数据页zzz偏移量的地方做了啥更新(这个就是弄了啥变化，具体的实现这个日志没说)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主从复制是如何实现的&#34;&gt;主从复制是如何实现的？
&lt;/h3&gt;&lt;p&gt;MySQL的主从复制依赖于binlog，binlog记录MySQl上的所有变化并以二进制形式保存在磁盘上，复制的过程就是将binlog中的数据从主库传输到从库中。&lt;/p&gt;
&lt;p&gt;MySQL集群的主从复制过程分为3个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入binlog: 主库写binlog日志，提交事务，并更新本地数据。&lt;/li&gt;
&lt;li&gt;同步binlog: 把binlog复制到所有从库中，每个从库把binlog写到暂存日志中。&lt;/li&gt;
&lt;li&gt;回放binlog: 回放binlog，并更新存储引擎中的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体详细过程如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL主库在收到客户端提交事务的请求后，会先写入binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端&amp;quot;操作成功&amp;quot;的响应。&lt;/li&gt;
&lt;li&gt;从库会创建一个专门的I/O线程，连接主库的log dump线程，来接收主库的binlog日志，再把binlog信息写入relay log的中继日志中，再返回给主库&amp;quot;复制成功&amp;quot;的响应。&lt;/li&gt;
&lt;li&gt;从库会创建一个用于回放binlog的线程，去读relay log中继日志，然后回放binlog更新存储引擎中的数据，最终实现主从的数据一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的话你就可以写的时候只写主库，读的时候只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。&lt;/p&gt;
&lt;h3 id=&#34;从库是不是越多越好&#34;&gt;从库是不是越多越好？
&lt;/h3&gt;&lt;p&gt;不是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为从库数量增加，从库连接上来的I/O线程也比较多，主库也要创建同样多的log dump线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。(通常情况下一个主库一般跟2-3个从库 1套数据库，1主2从备主)，这就是一主多从的MySQL集群结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql主从复制还有哪些模型&#34;&gt;MySQL主从复制还有哪些模型？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主要有三种&lt;/li&gt;
&lt;li&gt;同步复制: MySQL主库提交事务的线程要等待所有从库的复制响应，才返回客户端结果。这种方式在实际项目中，基本没法用，原因是: 一是性能很差，因为要复制到所有节点才返回响应，二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。&lt;/li&gt;
&lt;li&gt;异步复制(默认模型): MySQL主库提交事务的线程并不会等待binlog同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。&lt;/li&gt;
&lt;li&gt;半同步复制: MySQL5.7版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。&lt;strong&gt;这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;binlog啥时候刷盘&#34;&gt;binlog啥时候刷盘？
&lt;/h3&gt;&lt;p&gt;MySQL提供一个 &lt;strong&gt;sync_binlog&lt;/strong&gt; 参数来控制数据库的 binlog 刷到磁盘上的频率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；&lt;/li&gt;
&lt;li&gt;sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；&lt;/li&gt;
&lt;li&gt;sync_binlog =N(N&amp;gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。&lt;/li&gt;
&lt;li&gt;在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。&lt;/li&gt;
&lt;li&gt;而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。&lt;/li&gt;
&lt;li&gt;如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为啥需要两阶段提交&#34;&gt;为啥需要两阶段提交？
&lt;/h3&gt;&lt;p&gt;事务提交后，redo log和binlog都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成了两份日志之间的数据不一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在将redo log刷入到磁盘中，MySQL突然宕机了，而binlog还没有来得及写入。这样的话就会造成主库的数据是新的，但是从的数据是旧的。&lt;/li&gt;
&lt;li&gt;如果在将binlog刷入到磁盘中，MySQL突然宕机了，而redo log还没有来得及写入。这样的话就会造成主库是旧的数据，而从库的数据是新的，从而导致数据不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两阶段提交的过程是咋样的&#34;&gt;两阶段提交的过程是咋样的？
&lt;/h3&gt;&lt;p&gt;事务的提交过程有两个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prepare阶段&lt;/strong&gt;: 将XID(内部XA事务的ID)写入到redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit阶段&lt;/strong&gt;: 把XID写入到binlog，然后将binlog持久化到磁盘，接着调用引擎的提交事务接口，将redo log状态设置为commit,此时该状态并不需要持久化到磁盘中，只需要write到文件系统的page cache中就够了，因为只要binlog写磁盘成功，就算redo log的状态还是prepare也没有关系，一样会被认为事务已经执行成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;两阶段提交有啥问题吗&#34;&gt;两阶段提交有啥问题吗？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;磁盘I/O次数高: 对于&amp;quot;双1&amp;quot;配置，每个事务提交都会进行两次fsync(刷盘)，一次是redo log刷盘，另一次是binlog刷盘。&lt;/li&gt;
&lt;li&gt;锁竞争激烈: 两阶段提交虽然能够保证单个事务两个日志的内容一致，但在多个事务的情况下，却不能保证两者的提交顺序一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为啥锁竞争激烈&#34;&gt;为啥锁竞争激烈？
&lt;/h3&gt;&lt;p&gt;在早期的MySQL版本中，对于一个事务来说，获取锁才能进入prepare阶段，一直到commit阶段结束才能释放锁，相当于串行化。&lt;/p&gt;
&lt;h3 id=&#34;组提交&#34;&gt;组提交
&lt;/h3&gt;&lt;p&gt;MySQL引入了binlog组提交机制，当有多个事务提交的时候，会将多个binlog刷盘操作合并成一个，从而减少磁盘I/O的次数。&lt;/p&gt;
&lt;p&gt;引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;flush 阶段:&lt;/strong&gt; 多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sync 阶段:&lt;/strong&gt; 对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit 阶段:&lt;/strong&gt; 各个事务按顺序做 InnoDB commit 操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql磁盘io很高有啥优化的方法没&#34;&gt;MySQL磁盘I/O很高，有啥优化的方法没？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但即使 MySQL 进程中途挂了，也没有丢失数据的风险，因为 binlog 早被写入到 page cache 了，只要系统没有宕机，缓存在 page cache 里的 binlog 就会被持久化到磁盘。&lt;/li&gt;
&lt;li&gt;将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机。但是这样做的风险是，主机掉电时会丢 N 个事务的 binlog 日志。&lt;/li&gt;
&lt;li&gt;将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache，专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存，然后交由操作系统控制持久化到磁盘的时机。但是这样做的风险是，主机掉电的时候会丢数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;具体更新一条记录-update-t_user-set-name--jiahao-where-id--1-的流程如下&#34;&gt;具体更新一条记录 UPDATE t_user SET name = &amp;lsquo;jiahao&amp;rsquo; WHERE id = 1; 的流程如下:
&lt;/h3&gt;&lt;p&gt;执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；&lt;/li&gt;
&lt;li&gt;如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一样的话就不进行后续更新流程；&lt;/li&gt;
&lt;li&gt;如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。&lt;/p&gt;
&lt;p&gt;InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。&lt;/p&gt;
&lt;p&gt;至此，一条记录更新完了。&lt;/p&gt;
&lt;p&gt;在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。&lt;/p&gt;
&lt;p&gt;事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；&lt;/li&gt;
&lt;li&gt;commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此，一条更新语句执行完成&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySql锁</title>
        <link>https://getshhi.github.io/p/mysql%E9%94%81/</link>
        <pubDate>Sun, 15 Dec 2024 16:07:41 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E9%94%81/</guid>
        <description>&lt;img src="https://getshhi.github.io/f2.png" alt="Featured image of post MySql锁" /&gt;&lt;h3 id=&#34;mysql的锁有哪些&#34;&gt;MySql的锁有哪些?
&lt;/h3&gt;&lt;p&gt;MySql的锁可以分为三部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局锁(&lt;strong&gt;一旦使用数据库就处于只读的状态&lt;/strong&gt;)
&lt;ul&gt;
&lt;li&gt;主要用来进行 &lt;strong&gt;全库逻辑备份&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;加上全局锁的缺点是因为是只读状态，可能会导致业务只能读数据，从而导致业务&lt;strong&gt;停滞&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表级锁
&lt;ul&gt;
&lt;li&gt;表锁
&lt;ul&gt;
&lt;li&gt;一旦实现，本线程就只能读本线程所在的表，不能访问其他的线程，其他线程的只能读该线程所在的表。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;表级别的共享锁，也就是读锁；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_student&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;表级别的独占锁，也就是写锁；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_stuent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;元数据锁(&lt;strong&gt;MDL&lt;/strong&gt;)
&lt;ul&gt;
&lt;li&gt;分为MDL读锁和MDL写锁(都是数据库自动加的MDL)对一张表进行CRUD操作时，加的是MDL读锁，对一张表做结构变更操作的时候，加的是MDL写锁。&lt;/li&gt;
&lt;li&gt;MDL在事务执行期间，MDL是一直持有的。&lt;/li&gt;
&lt;li&gt;MDL写锁获取优先级高于MDL读锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;意向锁
&lt;ul&gt;
&lt;li&gt;意向锁简单来说就是提前说明记录是否存在共享锁和独占锁。&lt;/li&gt;
&lt;li&gt;意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享锁和独占表锁发生冲突。&lt;/li&gt;
&lt;li&gt;意向锁的目的就是为了判断表里是否有记录被加锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AUTO-INC锁
&lt;ul&gt;
&lt;li&gt;AUTO-INC锁的作用就是自动增加主键的值。&lt;/li&gt;
&lt;li&gt;锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放。&lt;/li&gt;
&lt;li&gt;在插入数据时，会加一个表级别的AUTO-INC锁。&lt;/li&gt;
&lt;li&gt;从MySql5.1.22版本开始，InnoDB存储引擎提供了一种轻量级的锁来实现自增。&lt;/li&gt;
&lt;li&gt;对于解决InnoDB的数据库一致性问题，可以采用&lt;strong&gt;innodb_autoinc_lock_mode = 2&lt;/strong&gt;，并且&lt;strong&gt;binlog_format = row&lt;/strong&gt;，既能提高并发性，又不会出现数据一致性问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行级锁(基于InnoDB)
&lt;ul&gt;
&lt;li&gt;Record Lock(&lt;strong&gt;记录锁&lt;/strong&gt;)
&lt;ul&gt;
&lt;li&gt;S型记录锁(S型与S型兼容，S型与X型不兼容，X型与X型也不兼容)&lt;/li&gt;
&lt;li&gt;X型记录锁(S型与S型兼容，S型与X型不兼容，X型与X型也不兼容)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gap Lock(&lt;strong&gt;间隙锁&lt;/strong&gt;)
&lt;ul&gt;
&lt;li&gt;间隙锁只存在可重复读隔离级别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入缓影记录而提出的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Next-Key Lock(&lt;strong&gt;间隙锁加记录锁-临键锁&lt;/strong&gt;)
Next-key lock是包含间隙锁+记录锁的，如果一个事务获取了X型的next-key lock,那么另外一个事务在获取相同范围的X型的间隙锁时，是会被阻塞的。&lt;/li&gt;
&lt;li&gt;插入意向锁
&lt;ul&gt;
&lt;li&gt;插入意向锁不是意向锁，它是一种特殊的间隙锁，属于行级别锁。&lt;/li&gt;
&lt;li&gt;一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁，如果有的话，插入操作就会发生阻塞，直到有间隙锁的那个事务提交为止，在此期间会生成一个插入意向锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql是咋加锁的&#34;&gt;MySql是咋加锁的？
&lt;/h3&gt;&lt;h4 id=&#34;啥sql语句会加行级锁&#34;&gt;啥SQL语句会加行级锁？
&lt;/h4&gt;&lt;p&gt;首先对于支持加行级锁的只有InnoDB，而对于InnoDB存储引擎加锁的语句为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;对读取的记录加共享锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S型锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;share&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;对读取的记录加独占锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X型锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;对操作的记录加独占锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X型锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;对操作的记录加独占锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X型锁&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;update和delete&lt;/strong&gt;操作都会加行级锁，且锁的类型都是独占锁(X型锁)&lt;/p&gt;
&lt;h3 id=&#34;mysql是咋加行级锁&#34;&gt;MySql是咋加行级锁？
&lt;/h3&gt;&lt;p&gt;MySQL行级锁的加锁规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;唯一索引等值查询
&lt;ul&gt;
&lt;li&gt;当查询的记录是存在的，在索引树上定位到这一条记录后，将该记录的索引中的next-key lock会退化成&lt;strong&gt;记录锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当查询的记录是不存在的，在索引树上找到第一条大于该记录的记录后，将该记录的索引中的next-key lock 会退化成&lt;strong&gt;间隙锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;唯一索引范围查询
&lt;ul&gt;
&lt;li&gt;针对&lt;strong&gt;大于等于&lt;/strong&gt;的范围查询，因为存在等值的查询，那么等值查询的记录存在的话，那么该记录的索引中的next-key锁会退化成记录锁&lt;/li&gt;
&lt;li&gt;针对&lt;strong&gt;小于或者小于等于&lt;/strong&gt;的范围查询，要看条件值的记录是否存在于表中:
&lt;ul&gt;
&lt;li&gt;当条件值得记录不在表中，那么不管是小于还是小于等于条件的范围查询，扫描到&lt;strong&gt;终止范围查询的记录&lt;/strong&gt;时，该记录的索引的next-key锁会退化成&lt;strong&gt;间隙锁&lt;/strong&gt;，其他扫描的记录，都是在这些记录的索引上加next-key锁。&lt;/li&gt;
&lt;li&gt;当条件值的记录在表中，如果是&lt;strong&gt;小于&lt;/strong&gt;条件的范围查询，扫描到&lt;strong&gt;终止范围查询的记录&lt;/strong&gt;时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果&lt;strong&gt;小于等于&lt;/strong&gt;条件的范围查询，扫描到&lt;strong&gt;终止范围查询的记录&lt;/strong&gt;时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为存在两个索引，一个是主键索引，一个是非唯一索引(二级索引)，所以在加锁的时候，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非唯一索引等值查询
&lt;ul&gt;
&lt;li&gt;当查询的记录存在时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描的二级索引记录加的是next-key锁，而对于&lt;strong&gt;第一个不符合条件的二级索引记录&lt;/strong&gt;，该二级索引的&lt;strong&gt;next-key锁&lt;/strong&gt;会退化成&lt;strong&gt;间隙锁&lt;/strong&gt;，同时，在符合查询条件的记录的主键索引上加&lt;strong&gt;记录锁&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当查询的记录不存在时，扫描到&lt;strong&gt;第一条不符合条件的二级索引记录&lt;/strong&gt;，该二级索引的&lt;strong&gt;next-key锁&lt;/strong&gt;会退化成&lt;strong&gt;间隙锁&lt;/strong&gt;。因为不存在满足查询条件的记录，所以&lt;strong&gt;不会&lt;/strong&gt;对&lt;strong&gt;主键索引加锁&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非唯一索引范围查询
&lt;ul&gt;
&lt;li&gt;该查询进行时，索引的next-key lock &lt;strong&gt;不会有退化&lt;/strong&gt;为间隙锁和记录锁的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;没有加索引的查询
&lt;ul&gt;
&lt;li&gt;如果锁定读查询语句，没有使用&lt;strong&gt;索引&lt;/strong&gt;列作为查询条件，或者查询语句没有走&lt;strong&gt;索引查询&lt;/strong&gt;，导致扫描是全表扫描。那么，每一条记录的索引上都会加&lt;strong&gt;next-key锁&lt;/strong&gt;，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。&lt;/li&gt;
&lt;li&gt;在线上在执行 update、delete、select &amp;hellip; for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;update没加索引会锁全表&#34;&gt;update没加索引会锁全表？
&lt;/h3&gt;&lt;p&gt;为啥会发生这种事故？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能是在update语句的where条件没有使用索引，就会全表扫描，于是就会对所有记录加上next-key锁，相当于加的是表锁。(相当于把整个表锁住了)&lt;/li&gt;
&lt;li&gt;上面的情况为啥是可能，因为决定全表扫描的是MySql中的优化器决定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何避免这种事故？&lt;/p&gt;
&lt;p&gt;主观做法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一定要为需要经常更新的字段加上索引，且执行update语句必须加上where条件。
客观做法&lt;/li&gt;
&lt;li&gt;我们可以将 MySQL 里的 sql_safe_updates 参数设置为 1，开启安全更新模式。&lt;/li&gt;
&lt;li&gt;MySQL 里的 sql_safe_updates的原理和作用&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;防止意外的大规模数据修改&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;：在&lt;code&gt;sql_safe_updates&lt;/code&gt;设置为非0值（通常为1）时，MySQL对于&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;操作有更严格的限制。这是为了避免因错误的&lt;code&gt;WHERE&lt;/code&gt;条件或者缺少合适的限制条件而导致大量数据被意外修改或删除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：假设你有一个包含100万条客户记录的&lt;code&gt;customers&lt;/code&gt;表。如果&lt;code&gt;sql_safe_updates&lt;/code&gt;为0，执行&lt;code&gt;UPDATE customers SET status = &#39;inactive&#39;&lt;/code&gt;这样没有&lt;code&gt;WHERE&lt;/code&gt;条件的语句，会将表中所有客户的状态都更新为&lt;code&gt;inactive&lt;/code&gt;。但如果&lt;code&gt;sql_safe_updates&lt;/code&gt;为1，这个操作就会被阻止，因为它既没有使用键（例如&lt;code&gt;customer_id&lt;/code&gt;）来限制更新范围，也没有&lt;code&gt;LIMIT&lt;/code&gt;子句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高数据安全性和稳定性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于开发环境&lt;/strong&gt;：在开发过程中，开发人员可能会频繁地编写和测试&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;语句。开启&lt;code&gt;sql_safe_updates&lt;/code&gt;可以作为一种安全机制，减少因代码错误而对数据造成不可逆损坏的风险。例如，新手开发人员可能在测试&lt;code&gt;UPDATE&lt;/code&gt;语句时，忘记添加&lt;code&gt;WHERE&lt;/code&gt;条件，有了这个设置可以避免这种错误操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对于生产环境&lt;/strong&gt;：虽然在生产环境中通常会有更严格的代码审查和测试流程，但意外情况仍可能发生。开启&lt;code&gt;sql_safe_updates&lt;/code&gt;可以作为额外的一层保护，防止恶意或误操作对重要数据的破坏。比如，防止有人在数据库管理工具中不小心执行了无限制的&lt;code&gt;DELETE&lt;/code&gt;语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强制使用合适的更新和删除策略&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;促进正确的SQL编写习惯&lt;/strong&gt;：要求&lt;code&gt;UPDATE&lt;/code&gt;语句在&lt;code&gt;WHERE&lt;/code&gt;子句中使用键或者有&lt;code&gt;LIMIT&lt;/code&gt;子句，以及&lt;code&gt;DELETE&lt;/code&gt;语句同时具备这两个条件，有助于开发人员养成更谨慎、更精确的SQL编写习惯。例如，开发人员会更加注意在&lt;code&gt;UPDATE&lt;/code&gt;语句中使用索引列作为&lt;code&gt;WHERE&lt;/code&gt;条件，这样不仅能避免大规模的数据修改，还能提高查询性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与索引使用的关联&lt;/strong&gt;：通过强制使用键（索引），间接鼓励开发人员合理利用索引来优化&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;操作。这与数据库的性能优化是紧密相关的，因为正确使用索引可以减少锁的范围，提高数据库的并发处理能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql记录锁间隙锁可以防止删除操作而导致的吗&#34;&gt;MySQL记录锁+间隙锁可以防止删除操作而导致的吗?
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可以的，对于MySql的可重复读隔离级别下，针对当前读的语句不会出现幻读的现象，因为MVCC机制，对于在快照读的情况下，next-key锁可以避免幻读的现象，因为锁不让进行插入，删除，更新等操作(该锁是X型独占锁)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mysql死锁了咋办&#34;&gt;MySQL死锁了，咋办？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;啥是死锁？
&lt;ul&gt;
&lt;li&gt;根据&lt;strong&gt;操作系统&lt;/strong&gt;的官方定义来讲的话，就是多个进程互相拥有对方的所需的资源，但是都不放弃自己的资源，从而形成循环等待链，形成僵局。&lt;/li&gt;
&lt;li&gt;从数据库的角度来看的话就是一个业务或多个业务在进行&lt;strong&gt;幂等性校验&lt;/strong&gt;时，进行快照读，然后互相占有锁，这样就造成了死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何避免死锁？
&lt;ul&gt;
&lt;li&gt;死锁的四个必要条件:&lt;strong&gt;互斥&lt;/strong&gt;，&lt;strong&gt;占有且等待&lt;/strong&gt;，&lt;strong&gt;不可强占用&lt;/strong&gt;，&lt;strong&gt;循环等待&lt;/strong&gt;。对于这四个条件只要破坏其中任意一个条件就行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设置事务等待锁的超时时间&lt;/strong&gt;，这个是破坏了占有且等待的条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启主动死锁检测&lt;/strong&gt;，破坏了&lt;strong&gt;循环等待&lt;/strong&gt;的条件。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySql事务</title>
        <link>https://getshhi.github.io/p/mysql%E4%BA%8B%E5%8A%A1/</link>
        <pubDate>Fri, 13 Dec 2024 12:13:39 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E4%BA%8B%E5%8A%A1/</guid>
        <description>&lt;img src="https://getshhi.github.io/f5.png" alt="Featured image of post MySql事务" /&gt;&lt;h4 id=&#34;事务有哪些特性&#34;&gt;事务有哪些特性?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;原子性，类似于操作系统中的原语，要不全部完成，要不全部不完成，不会结束在中间某个环节。
原子性是通过undo log(回滚日志)实现的。&lt;/li&gt;
&lt;li&gt;一致性，是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如你买了个东西花了200元，卖家赚了200元，但这个200元还在数据库中。一致性是通过持久性，原子性，隔离性共同实现的。&lt;/li&gt;
&lt;li&gt;隔离性，是指数据库允许多个并发事务同时对其数据进行读写和修改的能力，也就是说消费者买东西是不影响另一个消费者的。隔离性是通过MVCC(多版本并发控制)或锁机制来保证的。&lt;/li&gt;
&lt;li&gt;持久性，是指事务结束后，对数据的修改就是永久的，即使系统故障也不会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;并行事务会引发啥问题&#34;&gt;并行事务会引发啥问题?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;脏读，脏读就是一个事务读的数据是另一个未提交事务修改得到的数据。&lt;/li&gt;
&lt;li&gt;不可重复读，不可重复读就是在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就代表着发生了不可重复读。&lt;/li&gt;
&lt;li&gt;幻读，幻读就是在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着产生了幻读现象。(是不是幻读很懵逼的感觉，哈哈😁)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务的隔离级别有哪些&#34;&gt;事务的隔离级别有哪些
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;读未提交，指一个事务还没提交时，它做的变更就能被其他事务看到。这个的话，会出现幻读，不可重复读，脏读。&lt;/li&gt;
&lt;li&gt;读提交，指一个事务提交时，它做的变才能被其他事务看到。这个的话，会出现不可重复读，脏读。&lt;/li&gt;
&lt;li&gt;可重复读，指一个事务执行中中看到的数据，一直跟这个事务启动看到的数据是一致的，也就是MySQL InnoDB引擎的默认隔离级别。&lt;/li&gt;
&lt;li&gt;串行锁; 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能执行。(是不是跟操作系统的p-v操作很像呢)。这个不会出现问题，但会性能较低。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;read-vied-在mvcc里如何工作的&#34;&gt;Read Vied 在MVCC里如何工作的?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;首先我们需要了解Read Vied 的四个字段的作用
&lt;ul&gt;
&lt;li&gt;creator_trx_id就是创建该Reda View的事务的事务id。&lt;/li&gt;
&lt;li&gt;m_ids是指当前活跃并且未提交的事务id列表。&lt;/li&gt;
&lt;li&gt;min_trx_id，是指m_ids中最小事务的事务id。&lt;/li&gt;
&lt;li&gt;max_trx_id，是指该事务中这个事务中的id+1。
一般会出现几种情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果一个事务的id小于min_trx_id的话，那说明这个事务对于当前的事务是个旧的记录，所存在的是当前事务可见的。&lt;/li&gt;
&lt;li&gt;如果一个事务的id不小于min_trx_id的话，并且不大于max_trx_id，并且在m_ids中，说明该版本的记录对当前的事务不可见，如果不在max_trx_id中，说明该版本的记录对当前的事务可见。&lt;/li&gt;
&lt;li&gt;如果一个事务的id大于max_trx_id的话，说明该版本的记录对当前的事务不可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可重复度读读底层原理是啥&#34;&gt;可重复度读读底层原理是啥？
&lt;/h4&gt;&lt;p&gt;可重复读隔离级别是启动事务时生成一个Read View，然后整个事务期间都在用这个Read View。&lt;/p&gt;
&lt;p&gt;「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。&lt;/p&gt;
&lt;h4 id=&#34;读提交的底层原理是啥&#34;&gt;读提交的底层原理是啥?
&lt;/h4&gt;&lt;p&gt;读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。&lt;/p&gt;
&lt;h4 id=&#34;mysql-innodb-引擎的可重复读隔离级别默认隔离级根据不同的查询方式分别提出了避免幻读的方案&#34;&gt;MySQL InnoDB 引擎的可重复读隔离级别（默认隔离级），根据不同的查询方式，分别提出了避免幻读的方案:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读。&lt;/li&gt;
&lt;li&gt;针对当前读（select &amp;hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;会发生幻读的例子&#34;&gt;会发生幻读的例子
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于快照读，MVCC并不能完全避免幻读现象，因为当一个事务更新了另一条事务插入的记录，那么事务前后查询的记录条目就不一样的，所以就发生幻读。&lt;/li&gt;
&lt;li&gt;对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他数据插入了一条数据，那么事务后续使用当前进行查询的时候，就会发现前后查询的记录条目就不一样的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySql索引</title>
        <link>https://getshhi.github.io/p/mysql%E7%B4%A2%E5%BC%95/</link>
        <pubDate>Thu, 05 Dec 2024 13:11:20 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E7%B4%A2%E5%BC%95/</guid>
        <description>&lt;img src="https://getshhi.github.io/bk.png" alt="Featured image of post MySql索引" /&gt;&lt;h4 id=&#34;为啥mysql-innodb-选择btree作为索引的数据结构&#34;&gt;为啥MySQL InnoDB 选择B+tree作为索引的数据结构？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;B+Tree vs B Tree:
&lt;ul&gt;
&lt;li&gt;B+Tree只有叶子节点存储数据，而B Tree索引和数据都存，这样会导致在相同的条件下，B Tree的一个数据节点能够存储的索引减少，导致B Tree的深度会较长，从而造成IO时间较长，性能较差。&lt;/li&gt;
&lt;li&gt;B+Tree 的叶子节点是用双链表进行连接的，进行范围查询较为方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B+Tree vs 二叉树
&lt;ul&gt;
&lt;li&gt;对于二叉树来说，有可能会退化成时间复杂度为O(n)的(对于插入操作一直插入大的或一直小的)。&lt;/li&gt;
&lt;li&gt;对于二叉树来说，仅仅能存储一个索引，会导致层数增加，从而导致IO时间较长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B+Tree vs Hash
&lt;ul&gt;
&lt;li&gt;对于Hash来说，Hash不能进行范围查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;啥时候使用索引&#34;&gt;啥时候使用索引？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;字段有限制的，适合当索引。&lt;/li&gt;
&lt;li&gt;经常用于WHERE查询条件的字段。&lt;/li&gt;
&lt;li&gt;经常用ORDER BY 和GROUP BY的字段。&lt;/li&gt;
&lt;li&gt;尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，
避免回表，提高查询效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;啥时候不使用索引&#34;&gt;啥时候不使用索引？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;字段中存在大量重复数据，不需要创建索引。&lt;/li&gt;
&lt;li&gt;WHERE条件，GROUP BY，ORDER BY 里用不到的字段。&lt;/li&gt;
&lt;li&gt;经常需要更新的表，查询频率较小的表。&lt;/li&gt;
&lt;li&gt;字段中存在大量重复数据，不需要创建索引。&lt;/li&gt;
&lt;li&gt;表数据较少的不用创建索引，数据较少时全表查询效率已经很高了，如果加入索引会增加存储压力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;啥时候索引会失效&#34;&gt;啥时候索引会失效？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;不符合最左匹配原则的。&lt;/li&gt;
&lt;li&gt;模糊查询用%x和%x%的。&lt;/li&gt;
&lt;li&gt;将索引加入计算的表达式中。&lt;/li&gt;
&lt;li&gt;将索引加入函数中。&lt;/li&gt;
&lt;li&gt;在WHERE从句中的输入为字符串，但是字段的属性为INT类型。&lt;/li&gt;
&lt;li&gt;WHERE 子句中的 OR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。(解决方案:可以采让全部都是)&lt;/p&gt;
&lt;h4 id=&#34;有啥优化索引的方法&#34;&gt;有啥优化索引的方法？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;前缀索引优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖索引优化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以建立一个联合索引，即「分组ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引最好是自增的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。&lt;/p&gt;
&lt;p&gt;如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;防止索引失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果索引失效的话，那么这个索引将会失效，这个索引将会不起作用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引最好设置为NOT NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。&lt;/p&gt;
&lt;p&gt;第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中至少会用 1 字节空间存储 NULL 值列表。&lt;/p&gt;
&lt;h4 id=&#34;啥是索引&#34;&gt;啥是索引？
&lt;/h4&gt;&lt;p&gt;索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足
特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构
上实现高级查找算法，这种数据结构就是索引。(可以类比书籍的目录，简单来说就是用于快速检索数据的数据结构)&lt;/p&gt;
&lt;h4 id=&#34;不同存储引擎支持的索引结构&#34;&gt;不同存储引擎支持的索引结构
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;索引&lt;/th&gt;
          &lt;th&gt;InnoDB&lt;/th&gt;
          &lt;th&gt;MyISAM&lt;/th&gt;
          &lt;th&gt;Memory&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;B+tree索引&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Hash 索引&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;R-tree 索引&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Full-text&lt;/td&gt;
          &lt;td&gt;5.6版本之后支持&lt;/td&gt;
          &lt;td&gt;支持&lt;/td&gt;
          &lt;td&gt;不支持&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;索引分类&#34;&gt;索引分类
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;按照数据结构分类&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;索引结构&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;B+Tree索引&lt;/td&gt;
          &lt;td&gt;最常见的索引类型，大部分引擎都支持 B+ 树索引&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Hash索引&lt;/td&gt;
          &lt;td&gt;底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;R-tree (空间索引）&lt;/td&gt;
          &lt;td&gt;空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Full-text(全文索引)&lt;/td&gt;
          &lt;td&gt;是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;按照物理存储分类&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;分类&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;聚集索引(ClusteredIndex)&lt;/td&gt;
          &lt;td&gt;将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据&lt;/td&gt;
          &lt;td&gt;必须有,而且只有一个&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二级索引(SecondaryIndex)&lt;/td&gt;
          &lt;td&gt;将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键&lt;/td&gt;
          &lt;td&gt;可以存在多个&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;按照字段特性分类&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;分类&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
          &lt;th&gt;关键字&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;主键索引&lt;/td&gt;
          &lt;td&gt;针对于表中主键创建的索引&lt;/td&gt;
          &lt;td&gt;默认自动创建, 只能有一个&lt;/td&gt;
          &lt;td&gt;PRIMARY&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;唯一索引&lt;/td&gt;
          &lt;td&gt;避免同一个表中某数据列中的值重复&lt;/td&gt;
          &lt;td&gt;可以有多个&lt;/td&gt;
          &lt;td&gt;UNIQUE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;常规索引&lt;/td&gt;
          &lt;td&gt;快速定位特定数据&lt;/td&gt;
          &lt;td&gt;可以有多个&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;全文索引&lt;/td&gt;
          &lt;td&gt;全文索引查找的是文本中的关键词，而不是比较索引中的值&lt;/td&gt;
          &lt;td&gt;可以有多个&lt;/td&gt;
          &lt;td&gt;FULLTEXT&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;按照字段个数分类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分为单列索引和联合索引&lt;/p&gt;
&lt;h4 id=&#34;索引设计原则&#34;&gt;索引设计原则
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1 针对于数据量较大，且查询比较频繁的表建立索引。&lt;/li&gt;
&lt;li&gt;2 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索
引。&lt;/li&gt;
&lt;li&gt;3 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。&lt;/li&gt;
&lt;li&gt;4 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。&lt;/li&gt;
&lt;li&gt;5 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，
避免回表，提高查询效率。&lt;/li&gt;
&lt;li&gt;6 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增
删改的效率。&lt;/li&gt;
&lt;li&gt;7 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mysql单表不要超过2000w行靠谱吗&#34;&gt;MySQL单表不要超过2000W行，靠谱吗？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这个不是靠谱的，因为MySQL的行数与这个数据的大小有关系，对于不同的数据大小自然有不同的评判标准，我们应该根据B+树不能超过3层和具体的业务等等来进行判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哪种count性能最好&#34;&gt;哪种count性能最好？
&lt;/h4&gt;&lt;p&gt;count(*) = count(1) &amp;gt; count(主键字段) &amp;gt; count(普通字段)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。&lt;/li&gt;
&lt;li&gt;count(1) == count(*)的原因是 InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.&lt;/li&gt;
&lt;li&gt;count(1) 和count(*) 比count(主键字段)高效的原因是前两者不用判断是否为null&lt;/li&gt;
&lt;li&gt;不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;为啥innodb要通过遍历的方式来计数&#34;&gt;为啥InnoDB要通过遍历的方式来计数？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;因为InnoDBInnoDB 存储引擎是支持事务的，同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;如何优化count&#34;&gt;如何优化count(*)?
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;可以采用近似值。
浏览器的搜索就是采用这个的。&lt;/li&gt;
&lt;li&gt;采用额外表保存计数值。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySql基础</title>
        <link>https://getshhi.github.io/p/mysql%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Wed, 04 Dec 2024 18:42:40 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;img src="https://getshhi.github.io/kj4.png" alt="Featured image of post MySql基础" /&gt;&lt;h4 id=&#34;mysql内部结构&#34;&gt;MySql内部结构
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://getshhi.github.io/MySql1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;执行一条select语句期间发生了啥&#34;&gt;执行一条select语句，期间发生了啥？
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;先说结论&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先客户端会与服务端的连接器进行连接，连接器会检查客户端传来的账号，密码，核对一下是否正确，如果正确，就会开始读取所属的用户和用户权限，并把这个信息保存在连接器中，如果不正确，会返回错误。&lt;/li&gt;
&lt;li&gt;然后开始查询缓存(针对已经查过的数据，会以key-value的形式存储在缓存中)，如果key中有对应的值，则直接返回其value值。(MySQL 8.0已经删除这个模块)&lt;/li&gt;
&lt;li&gt;其次会解析SQL，解析器会先进行词法分析，然后进行语法分析，构造语法树，如果语法错误，会返回错误。&lt;/li&gt;
&lt;li&gt;最后执行SQL，首先在预处理器中会判断是否缺少字段，然后在优化器中选择合适的SQL查询方案，尽可能地提高性能，最后在执行器中按照执行计划执行SQL查询语句，从存储引擎读取记录，返回给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;逐步分析&#34;&gt;逐步分析
&lt;/h4&gt;&lt;h5 id=&#34;连接器&#34;&gt;连接器
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;与客户端进行 TCP 三次握手建立连接；&lt;/li&gt;
&lt;li&gt;校验客户端的用户名和密码，如果用户名或密码不对，则会报错；&lt;/li&gt;
&lt;li&gt;如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;查询缓存&#34;&gt;查询缓存
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。&lt;/li&gt;
&lt;li&gt;如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。&lt;/li&gt;
&lt;li&gt;其实这个很无用(对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。)，所以MySQL 8.0 版本直接将查询缓存删掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;解析sql&#34;&gt;解析SQL
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;第一件事，词法分析。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from；&lt;/li&gt;
&lt;li&gt;第二件事语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;执行sql&#34;&gt;执行SQL
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;预处理器
&lt;ul&gt;
&lt;li&gt;检查 SQL 查询语句中的表或者字段是否存在；&lt;/li&gt;
&lt;li&gt;将 select Fields 中的内容扩展为该有的列；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化器
&lt;ul&gt;
&lt;li&gt;主要负责将SQL查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行器
&lt;ul&gt;
&lt;li&gt;主键索引查询&lt;/li&gt;
&lt;li&gt;全表扫描&lt;/li&gt;
&lt;li&gt;索引下推&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;最终的效果图&#34;&gt;最终的效果图
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://getshhi.github.io/MySql2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;mysql的数据存放在哪个文件&#34;&gt;MySql的数据存放在哪个文件？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于MySql5.7来说
&lt;img src=&#34;https://getshhi.github.io/MySql3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;ul&gt;
&lt;li&gt;db.opt，用来存储当前数据库的默认字符集和字符校验规则。&lt;/li&gt;
&lt;li&gt;student.frm，student的表结构会保存在这个文件中。&lt;/li&gt;
&lt;li&gt;student.ibd，student的表数据会保存在这个文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于MySql8.0来说
&lt;img src=&#34;https://getshhi.github.io/MySql4.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;ul&gt;
&lt;li&gt;这个ibd文件中不仅存放表结构、数据，还会存放该表对应的索引信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;表空间文件的结构是啥&#34;&gt;表空间文件的结构是啥？
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://getshhi.github.io/MySql5.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。&lt;/li&gt;
&lt;li&gt;段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。&lt;/li&gt;
&lt;li&gt;区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。&lt;/li&gt;
&lt;li&gt;页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。&lt;/li&gt;
&lt;li&gt;行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;innodb-行格式有哪些&#34;&gt;InnoDB 行格式有哪些？
&lt;/h4&gt;&lt;p&gt;InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。&lt;/li&gt;
&lt;li&gt;由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。&lt;/li&gt;
&lt;li&gt;Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;compact-行格式长什么样&#34;&gt;COMPACT 行格式长什么样？
&lt;/h4&gt;&lt;p&gt;主要分为真实数据和额外的信息，图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://getshhi.github.io/MySql6.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;为什么变长字段长度列表的信息要按照逆序存放&#34;&gt;为什么「变长字段长度列表」的信息要按照逆序存放？
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;逆序存放变长字段长度列表可以使得位置靠前的记录的&lt;strong&gt;真实数据和数据对应的字段长度信息&lt;/strong&gt;同时在&lt;strong&gt;一个CPU Cache Line&lt;/strong&gt;中。这有助于&lt;strong&gt;提高CPU缓存的命中率&lt;/strong&gt;，从而加快数据访问速度。&lt;/li&gt;
&lt;li&gt;当读取记录时，首先读取的是&lt;strong&gt;记录头信息&lt;/strong&gt;，然后根据变长字段长度列表中的信息，从后往前读取各个字段的长度，进而确定每个字段的&lt;strong&gt;起始位置和长度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这种设计还有助于减少磁盘I/O操作，因为相关的长度信息和数据可以一起被加载到内存中，减少了额外的读取次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;varcharn最大取值为多少&#34;&gt;varchar(n)最大取值为多少？
&lt;/h4&gt;&lt;p&gt;不管是单字段还是多字段，算 varchar(n) 中 n 最大值时，都需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。&lt;/p&gt;
&lt;h4 id=&#34;行溢出后mysql是咋处理的&#34;&gt;行溢出后，MySQL是咋处理的?
&lt;/h4&gt;&lt;p&gt;InnoDB存储引擎会自动将溢出的数据存放到[溢出页]中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compact行溢出时，会保存该列的一部分数据，而把剩余的数据放在[溢出页]中，然后真实数据处用20字节存储指向溢出页的地址，从而可以找到剩余数据的页。&lt;/li&gt;
&lt;li&gt;Compressed和Dynamic这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储20个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>MySql的基本用法</title>
        <link>https://getshhi.github.io/p/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
        <pubDate>Sat, 30 Nov 2024 16:37:58 +0800</pubDate>
        
        <guid>https://getshhi.github.io/p/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
        <description>&lt;img src="https://getshhi.github.io/jk1.png" alt="Featured image of post MySql的基本用法" /&gt;&lt;h3 id=&#34;1ddl语句&#34;&gt;1.DDL语句
&lt;/h3&gt;&lt;p&gt;DDL用于定义和修改数据库结构，包括创建、修改和删除表、索引等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CREATE: 创建数据库、表或视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DATABASE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_database&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;ALTER: 修改现有的数据库结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ALTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ADD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COLUMN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;DROP: 删除数据库、表或视图。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;DROP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DATABASE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_database&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DROP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;TRUNCATE: 清空表中的所有数据，但保留表结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;TRUNCATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DML (Data Manipulation Language)
DML用于插入、更新和删除表中的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;INSERT: 向表中插入新数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;INSERT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INTO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;John Doe&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;UPDATE: 更新表中的现有数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;UPDATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Jane Doe&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;DELETE: 从表中删除数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;DELETE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DCL (Data Control Language)
DCL用于控制对数据库的访问权限。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;GRANT: 授予用户权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;GRANT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ALL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ON&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_database&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TO&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;REVOKE: 撤销用户权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;REVOKE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ALL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ON&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_database&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;user&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;host&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;TCL (Transaction Control Language)
TCL用于管理事务，确保数据的一致性和完整性。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;COMMIT: 提交当前事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;COMMIT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;ROLLBACK: 回滚当前事务。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;ROLLBACK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;SAVEPOINT: 设置保存点（在事务中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;SAVEPOINT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;savepoint_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;RELEASE SAVEPOINT: 释放保存点。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;RELEASE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SAVEPOINT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;savepoint_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;DQL (Data Query Language)
DQL用于查询数据库中的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;SELECT: 从表中检索数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;JOIN: 连接多个表。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;JOIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ON&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;6.Other Common SQL Clauses and Functions
其他常见的SQL子句和函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WHERE: 过滤条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;ORDER BY: 排序结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ASC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;GROUP BY: 分组数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COUNT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;as&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;GROUP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;HAVING: 过滤分组后的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;COUNT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;as&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;GROUP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;HAVING&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;UNION: 合并多个查询的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;UNION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;7.注意事项
在编写MySQL查询时，SQL语句的子句和函数的顺序通常遵循一定的规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELECT: 指定要选择的列。&lt;/li&gt;
&lt;li&gt;FROM: 指定数据来源的表。&lt;/li&gt;
&lt;li&gt;JOIN: 如果有多个表进行连接，使用 JOIN 子句。&lt;/li&gt;
&lt;li&gt;WHERE: 过滤记录的条件。&lt;/li&gt;
&lt;li&gt;GROUP BY: 对结果集进行分组。&lt;/li&gt;
&lt;li&gt;HAVING: 对分组后的结果进行过滤。&lt;/li&gt;
&lt;li&gt;ORDER BY: 对结果集进行排序。&lt;/li&gt;
&lt;li&gt;LIMIT: 限制返回的记录数。&lt;/li&gt;
&lt;li&gt;OFFSET: 跳过指定数量的记录（通常与 LIMIT 一起使用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aggregate_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;JOIN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ON&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;common_column&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;common_column&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;condition&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;GROUP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;HAVING&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aggregate_condition&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ORDER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ASC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;column2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DESC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LIMIT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;OFFSET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
